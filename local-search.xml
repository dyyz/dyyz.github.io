<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JAVA基础面试题</title>
    <link href="/2024/02/20/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2024/02/20/%E9%9D%A2%E8%AF%95/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>JAVA面试题汇总</p><span id="more"></span><h2 id="JVM、JRE、JDK"><a href="#JVM、JRE、JDK" class="headerlink" title="JVM、JRE、JDK"></a>JVM、JRE、JDK</h2><h3 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h3><p>java虚拟机，解释.class文件  </p><h3 id="jre"><a href="#jre" class="headerlink" title="jre"></a>jre</h3><p>java运行环境，包含jvm和java核心类库<br>解释.class文件jvm需要调用解释所需要的类库(lib)<br>运行环境，不提供编译、调试等功能  </p><h3 id="jdk"><a href="#jdk" class="headerlink" title="jdk"></a>jdk</h3><p>java开发环境，包含jre、java基础类库、java开发工具<br><img src="/'/images/jvm/jvm.png'" title="jvm运行"></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA进阶面试题</title>
    <link href="/2023/12/31/%E9%9D%A2%E8%AF%95/JAVA%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/12/31/%E9%9D%A2%E8%AF%95/JAVA%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<p>JAVA进阶面试</p><span id="more"></span><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>解耦</li><li>异步</li><li>削峰</li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>系统可用性降低</li><li>系统复杂度提高</li><li>一致性问题</li></ul><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级</td><td>同ActiveMQ</td><td>10万级，高吞吐</td><td>10万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic数量对吞吐量的影响</td><td></td><td></td><td>topic可以达到几百&#x2F;几千的级别，吞吐量较小幅度的下降</td><td>从几十到几百个时候，吞吐量会大幅下降，支持大规模的topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms级</td><td>微秒级</td><td>ms级</td><td>延迟在ms级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构</td><td>同ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>较低的概率丢失数据</td><td>基本不丢</td><td>参数优化配置，0丢失</td><td>同RocketMQ</td></tr><tr><td>功能支持</td><td>MQ领域的功能极其完备</td><td>并发能力强，性能极好，延时很低</td><td>MQ功能晚上，分布式，扩展性好</td><td>支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><ol><li>单机模式</li><li>普通集群模式（无高可用性）</li></ol><p>创建的queue只会放在一个RabbitMQ实例上。随机拉取数据，数据拉取开销；固定连接，单实例性能瓶颈</p><p>queue实例宕机，其他实例无法拉取；开启消息持久化，消息不一定会丢</p><ol start="3"><li>镜像集群模式（高可用性）</li></ol><p>创建的queue存在于多个实例上，自动把消息同步</p><p>坏处：性能开销大、扩展性低</p><h2 id="消息队列的幂等性"><a href="#消息队列的幂等性" class="headerlink" title="消息队列的幂等性"></a>消息队列的幂等性</h2><ul><li>MySQL 主键查一下，有，更新，否则插入</li><li>Redis set,天然幂等性</li><li>生产者的每条数据中加一个全局唯一的id，redis里查询，消费过不处理</li><li>数据库唯一键保证重复数据不会重复插入多条</li></ul><h2 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h2><p>消息的可靠性传输（处理消息丢失的问题）</p><ol><li>RabbitMQ丢失数据的解决方案</li></ol><table><thead><tr><th>途径</th><th>方案</th><th>备注</th></tr></thead><tbody><tr><td>生产者丢失</td><td>开启RabbitMQ事务（同步，不推荐）</td><td>吞吐量低，低性能</td></tr><tr><td></td><td>开启confirm模式（异步，推荐）</td><td>写消息会分配一个唯一的id，写入RabbitMQ，消息OK，回传ack消息，否则回调nack接口，告知接收失败</td></tr><tr><td>MQ丢失</td><td>开启持久化</td><td></td></tr><tr><td>消费者丢失</td><td>关闭RabbitMQ自动ack</td><td>消费完，调用接口，手动ack</td></tr></tbody></table><ol start="2"><li>Kafka丢失数据的解决方案</li></ol><ul><li><p><strong>消费端丢失数据</strong></p><p>  关闭自动提交offset，手动提交offset</p><p>  自动提交了offset，但可能会重复消费，需要保证幂等性</p></li><li><p><strong>Kafka丢失数据</strong></p><ul><li>topic设置<code>reclication.factor</code>参数，值必须大于1，要求每个partition必须有至少两个副本;</li><li>服务端设置<code>min.insync.replicas</code>参数，值必须大于1，要求一个leader至少感知到一个followr；</li><li>producer端设置<code>acks=all</code>，要求每条数据写入所有replica之后，才能认为是写成功；</li><li>producer端设置<code>retries=MAX</code>，要求一旦写入失败，就无限重试|自动提交了offset|</li></ul></li></ul><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul><li>高性能</li><li>高并发</li></ul><h2 id="引发问题"><a href="#引发问题" class="headerlink" title="引发问题"></a>引发问题</h2><ul><li>缓存与数据库双写不一致</li><li>缓存雪崩、缓存穿透、缓存击穿</li><li>缓存并发竞争</li></ul><h2 id="Redis和Memcached"><a href="#Redis和Memcached" class="headerlink" title="Redis和Memcached"></a>Redis和Memcached</h2><p>都是将数据存放在内存中</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="1-单线程工作模型"><a href="#1-单线程工作模型" class="headerlink" title="1.单线程工作模型"></a>1.单线程工作模型</h4><ul><li>支持复杂的数据结构</li><li>支持集群模式</li></ul><p>每一个核上存储小数据性能更高，100k以上，Memcached性能要高</p><h4 id="2-过期策略"><a href="#2-过期策略" class="headerlink" title="2. 过期策略"></a>2. 过期策略</h4><ul><li>定时删除策略（默认）</li></ul><p>定时器到期，自动删除键</p><p>保证键自动删除，但CPU开销较高，占用大量CPU资源</p><ul><li>惰性删除策略</li></ul><p>当对key操作时，才会检查该键是否过期，如果过期则删除</p><p>避免定时删除策略的开销，但长时间未被访问的过期的key会一直保留，浪费空间</p><ul><li>定期删除策略</li></ul><p>自动删除，避免过期键长时间占用内存，不像定时删除策略占用大量CPU资源；</p><p>但过期前被访问，就不会被定期删除，内存占用了增加；删除频率太低，浪费内存；频率太高，影响性能</p><ul><li>随机删除策略</li></ul><p>定期，从已设置过期时间的键中选择一定数量的键，并删除其中已过期的键</p><p>效率比较高，但不能保证在一定时间内删除所有过期键</p><h4 id="3-主从架构"><a href="#3-主从架构" class="headerlink" title="3. 主从架构"></a>3. 主从架构</h4><p>一主多从，主负责写，从负责读，从而支撑高并发</p><p>redis replication -&gt; 主从架构 -&gt; 读写分离 -&gt; 水平扩容支撑读高并发</p><p>异步复制数据到从节点</p><p>主从架构，建议必须开启master node的持久化</p><h4 id="4-雪崩、穿透、击穿"><a href="#4-雪崩、穿透、击穿" class="headerlink" title="4. 雪崩、穿透、击穿"></a>4. 雪崩、穿透、击穿</h4><ul><li><strong>雪崩</strong></li></ul><p>缓存宕机，请求落到数据库，数据库崩溃，挂了</p><p>事前：redis高可用，主从+哨兵，redis cluster，避免全盘崩溃</p><p>事中：本地ehcache缓存+hystrix限流&amp;降级，避免MySQL被打死</p><p>事后：redis持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据</p><ul><li><strong>穿透</strong></li></ul><p>无效值请求，缓存不存在，直接查询数据库</p><p>(1). 不存在的键空值写入缓存，并设置过期时间</p><p>(2). 布隆过滤器</p><p>它由一个很长的二进制比特数组和一系列哈希函数构成，用于高效地检索数据是否存在</p><p>当布隆过滤器告诉我们某个值存在时，其实这个值只是有可能存在；可是它说某个值不存在时，那这个值就真的不存在。</p><ul><li><strong>击穿</strong></li></ul><p>key热点，访问非常频繁，处于集中式高并发访问的情况，当key失效的瞬间，大量的请求击穿缓存，直接请求数据库</p><p>(1). 基本不会更新的数据，设置为永不过期</p><p>(2). 数据更新不频繁或缓存刷新耗时较少，分布式互斥锁，活本地互斥锁保证仅少量的请求能请求数据库并重新构建缓存</p><p>(3). 数据更新频繁或缓存刷新流程耗时长，定时线程，缓存过期前，主动地重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存</p><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>多核</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JAVA面试题</title>
    <link href="/2023/12/31/%E9%9D%A2%E8%AF%95/JAVA/"/>
    <url>/2023/12/31/%E9%9D%A2%E8%AF%95/JAVA/</url>
    
    <content type="html"><![CDATA[<p>JAVA面试题汇总</p><span id="more"></span><h3 id="库森学长"><a href="#库森学长" class="headerlink" title="库森学长"></a>库森学长</h3><h4 id="一、避免重复下单支付解决方案："><a href="#一、避免重复下单支付解决方案：" class="headerlink" title="一、避免重复下单支付解决方案："></a>一、避免重复下单支付解决方案：</h4><ol><li>通过订单id来校验其幂等性</li><li>支付接口在Nginx层面不要设置失败或超时重试</li></ol><h4 id="二、产品快照"><a href="#二、产品快照" class="headerlink" title="二、产品快照"></a>二、产品快照</h4><p>商品信息是可以修改的，当用户下单后，为了更好解决后面可能存在的买卖纠纷，创建订单时会同步保存一份商品详情信息，称之为订单产品快照。</p><p>同一件商品，会有很多用户会购买，如果热销商品，短时间就会有上万的订单。如果每个订单都创建一份快照，存储成本太高。另外商品信息虽然支持修改，但毕竟是一个低频动作。<br>我们可以理解成，大部分订单的产品快照信息都是一样的，除非下单时用户修改过。</p><p>我们的解决方案时，用新下单的订单id直接关联最新一份的产品快照id即可。</p><p>由于订单产品快照属于非核心操作，即使失败也不应该影响用户正常购买流程，所以通常采用异步流程执行。</p><h4 id="三、购物车混合存储"><a href="#三、购物车混合存储" class="headerlink" title="三、购物车混合存储"></a>三、购物车混合存储</h4><p>购物车是电商系统的标配功能，暂存用户想要购买的商品。分为添加商品、列表查看、结算下单三个动作。</p><p>技术设计并不是特别复杂，存储的信息也相对有限（用户id、商品id、sku_id、数量、添加时间）。这里特别拿出来单讲主要是用户体验层面要注意几个问题：</p><p>添加购物车时，后端校验用户未登录，常规思路，引导用户跳转登录页，待登录成功后，再添加购物车。多了一步操作，给用户一种强迫的感觉，体验会比较差。</p><p>如果细心体验京东、淘宝等大平台，你会发现即使未登录态也可以添加购物车，这到底是怎么实现的？</p><p>细细琢磨其实原理并不复杂，服务端这边在用户登录态校验时，做了分支路由，当用户未登录时，会创建一个临时Token，作为用户的唯一标识，购物车数据挂载在该Token下，为了避免购物车数据相互影响以及设计的复杂度，这里会有一个临时购物车表。</p><h4 id="四、库存超卖"><a href="#四、库存超卖" class="headerlink" title="四、库存超卖"></a>四、库存超卖</h4><p>常见的库存扣减方式有：</p><ul><li>下单减库存：即当买家下单后，在商品的总库存中减去买家购买数量。<br>下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。<br>但是你要知道，有些人下完单可能并不会付款。</li><li>付款减库存：即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。<br>但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。</li><li>预扣库存：这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 30 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。<br>在买家付款前，系统会校验该订单的库存是否还有保留：<ul><li>如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；</li><li>如果预扣成功，则完成付款并实际地减去库存。</li></ul></li></ul><p>至于采用哪一种减库存方式更多是业务层面的考虑，减库存最核心的是大并发请求时保证数据库中的库存字段值不能为负数。</p><p><strong>方案一：</strong></p><p>通常在扣减库存的场景下使用行级锁，通过数据库引擎本身对记录加锁的控制，保证数据库的更新的安全性，并且通过where语句的条件，保证库存不会被减到 0 以下，也就是能够有效的控制超卖的场景。</p><p><strong>方案二：</strong></p><p>设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时 SQL 语句会报错。</p><h4 id="五、账户余额更新，保证事务"><a href="#五、账户余额更新，保证事务" class="headerlink" title="五、账户余额更新，保证事务"></a>五、账户余额更新，保证事务</h4><p>用户支付，我们要从买家账户减掉一定金额，再往卖家增加一定金额，为了保证数据的完整性、可追溯性，变更余额时，我们通常会同时插入一条记录流水。</p><p><strong>账户流水核心字段：</strong>流水ID、金额、交易双方账户、交易时间戳、订单号、注意：账户流水只能新增，不能修改和删除。流水号必须是自增的。</p><p>后续，系统对账时，我们只需要对交易流水明细数据做累计即可，如果出现和余额不一致情况，一般以交易流水为准来修复余额数据。</p><p>更新余额、记录流水 虽属于两个操作，但是要保证要么都成功，要么都失败。要做到事务。</p><p>数据库的事务隔离级别有：读未提交（RU）、读已提交（RC）、可重复读（RR）、串行化（Serializable）</p><p>常用的隔离级别是 RC 和 RR ，因为这两种隔离级别都可以避免脏读。</p><p>当然，如果涉及多个微服务调用，一般情况下，我们借助重试机制，保证最终一致是常用的方案。</p><h4 id="六、读写分离导致数据不一致"><a href="#六、读写分离导致数据不一致" class="headerlink" title="六、读写分离导致数据不一致"></a>六、读写分离导致数据不一致</h4><p>互联网业务大部分都是读多写少，为了提升数据库集群的吞吐性能，我们通常会采用主从架构、读写分离</p><p>部署一个主库实例，客户端请求所有写操作全部写到主库，然后借助 MySQL 自带的 主从同步 功能，做一些简单配置，可以近乎实时的将主库的数据同步给 多个从库实例，主从延迟非常小，一般<strong>不超过 1 毫秒</strong>。</p><p>客户端请求的所有读操作全部打到 从库，借助多实例集群提升读请求的整体处理能力。</p><p>但是，主从同步虽然近乎实时，但还是有个时间差 ，主库数据刚更新完，但数据还没来得及同步到从库，后续读请求直接访问了从库，看到的还是旧数据，会造成一致性的问题。</p><p>因此，对实时性要求很高的by id查询，我们还是需要让它走主库，而不是一股脑地把所有读请求都往从库打。</p><h4 id="七、历史订单归档"><a href="#七、历史订单归档" class="headerlink" title="七、历史订单归档"></a>七、历史订单归档</h4><p>根据二八定律，系统绝大部分的性能开销花在20%的业务。数据也不例外，从数据的使用频率来看，经常被业务访问的数据称为热点数据；反之，称之为冷数据。</p><p>在了解的数据的冷、热特性后，便可以指导我们做一些有针对性的性能优化。这里面有业务层面的优化，也有技术层面的优化。比如：电商网站，一般只能查询3个月内的订单，如果你想看看3个月前的订单，需要访问历史订单页面。</p><p><strong>实现思路：</strong></p><p>1、冷热数据区分的标准是什么？要结合业务思考，可能要找产品同学一块讨论才能做决策，切记不要拍脑袋。以电商订单为例：</p><ul><li>方案一： 以“下单时间”为标准，将3 个月前的订单数据当作冷数据，3 个月内的当作热数据。</li><li>方案二：根据“订单状态”字段来区分，已完结的订单当作冷数据，未完结的订单当作热数据。</li><li>方案三：组合方式，把下单时间 &gt; 3 个月且状态为“已完结”的订单标识为冷数据，其他的当作热数据。</li></ul><p>2、如何触发冷热数据的分离</p><ul><li>方案一：直接修改业务代码，每次业务请求触发冷热数据判断，根据结果路由到对应的冷数据表或热数据表。<br>缺点：如果判断标准是 时间维度，数据过期了无法主动感知。</li><li>方案二：如果觉得修改业务代码，耦合性高，不易于后期维护。<br>可以通过监听数据库变更日志 binlog 方式来触发</li><li>方案三：常用的手段是跑定时任务，一般是选择凌晨系统压力小的时候，通过跑批任务，将满足条件的冷数据迁移到其他存储介质。在途业务表中只留下来少量的热点数据。</li></ul><p>3、如何实现冷热数据分离，过程大概分为三步：</p><ul><li>判断数据是冷、还是热</li><li>将冷数据插入冷数据表中</li><li>然后，从原来的热库中删除迁移的数据</li></ul><p>4、如何使用冷热数据</p><ul><li>方案一：界面设计时会有选项区分，如上面举例的电商订单</li><li>方案二：直接在业务代码里区分。</li></ul><h4 id="八、订单分库分表，多维度查询"><a href="#八、订单分库分表，多维度查询" class="headerlink" title="八、订单分库分表，多维度查询"></a>八、订单分库分表，多维度查询</h4><p>如果电商的订单数过多，我们一般会想到分库分表 解决策略。没问题，这个方向是对的。</p><p>但是查询维度很多</p><p>1、买家，查询 我的订单 列表，需要根据 buyer_id 来查询<br>2、查看订单详情，需要根据 order_id 来查询<br>3、卖家，查询 我的销售 列表，需要根据 seller_id 来查询<br>4、最可怕的是管理系统，它会根据不同维度去查询订单  </p><p>前三种场景通过买家库+卖家库的方案解决（买家库为“主”库），第四种则是通过DataBus将数据同步到ES来进行解决。</p><hr><blockquote><p>作者：库森学长<br>链接：<a href="https://www.zhihu.com/question/461650956/answer/2985600612">https://www.zhihu.com/question/461650956/answer/2985600612</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><hr>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>JAVA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统集成项目管理</title>
    <link href="/2023/12/31/%E8%BD%AF%E8%80%83/%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <url>/2023/12/31/%E8%BD%AF%E8%80%83/%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>系统集成项目管理阅读笔记</p><span id="more"></span><h2 id="系统集成项目管理"><a href="#系统集成项目管理" class="headerlink" title="系统集成项目管理"></a>系统集成项目管理</h2><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86">系统集成项目管理</a><ul><li><a href="#%E9%A3%8E%E9%99%A9">风险</a></li><li><a href="#%E9%A1%B9%E7%9B%AE%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86">项目风险管理</a></li><li><a href="#%E8%A7%84%E5%88%92%E9%A3%8E%E9%99%A9%E7%AE%A1%E7%90%86">规划风险管理</a></li><li><a href="#%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9">识别风险</a><ul><li><a href="#%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9%E7%9A%84%E8%BE%93%E5%85%A5">识别风险的输入</a></li><li><a href="#%E8%AF%86%E5%88%AB%E9%A3%8E%E9%99%A9%E7%9A%84%E5%B7%A5%E5%85%B7%E4%B8%8E%E6%8A%80%E6%9C%AF">识别风险的工具与技术</a></li></ul></li></ul></li></ul><h3 id="风险"><a href="#风险" class="headerlink" title="风险"></a>风险</h3><ol><li>定义</li></ol><ul><li>狭义： 损失的不确定性<br>负面的影响</li><li>广义： 不确定的事件或条件，一旦发生，产生积极或消极的影响<br>中性词，表示损失、获益之间的任意一种可能</li></ul><p>风险的发生概率 0% —— 100%</p><ol start="2"><li>分类</li></ol><table><thead><tr><th>划分类别</th><th>风险</th><th>定义</th><th>结果</th><th>示例</th><th>备注</th></tr></thead><tbody><tr><td>性质</td><td>纯粹风险</td><td>只有损失可能性而无获利可能性的风险</td><td>损失</td><td>火灾、汽车主人面临的碰撞</td><td></td></tr><tr><td></td><td>投机风险</td><td>既有损失的可能又有获利机会的风险</td><td>没有损失；有损失；收益</td><td>股票</td><td></td></tr><tr><td>产生原因</td><td>自然风险</td><td>自然力的不规则变化使社会生产和社会省会等遭受威胁的风险</td><td></td><td>地震、水灾、火灾、瘟疫</td><td>不可控性；周期性；共沾性</td></tr><tr><td></td><td>社会风险</td><td>个人或团队的行为或不作为使社会生产以及人们生活遭受损失的风险</td><td>盗窃、抢劫、玩忽职守</td><td></td><td></td></tr><tr><td></td><td>政治风险（国家风险）</td><td>对外投资和贸易过程中，因政治原因或订立双方所不能控制的原因，使债权人可能遭受损失的风险</td><td>进口国战争、内乱而中止货物进口</td><td></td><td></td></tr><tr><td></td><td>经济风险</td><td></td><td></td><td></td><td>企业生产规模的增减</td></tr><tr><td></td><td>技术风险</td><td></td><td></td><td></td><td>核辐射、空气污染、噪音</td></tr><tr><td>标的物</td><td>财产风险</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>人身风险</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>责任风险</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>信用风险</td><td></td><td></td><td></td><td></td></tr><tr><td>行为</td><td>特定风险</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>基本风险</td><td></td><td></td><td></td><td></td></tr><tr><td>环境</td><td>静态风险</td><td></td><td></td><td></td><td></td></tr><tr><td></td><td>动态风险</td><td></td><td></td><td></td><td></td></tr></tbody></table><ol start="3"><li>特性<ul><li>客观性</li><li>偶然性</li><li>相对性</li><li>社会性</li><li>不确定性</li></ul></li></ol><h3 id="项目风险管理"><a href="#项目风险管理" class="headerlink" title="项目风险管理"></a>项目风险管理</h3><p>风险管理所花费的成本不能超过所管理的风险事件的预期货币价值</p><ol><li>规划风险管理</li><li>识别风险</li><li>实施定性风险分析</li><li>实施定量风险分析</li><li>规划风险应对</li><li>控制风险</li></ol><table><thead><tr><th>类别</th><th>定义</th><th>措施</th></tr></thead><tbody><tr><td>已知风险</td><td>已经识别并分析过的风险</td><td>规划应对措施</td></tr><tr><td></td><td>已知但又无法主动管理的风险</td><td>分配一定的应急储备</td></tr><tr><td>未知风险</td><td>项目中没有被识别和分析过，但也有发生可能的风险</td><td>分配一定的管理储备</td></tr></tbody></table><p>项目实施中已发生的消极的项目风险被视为问题，是一种损失</p><p>组织和干系人的风险态度的影响因素：</p><ul><li>风险偏好</li><li>风险承受力</li><li>风险临界值</li></ul><h3 id="规划风险管理"><a href="#规划风险管理" class="headerlink" title="规划风险管理"></a>规划风险管理</h3><ol><li><p>输入</p><ol><li>项目管理计划</li></ol><p>提供会受风险影响的范围、进度和成本的基准或当前状态</p><ol start="2"><li>项目章程</li></ol><p>提供各种输入，如高层级风险、项目描述和需求</p><ol start="3"><li>干系人登记册</li></ol><p>包含了项目干系人的详细信息及角色概述</p><ol start="4"><li>事业环境因素</li></ol><p>包括（但不限于）组织的风险态度、临界值和承受力，它们描述了组织愿意并能够承受的风险程度</p><ol start="5"><li>组织过程资产</li></ol><p>包括（但不限于）：</p><ul><li>风险类别</li><li>概念和术语的通用定义</li><li>风险描述的格式</li><li>标准模板</li><li>角色和职责</li><li>决策所需的职权级别</li><li>经验教训</li></ul></li><li><p>工具与技术</p><ol><li>分析技术</li><li>专家判断</li><li>会议</li></ol></li><li><p>输出</p><ol><li>方法论</li><li>角色与职责</li><li>预算</li><li>时间安排</li><li>风险类别</li><li>风险概率和影响的定义</li><li>概率和影响矩阵</li><li>修订的干系人承受力</li><li>报告格式</li><li>跟踪</li></ol></li></ol><h3 id="识别风险"><a href="#识别风险" class="headerlink" title="识别风险"></a>识别风险</h3><p>判断哪些风险可能影响项目并记录其特征的过程。本过程的主要作用是，把识别出的风险记录在案，并为项目团队预测未来事件积累知识和技能。</p><p>原则：</p><ol><li>由粗及细，由细及粗</li><li>严格界定风险内涵并考虑风险因素之间的相关性</li><li>先怀疑，后排除</li><li>排除与确认并重。对于肯定不能排除但又不能肯定予以确认的风险按确认考虑</li><li>必要时，可作实验论证</li></ol><h4 id="识别风险的输入"><a href="#识别风险的输入" class="headerlink" title="识别风险的输入"></a>识别风险的输入</h4><ol><li>风险管理计划</li></ol><p>为识别风险过程提供一些关键要素，包括角色和职责分配、已列入预算和进度计划的风险管理活动，以及可能以风险分解结构的形式呈现的风险类别</p><ol start="2"><li>成本管理计划</li></ol><p>规定的工作流程和控制方法有助于在整个项目内识别风险</p><ol start="3"><li>进度管理计划</li></ol><p>有助于了解可能受风险（已知的和未知的）影响的项目时间目标及预期</p><ol start="4"><li>质量管理计划</li></ol><p>规定的质量测量和度量基准，可用于识别风险</p><ol start="5"><li>人力资源管理计划</li></ol><p>为如何定义、匹配、管理和最终遣散项目人力资源提供指南</p><ol start="6"><li>范围基准</li></ol><p>项目范围说明书中包括项目的假设条件，应该把项目假设条件中的不确定性作为项目风险的潜在原因加以评估。</p><p>WBS是识别风险过程的关键输入，因为它方便人们同时从微观和宏观两个层面认识潜在风险。可以在总体、控制账户和工作包层级上识别并跟踪风险。</p><ol start="7"><li>活动成本估算</li></ol><p>对活动成本估算进行审查，有利于识别风险。活动成本估算是对完成进度活动可能需要成本的量化评估，最好用一个区间来表示，区间的宽度代表着风险的程度。通过审查，可以预知估算的成本是否足以完成某项活动（是否给项目带来风险）</p><ol start="8"><li>活动持续时间估算</li></ol><p>对活动持续时间估算进行审查，有利于识别与活动或整个项目的应急储备时间有关的风险。类似的，估算区间的宽度代表着风险的相对程度。</p><ol start="9"><li><p>干系人登记册</p></li><li><p>项目文件</p><ol><li>项目章程</li><li>项目进度计划</li><li>进度网络图</li><li>问题日志</li><li>质量核对单</li><li>对识别风险有用的其他信息</li></ol></li><li><p>采购文件</p></li><li><p>事业环境因素</p><ol><li>公开发布的信息，包括商业数据库</li><li>学术研究资料</li><li>公开发布的核对单，标杆对照资料</li><li>行业研究资料</li><li>风险态度</li></ol></li><li><p>组织过程资产<br> 1.   项目文档，包括实际数据<br> 2.   组织和项目的过程控制资料<br> 3.   风险描述的格式或模板<br> 4.   经验教训</p></li></ol><h4 id="识别风险的工具与技术"><a href="#识别风险的工具与技术" class="headerlink" title="识别风险的工具与技术"></a>识别风险的工具与技术</h4><ol><li>文档审查</li><li>信息收集技术<ol><li>头脑风暴</li><li>德尔菲技术</li><li>访谈</li><li>根本原因分析</li></ol></li><li>核对单分析</li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>软考</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软考</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础知识</title>
    <link href="/2023/12/31/%E8%AF%AD%E8%A8%80/Python/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/12/31/%E8%AF%AD%E8%A8%80/Python/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>Python基础知识</p><span id="more"></span><h1 id="Python-库"><a href="#Python-库" class="headerlink" title="Python 库"></a>Python 库</h1><h2 id="pygame"><a href="#pygame" class="headerlink" title="pygame"></a>pygame</h2><p>Python库，开发基于图形的应用程序，提供工具和函数，创建声音、动画和图形。  </p><h3 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h3><ul><li>pygame.display</li><li>pygame.image</li><li>pygame.mixer</li><li>pygame.event</li><li>pygame.init</li></ul><h4 id="pygame-init"><a href="#pygame-init" class="headerlink" title="pygame.init()"></a>pygame.init()</h4><p>初始化pygame模块，在其他pygame模块之前调用，在初始化过程中，pygame会自动加载所需的SDL库，并进行相关设置。  </p><blockquote><p>__SDL__：跨平台的软件开发库，用于操作音频、键盘、鼠标、操纵杆、图像等输入和输出设备，为多个平台提供统一的接口，开源。</p></blockquote><blockquote><p>__Surface__：对一个矩形区域的一个二维的像素数组的包装；提供了各种操作像素图像的方法，比如绘制图形、裁剪、旋转、缩放等。</p></blockquote><blockquote><p>__Color__：由RGB组成，每个值的范围为0-255，例如(255,255,255)表示白色</p></blockquote><h4 id="pygame-display"><a href="#pygame-display" class="headerlink" title="pygame.display"></a>pygame.display</h4><table><thead><tr><th align="left">方法</th><th align="left">描述</th><th align="left">备注</th></tr></thead><tbody><tr><td align="left">pygame.display.flip()</td><td align="left">将更新整个显示内容</td><td align="left"></td></tr><tr><td align="left">pygame.display.update()</td><td align="left">允许更新屏幕的一部分，而不是屏幕的整个区域。不传递任何参数，更新整个显示</td><td align="left">当使用OpenGL的时候，不能使用pygame.display</td></tr><tr><td align="left">pygame.display.quit()</td><td align="left">取消初始化显示模块</td><td align="left"></td></tr><tr><td align="left">pygame.display.get_init()</td><td align="left">如果显示模块已初始化，返回True</td><td align="left"></td></tr><tr><td align="left">pygame.display.set_mode()</td><td align="left">初始化显示窗口或屏幕</td><td align="left"></td></tr><tr><td align="left">pygame.display.get_surface</td><td align="left">返回对当前设置的显示Surface的引用，若为设置，则返回无</td><td align="left"></td></tr><tr><td align="left">pygame.display.get_driver()</td><td align="left">获取pygame显示后端的名称</td><td align="left"></td></tr><tr><td align="left">pygame.display.Info()</td><td align="left">创建一个视频显示信息对象</td><td align="left"></td></tr><tr><td align="left">pygame.display.get_wm_info()</td><td align="left">获取有关当前窗口系统的信息</td><td align="left"></td></tr><tr><td align="left">pygame.display.list_modes()</td><td align="left">获取可用全屏模式的列表</td><td align="left"></td></tr><tr><td align="left">pygame.display.mode_ok()</td><td align="left">为显示模式选择最佳颜色深度</td><td align="left"></td></tr><tr><td align="left">pygame.display.gl_get_attribute()</td><td align="left">获取当前显示的OpenGL flag的值</td><td align="left"></td></tr><tr><td align="left">pygame.display.gl_set_attribute()</td><td align="left">请求显示模式的OpenGL显示属性</td><td align="left"></td></tr><tr><td align="left">pygame.display.iconify()</td><td align="left">使显示面图标化</td><td align="left"></td></tr><tr><td align="left">pygame.display.toggle_fullscreen()</td><td align="left">在全屏和窗口显示之间切换</td><td align="left"></td></tr><tr><td align="left">pygame.display.set_gamma()</td><td align="left">更改硬件gamma渐变</td><td align="left"></td></tr><tr><td align="left">pygame.display.set_gamma_ramp()</td><td align="left">使用自定义查找更改硬件gamma渐变</td><td align="left"></td></tr><tr><td align="left">pygame.display.set_icon()</td><td align="left">更改显示窗口的系统图像</td><td align="left"></td></tr><tr><td align="left">pygame.display.set_caption()</td><td align="left">设置当前窗口标题</td><td align="left"></td></tr><tr><td align="left">pygame.display.get_caption()</td><td align="left">获取当前窗口标题</td><td align="left"></td></tr><tr><td align="left">pygame.display.set_palette()</td><td align="left">设置索引显示的显示调色板</td><td align="left"></td></tr><tr><td align="left">pygame.display.get_num_displays()</td><td align="left">返回显示数</td><td align="left"></td></tr><tr><td align="left">pygame.display.get_window_size()</td><td align="left">返回窗口或屏幕的大小</td><td align="left"></td></tr></tbody></table><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="Surface"><a href="#Surface" class="headerlink" title="Surface"></a>Surface</h4><p>表示图像的对象，图片是由像素组成的，Surface对象具有固定的分辨率和像素格式  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pygame <span class="hljs-comment"># 导入模块</span><br>pygame.init()  <span class="hljs-comment"># 初始化模块</span><br>screen = pygame.display.set_mode((<span class="hljs-number">800</span>,<span class="hljs-number">600</span>),<span class="hljs-number">0</span>,<span class="hljs-number">32</span>)  <span class="hljs-comment"># 创建一个Surface对象窗口</span><br></code></pre></td></tr></table></figure><p>screen是绘制其他图形的主要窗口  </p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/618198911?utm_id=0">pygame入门教程</a></li><li><a href="https://blog.csdn.net/dudu3332/article/details/110309130">pygame.display.flip()和pygame.display.update()的区别</a></li><li><a href="https://blog.csdn.net/Rita_Aloha/article/details/106208691">pygame中display模块方法详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>语言</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VsCode设置</title>
    <link href="/2023/12/31/%E8%AE%BE%E7%BD%AE/vscode/"/>
    <url>/2023/12/31/%E8%AE%BE%E7%BD%AE/vscode/</url>
    
    <content type="html"><![CDATA[<p>VsCode 设置</p><span id="more"></span><h3 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h3><h4 id="以管理员身份运行-PowerShell"><a href="#以管理员身份运行-PowerShell" class="headerlink" title="以管理员身份运行 PowerShell"></a>以管理员身份运行 PowerShell</h4><p><a href="http://chart.zhenglinglu.cn/pages/6b5b03/#%E7%AC%AC%E4%B8%80%E6%AD%A5">原文地址</a></p><ol><li>VsCode 桌面快捷图标，右击 -&gt; 属性 -&gt; 兼容性，勾选“以管理员身份运行次程序”；</li><li>打开 vs，在终端输入 <code>get-ExecutionPolicy</code>, 若终端返回 <strong>Restricted</strong>，表示状态是禁止的;</li><li>终端输入 <code>set-ExecutionPolicy RemoteSigned</code>;</li><li>终端输入 <code>get-ExecutionPolicy</code>，若返回 <strong>RemoteSigned</strong>，管理员身份运行设置成功；</li><li>重启 VsCode</li></ol>]]></content>
    
    
    <categories>
      
      <category>设置</category>
      
      <category>VsCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VsCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ</title>
    <link href="/2023/12/31/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/rabbitmq/"/>
    <url>/2023/12/31/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/rabbitmq/</url>
    
    <content type="html"><![CDATA[<h2 id="一、RabbitMQ-安装"><a href="#一、RabbitMQ-安装" class="headerlink" title="一、RabbitMQ 安装"></a>一、RabbitMQ 安装</h2><p>rabbitMQ 是一个在 AMQP 协议标准基础上完整的，可服用的企业消息系统。它遵循 Mozilla Public License 开源协议，采用 Erlang 实现的工业级的消息队列 (MQ) 服务器，Rabbit MQ 是建立在 Erlang OTP 平台上。所以需要先安装 Erlang。  </p><ol><li><p>安装 Erlang<br>官网下载地址： <a href="http://www.erlang.org/downloads">http://www.erlang.org/downloads</a>  </p></li><li><p>rabbitmq-server-3.7.0.exe<br>下载地址 ：<a href="http://www.rabbitmq.com/install-windows.html">http://www.rabbitmq.com/install-windows.html</a>  </p></li><li><p>开启插件<br><strong>rabbitmq_managemen</strong> 是管理后台的插件<br>激活 RabbitMQ’s Management Plugin<br>使用 RabbitMQ 管理插件，可以更好的可视化方式查看Rabbit MQ 服务器实例的状态。<br>进入到安装目录的 sbin 目录下，cmd 输入 <strong>rabbitmq-plugins enable rabbitmq_management</strong><br>服务会自动开启</p></li><li><p>可以以管理员身份运行 cmd，开启或关闭 rabbitmq<br>net start rabbitmq<br>net stop rabbitmq  </p></li><li><p>进入管理后台<br>访问地址： <a href="http://localhost:15672/">http://localhost:15672</a><br>默认 userName 是 <strong>guest</strong><br>默认 password 是 <strong>guest</strong>  </p></li><li><p>创建用户、密码、绑定角色<br>使用rabbitmqctl控制台命令（位于安装目录 \sbin&gt;）来创建用户，密码，绑定权限等  </p><ul><li><p>查看已有用户以及用户的角色<br> <strong>rabbitmqctl list_users</strong>  </p></li><li><p>创建用户<br> <strong>rabbitmqctl add_user dy 123456</strong>  </p></li><li><p>创建角色<br> 角色分为五类：  </p><ul><li>超级管理员(administrator)<br>  可查看所有的信息，并且可以对用户、策略进行操作  </li><li>监控者(monitoring)<br>  同时可以查看 rabbitmq 节点的相关信息（进程数、内存使用情况、磁盘使用情况等）  </li><li>策略制定者(policymaker)<br>  同时对 policy 进行管理  </li><li>普通管理者(management)<br>  仅可登陆管理控制台，无法看到节点信息，也无法对策略进行管理  </li><li>其他的<br>  无法登陆管理控制台，通常就是普通的生产者和消费者</li></ul></li></ul><p> <strong>rabbitmqctl  set_user_tags  username tag1 [tag2 …]</strong>  </p><ul><li><p>修改密码<br> <strong>rabbitmqctl change_password userName newPassword</strong>  </p></li><li><p>删除用户<br> <strong>rabbitmqctl delete_user username</strong>  </p></li><li><p>权限设置  </p><ul><li>设置用户权限<br>  rabbitmqctl  set_permissions  -p  VHostPath  User  ConfP  WriteP  ReadP</li><li>查看(指定hostpath)所有用户的权限信息<br>  rabbitmqctl  list_permissions  [-p  VHostPath]</li><li>查看指定用户的权限信息<br>  rabbitmqctl  list_user_permissions  User</li><li>清除用户的权限信息<br>  rabbitmqctl  clear_permissions  [-p VHostPath]  User</li></ul></li></ul></li></ol><hr><h3 id="Spring-Boot-整合-RabbitMQ"><a href="#Spring-Boot-整合-RabbitMQ" class="headerlink" title="Spring Boot 整合 RabbitMQ"></a>Spring Boot 整合 RabbitMQ</h3><p><strong>spring-boot-starter-amqp</strong>  </p><p>高级消息队列协议（AMQP）是面向消息中间件的平台中立的有线协议。Spring AMQP 项目将核心 Spring 概念应用于基于 AMQP 的消息传递解决方案的开发。Spring Boot 为通过 RabbitMQ 与 AMQP 一起工作提供了一些便利，包括 spring-boot-starter-amqp “Starter”。  </p><p>springboot集成RabbitMQ非常简单，如果只是简单的使用配置非常少，springboot提供了spring-boot-starter-amqp项目对消息各种支持。  </p><ul><li>添加依赖  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>属性配置  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.rabbitmq.host</span>=localhost<br><span class="hljs-attr">spring.rabbitmq.port</span>=<span class="hljs-number">5672</span><br><span class="hljs-attr">spring.rabbitmq.username</span>=guest<br><span class="hljs-attr">spring.rabbitmq.password</span>=guest<br></code></pre></td></tr></table></figure></li><li>一对一发送配置  <ul><li>队列配置  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">queue</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>发送者  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloSender</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> <span class="hljs-title class_">AmqpTemplate</span> amqpTemplate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">send</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-title class_">String</span> context = <span class="hljs-string">&quot;hello----&quot;</span>+<span class="hljs-title class_">LocalDateTime</span>.<span class="hljs-title function_">now</span>();<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;send:&quot;</span>+context);<br>        <span class="hljs-comment">//往名称为 hello 的queue中发送消息</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">amqpTemplate</span>.<span class="hljs-title function_">convertAndSend</span>(<span class="hljs-string">&quot;hello&quot;</span>,context);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>接受者  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@RabbitListener</span>(queues = <span class="hljs-string">&quot;hello&quot;</span>) <span class="hljs-comment">//监听 名称为 hello 的queue</span><br>public class HelloReceiver &#123;<br><br>    <span class="hljs-comment">//消息处理器</span><br>    <span class="hljs-variable">@RabbitHandler</span><br>    public void <span class="hljs-built_in">process</span>(String message)&#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Receiver:&quot;</span>+message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li>一对多发送：一个发送者多个接受者  <ul><li>队列配置    <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">multiReceiverQueue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;hello_multi&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>发送者  <figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">sendMulti</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>        <span class="hljs-type">String</span> context = i + <span class="hljs-string">&quot;&quot;</span>;<br>        System.out.<span class="hljs-built_in">println</span>(context + <span class="hljs-string">&quot; --- send: &quot;</span>);<br>        <span class="hljs-keyword">this</span>.amqpTemplate.<span class="hljs-built_in">convertAndSend</span>(<span class="hljs-string">&quot;hello_multi&quot;</span>, context);<br>    &#125;<br></code></pre></td></tr></table></figure></li><li>接收者  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//多个</span><br><span class="hljs-variable">@Component</span><br><span class="hljs-variable">@RabbitListener</span>(queues = <span class="hljs-string">&quot;hello_multi&quot;</span>)<br>public class HelloReceiver2 &#123;<br><br>    <span class="hljs-variable">@RabbitHandler</span><br>    public void <span class="hljs-built_in">process</span>(String message) &#123;<br>        <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;Receiver2: &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><blockquote><p>一个发送者，N个接受者,经过测试会均匀的将消息发送到N个接收者中</p></blockquote><ul><li>多对多发送<br>test时：  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">many2many</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">100</span>;i++)&#123;<br>    helloSender.send2(i);<br>    helloSender2.send2(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>和一对多一样，接收端仍然会均匀接收到消息</p></blockquote></li></ul><h3 id="Exchange-Type"><a href="#Exchange-Type" class="headerlink" title="Exchange Type"></a>Exchange Type</h3><p>abbitMQ 常用的Exchange Type 有 fanout、direct、topic、headers 这四种（AMQP规范里还提到两种 Exchange Type，分别为 system 与自定义，这里不予以描述），下面分别进行介绍</p><h4 id="Fanout"><a href="#Fanout" class="headerlink" title="Fanout"></a>Fanout</h4><p>又叫广播形式，不管路由键或者是路由模式，会把消息发给绑定给它的全部队列，如果配置了routing_key会被忽略。<br>当使用fanout交换器时，他会将消息广播到与该交换器绑定的所有队列上。  </p><ul><li>Queue 配置  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title class_">AMessage</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.A&quot;</span>);<br>&#125;<br><span class="hljs-comment">//创建队列</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title class_">BMessage</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;fanout.B&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//创建Fanout交换器</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-title class_">FanoutExchange</span> <span class="hljs-title function_">fanoutExchange</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FanoutExchange</span>(<span class="hljs-string">&quot;fanoutExchange&quot;</span>);<br>&#125;<br><span class="hljs-comment">//将对列绑定到Fanout交换器</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingExchangeA</span>(<span class="hljs-params">Queue AMessage,FanoutExchange fanoutExchange</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">AMessage</span>).<span class="hljs-title function_">to</span>(fanoutExchange);<br>&#125;<br><span class="hljs-comment">//将对列绑定到Fanout交换器</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingExchangeB</span>(<span class="hljs-params">Queue BMessage, FanoutExchange fanoutExchange</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">BMessage</span>).<span class="hljs-title function_">to</span>(fanoutExchange);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>消息生产者  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span>()</span> &#123;<br>    String context = <span class="hljs-string">&quot;hi, fanout msg &quot;</span>;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Sender : &quot;</span> + context);<br>    <span class="hljs-keyword">this</span>.rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;fanoutExchange&quot;</span>,<span class="hljs-string">&quot;&quot;</span>, context);<br>&#125;<br></code></pre></td></tr></table></figure></li><li>消息接受者<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;fanout.A&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutReceiverA</span> &#123;<br>   <span class="hljs-meta">@RabbitHandler</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) &#123;<br>     <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;fanout Receiver A : &quot;</span> + message);<br>  &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RabbitListener</span>(queues = <span class="hljs-string">&quot;fanout.B&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanoutReceiverB</span> &#123;<br>   <span class="hljs-meta">@RabbitHandler</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">process</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> message</span>) &#123;<br>     <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(<span class="hljs-string">&quot;fanout Receiver B : &quot;</span> + message);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="Topic"><a href="#Topic" class="headerlink" title="Topic"></a>Topic</h4><p>转发消息主要是根据通配符。<br>消息发送到topic类型的exchange上时不能随意指定routing_key（一定是指由一系列由点号连接单词的字符串，单词可以是任意的，但一般都会与消息或多或少的有些关联）。Routing key的长度不能超过255个字节。</p><p>Binding key 也一定要是同样的方式。Topic 类型的 exchange 就像一个直接的交换：一个由生产者指定了确定 routing key 的消息将会被推送给所有 Binding  key能与之匹配的消费者。<br>然而这种绑定有两种特殊的情况：<br>    1. #（井号）：可以匹配多个单词（或者零个）<br>    2. *（星号）：可以（只能）匹配一个单词  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Bean<br>public Binding bind<span class="hljs-constructor">Messages(TopicExchange <span class="hljs-params">topicExchange</span>)</span> &#123;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BindingBuilder</span>.</span></span>bind(queue<span class="hljs-constructor">Messages()</span>).<span class="hljs-keyword">to</span>(topicExchange).<span class="hljs-keyword">with</span>(<span class="hljs-string">&quot;topic.#&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>将 bean queueMessages 队列绑定到 topicExchange 交换机上。所有的 routing key 匹配 topic.# 的消息在 queueMessages 队列。  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendForTopicMessages</span>()</span> &#123;<br>    String context = <span class="hljs-string">&quot;I am messages. My routingKey is topic.messages&quot;</span>;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;sendForTopicMessages send&quot;</span>);<br>    <span class="hljs-keyword">this</span>.amqpTemplate.convertAndSend(<span class="hljs-string">&quot;exchange&quot;</span>, <span class="hljs-string">&quot;topic.messages&quot;</span>, context);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>amqpTemplate.convertAndSend(“exchange”, “topic.messages”, context)</strong><br>方法的第一个参数是交换机名称，第二个参数是发送的 routing key，由消息提供者定义<br>，第三个参数是内容，RabbitMQ 将会根据第二个参数去寻找有没有匹配此规则的队列，如果有, 则把消息给它，如果有不止一个，则把消息分发给匹配的队列(每个队列都有消息!)  </p><p>如果在发送消息时所指定的exchange和routing key在消费者端没有对应的exchange和binding key与之绑定的话，那么这条消息将会被丢弃掉  </p><p>Topic类型的exchange是很强大的，也可以实现其它类型的exchange。<br>当一个队列被绑定为binding key为”#”时，它将会接收所有的消息，此时和fanout类型的exchange很像。<br>当binding key不包含”*”和”#”时，这时候就很像direct类型的exchange。  </p><h4 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h4><p>是RabbitMQ默认的交换机模式，也是最简单的模式，根据key全文匹配去寻找队列<br>direct 类型的行为是”先匹配, 再投送”. 即在绑定时设定一个 routing_key, 消息的routing_key 匹配时, 才会被交换器投送到绑定的队列中去<br>相当于一对一模式，一个消息被发送者发送后，会被转发到一个绑定的消息队列中，然后被一个接受者接收。  </p><h4 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h4><p>headers 也是根据规则匹配, 相较于 direct 和 topic 固定地使用 routing_key , headers 则是一个自定义匹配规则的类型. 在队列与交换器绑定时, 会设定一组键值对规则, 消息中也包括一组键值对( headers 属性), 当这些键值对有一对, 或全部匹配时, 消息被投送到对应队列.</p><hr><p>参考文档：<br>rabbitmq官网教程：<a href="http://www.rabbitmq.com/getstarted.html">http://www.rabbitmq.com/getstarted.html</a><br>springboot官网教程：<a href="https://docs.spring.io/spring-amqp/docs/2.0.4.RELEASE/reference/html/">https://docs.spring.io/spring-amqp/docs/2.0.4.RELEASE/reference/html/</a>  </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>消息推送</category>
      
      <category>RabbitMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPush</tag>
      
      <tag>消息推送</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2023/12/31/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/Kafka/"/>
    <url>/2023/12/31/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/Kafka/</url>
    
    <content type="html"><![CDATA[<h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>一个队列，拥有先进先出的特性。<br>主要用于不同进程或线程之间的通信，用来处理一系列的输入请求  </p><p>异步通信机制  </p><p>应用：  </p><ul><li>应用解耦  </li><li>异步处理<br>  与串行不同之处是，并行处理提高了处理效率，减少了处理时间  </li><li>数据限流<br>  FIFO(先进先出)是一种较为传统的执行方法，按照请求顺序依次进行处理  </li><li>消息通信</li></ul><p>#####历程：<br>起源于 LinkedIn 公司  </p><h2 id="基本概念：1-代理（Broker）一个-Kafka-进程被称为一个代理节点2-生产者（Producer）将消息记录发送到-Kafka-集群指定的主题（Topic）中进行存储，同时生产者也能通过自定义算法绝对将消息记录发送到哪个分区3-消费者（Consumer）从-Kafka-集群指定的主题（Topic）中读取消息记录读取主题数据时，需要设置消费组名。如果不设置，则-Kafka-消费者会默认生成一个消费组名称4-消费者组（Consumer-Group）一个消费者组可以包含一个或多个消费者程序，使用多分区和多线程模式可以极大提高读取数据的效率-gt-一般，一个消费组对应一个线程给应用程序设置线程数量时，遵循“线程数小于等于分区数”原则，如果线程数大于分区数，则多余的线程不会消费分区中的数据，这样会造成资源浪费"><a href="#基本概念：1-代理（Broker）一个-Kafka-进程被称为一个代理节点2-生产者（Producer）将消息记录发送到-Kafka-集群指定的主题（Topic）中进行存储，同时生产者也能通过自定义算法绝对将消息记录发送到哪个分区3-消费者（Consumer）从-Kafka-集群指定的主题（Topic）中读取消息记录读取主题数据时，需要设置消费组名。如果不设置，则-Kafka-消费者会默认生成一个消费组名称4-消费者组（Consumer-Group）一个消费者组可以包含一个或多个消费者程序，使用多分区和多线程模式可以极大提高读取数据的效率-gt-一般，一个消费组对应一个线程给应用程序设置线程数量时，遵循“线程数小于等于分区数”原则，如果线程数大于分区数，则多余的线程不会消费分区中的数据，这样会造成资源浪费" class="headerlink" title="#####基本概念：1. 代理（Broker）一个 Kafka 进程被称为一个代理节点2. 生产者（Producer）将消息记录发送到 Kafka 集群指定的主题（Topic）中进行存储，同时生产者也能通过自定义算法绝对将消息记录发送到哪个分区3. 消费者（Consumer）从 Kafka 集群指定的主题（Topic）中读取消息记录读取主题数据时，需要设置消费组名。如果不设置，则 Kafka 消费者会默认生成一个消费组名称4. 消费者组（Consumer Group）一个消费者组可以包含一个或多个消费者程序，使用多分区和多线程模式可以极大提高读取数据的效率&gt;一般，一个消费组对应一个线程给应用程序设置线程数量时，遵循“线程数小于等于分区数”原则，如果线程数大于分区数，则多余的线程不会消费分区中的数据，这样会造成资源浪费  "></a>#####基本概念：<br>1. 代理（Broker）<br>一个 Kafka 进程被称为一个代理节点<br>2. 生产者（Producer）<br>将消息记录发送到 Kafka 集群指定的主题（Topic）中进行存储，同时生产者也能通过自定义算法绝对将消息记录发送到哪个分区<br>3. 消费者（Consumer）<br>从 Kafka 集群指定的主题（Topic）中读取消息记录<br>读取主题数据时，需要设置消费组名。如果不设置，则 Kafka 消费者会默认生成一个消费组名称<br>4. 消费者组（Consumer Group）<br>一个消费者组可以包含一个或多个消费者程序，使用多分区和多线程模式可以极大提高读取数据的效率<br>&gt;一般，一个消费组对应一个线程<br>给应用程序设置线程数量时，遵循“线程数小于等于分区数”原则，如果线程数大于分区数，则多余的线程不会消费分区中的数据，这样会造成资源浪费  </h2><ol><li>主题（Topic）<br>Kafka 系统通过主题来区分不同业务类型的消息记录  </li><li>分区（Partition）<br>每个主题中可以有一个或者多个分区<br>分区是基于物理层面上的，不同的分区对应着不同的数据文件<br>每个分区内部的消息记录是有序的，每个消息都有一个连续的偏移量序号（Offset）<br>一个分区只对应一个代理节点（Broker），一个代理节点可以管理多个分区  </li><li>副本（Replication）<br>每个主题在创建时指定它的副本数，默认是 1<br>通过副本机制来保证 Kafka 分布式集群数据的高可用性  <blockquote><p>主题的副本系数值应如下设置：<br>（1） 若集群数量大于等于3，则主题的副本系数可以设置为3<br>（2） 若集群数量小于3，则主题的副本系数值可以设置为小于等于集群数量值  </p></blockquote></li><li>记录（Record)<br>被实际写入到 Kafka 集群并且可以被消费者应用程序读取的数据，被称为记录<br>每条记录包含一个键（Key）、值（Value）和时间戳（Timestamp）</li></ol><hr>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MPush</title>
    <link href="/2023/12/31/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/mpush/"/>
    <url>/2023/12/31/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/mpush/</url>
    
    <content type="html"><![CDATA[<h3 id="1-服务部署"><a href="#1-服务部署" class="headerlink" title="1. 服务部署"></a>1. 服务部署</h3><h4 id="1-1-部署流程"><a href="#1-1-部署流程" class="headerlink" title="1.1 部署流程"></a>1.1 部署流程</h4><ul><li><p>安装 jdk 1.8 以上版本  </p></li><li><p>安装 zookeeper  </p><ul><li>下载解压zookeeper<br>  <code>tar -zxvf zookeeper-3.4.12.tar.gz</code></li><li>root 修改 &#x2F;etc&#x2F;profile，增加<br>  <code>export ZOOKEEPER_HOME=/opt/zookeeper-3.4.6</code><br>  <code>export PATH=$PATH:$ZOOKEEPER_HOME/bin:$ZOOKEEPER_HOME/conf</code></li><li>source &#x2F;etc&#x2F;profile 使配置奏效  </li><li>在 zookeeper 目录下创建数据文件目录及日志文件目录  </li><li><code>cd conf</code> <code>cp zoo_sample.cfg zoo.cfg</code>  </li><li><code>vim zoo.cfg</code> 修改如下配置：<br>  <code>dataDir=/home/hadoop/usr/local/zookeeper/data #目录上文创建，同下</code><br>  <code>dataLogDir=/home/hadoop/usr/local/zookeeper/logs</code><br>  <code>server.1=192.168.126:2888:3888 第一个端口用于集合体中 follower 以侦听 leader； 第二个端口用于 Leader 选举; 第一个 hostname 即为本服务器地址</code></li><li>启动<br>  <code>cd bin</code><br>  <code>zkServer.sh start</code>： 启动<br>  <code>zkServer.sh status</code>: 检查状态<br>  <code>zkServer.sh stop</code>： 停止</li></ul></li><li><p>安装 mpush</p></li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>消息推送</category>
      
      <category>MPush</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MPush</tag>
      
      <tag>消息推送</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMeter 笔记</title>
    <link href="/2023/12/31/%E6%B5%8B%E8%AF%95/Jmeter%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/31/%E6%B5%8B%E8%AF%95/Jmeter%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><p><strong>下载地址</strong><br><a href="http://jmeter.apache.org/download_jmeter.cgi">官网</a>  </p></li><li><p><strong>环境变量配置</strong><br>新建系统变量： 变量名： <code>JMETER_HOME</code>    变量值： <code>D:\installation\apache-jmeter-5.1.1</code><br>更改Path: <code>;%JMETER_HOME%\lib\ext\ApacheJMeter_core.jar;%JMETER_HOME%\lib\jorphan.jar;</code>  </p></li><li><p><strong>更换语言</strong><br>打开 <code>D:\installation\apache-jmeter-5.1.1\bin\jmeter.properties</code>，添加 <code>language=zh_CN</code></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JMeter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8</title>
    <link href="/2023/12/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/Java/Java8%20%E5%AE%9E%E6%88%98/"/>
    <url>/2023/12/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/Java/Java8%20%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<h3 id="不清楚的点"><a href="#不清楚的点" class="headerlink" title="不清楚的点"></a>不清楚的点</h3><h4 id="1-Java8-中接口"><a href="#1-Java8-中接口" class="headerlink" title="1. Java8 中接口"></a>1. Java8 中接口</h4><ol><li>增加了 default 方法和 static 法，这两种方法完全可以有方法体  </li><li>default 方法属于实例， static 方法属于类（接口），接口中静态方法并不能继承  </li><li>接口中的静态方法不会被继承，接口中的静态变量会被继承  </li><li>如果一个实现类继承了两个接口（这两个接口没有继承关系，有同名的默认方法），那么必须在实现类，显示声明，否则编译器不知道调用哪个而报错；而且可以通过 XXInterface.super.重名method(); 指定需要实现的是哪个接口</li></ol><p>@FunctionInterface<br>限定接口只能有一个抽象方法，<br>该注解只能标记在”有且仅有一个抽象方法”的接口上<br>该注解不是必须的，如果一个接口符合”函数式接口”定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了 @FunctionInterface，那么编译器会报错  </p><p>1、接口有且只能有个一个抽象方法，只有方法定义，没有方法<br>体<br>2、在接口中覆写 Object 类中的 public 方法，不算是函数式接口的方法。如 Comparator 仍是一个函数式接口  </p><p>JDK8接口中的静态方法和默认方法，都不算是抽象方法<br>接口默认继承java.lang.Object，所以如果接口显示声明覆盖了Object中方法，那么也不算抽象方法。  </p><p>Object 不是函数式接口  </p><h4 id="2-接口-和-Object-类"><a href="#2-接口-和-Object-类" class="headerlink" title="2. 接口 和 Object 类"></a>2. 接口 和 Object 类</h4><p>一、 如果接口继承 Object 类，则可以直接在接口后面加 extends Object。 很明显会报错，编译通不过。<br>二、 隐含继承<br>List 接口中如果没有 toString() 方法，那么由多态或继承的原理，System.out.println(array.toString()) 会报错，但事实确实不会报错。<br><a href="https://www.aliyun.com/jiaocheng/1437510.html">原文链接</a><br>三、 会默认被 Object 实现（我自已的意见）<br>如果新建一个 interface，无论是不是函数式接口，编写一个 toString() 或其他 Object 的方法，Ctrl open implementation(打开实现类) 会跳转至 Object 类中。  </p><h4 id="3-File-file-x3D-new-File-“路径名”-路径名的2种写法"><a href="#3-File-file-x3D-new-File-“路径名”-路径名的2种写法" class="headerlink" title="3. File file &#x3D; new File(“路径名”) 路径名的2种写法"></a>3. File file &#x3D; new File(“路径名”) 路径名的2种写法</h4><p>只有在 src 或者 java 文件夹下的 java 文件或资源文件才会编译，然后通过打包，会复制到 commlib 中  </p><p>1.绝对路径  </p><p>a. 带盘符,如E:&#x2F;book.xml<br>b. 以http开头,<a href="http://img.baidu.com/img/book.jpg">http://img.baidu.com/img/book.jpg</a>  </p><ol start="2"><li>相对路径</li></ol><p>a. 带 “&#x2F;“ 开头,如 &#x2F;book.xml<br>b. 不带 “&#x2F;“ 开头,如 book.xml  </p><p>现在项目结构如下,项目 System.getProperty(“user.dir”)&#x3D;E:\ProjectTest\javaEE\  </p><p>new File(“E:&#x2F;ProjectTest&#x2F;javaEE&#x2F;src&#x2F;com&#x2F;ly&#x2F;javaee&#x2F;xml&#x2F;dom4j&#x2F;book.xml”)—OK  </p><p>相对路径<br>new File(“book.xml”)—-报错(此时相当于 System.getProperty(“user.dir”) + “book.xml”,这是文件 book.xml 不存在 user.dir 下面)  </p><p>new File(“src&#x2F;com&#x2F;ly&#x2F;javaee&#x2F;xml&#x2F;dom4j&#x2F;book.xml”)—-OK(不带 “&#x2F;“ 可见在项目中相对的是以项目名为根路径,此时相当于 System.getProperty(“user.dir”) + “src&#x2F;com&#x2F;ly&#x2F;javaee&#x2F;xml&#x2F;dom4j&#x2F;book.xml”)  </p><p>new File(“&#x2F;book.xml”)—-以下可以看出本JVM运行在E盘下,此时带 “&#x2F;“ 就相当于 “E:&#x2F;book.xml” ,JVM 运行在哪个盘符就以哪个为根路径</p><p>new File(“.&#x2F;book.xml”);—报错(同 new File(“book.xml”) 效果)  </p><p><a href="http://www.cnblogs.com/cs-lcy/p/7499959.html">原文链接</a>  </p><h4 id="4-堆（heap）和栈（stack）"><a href="#4-堆（heap）和栈（stack）" class="headerlink" title="4. 堆（heap）和栈（stack）"></a>4. 堆（heap）和栈（stack）</h4><ol><li><p>与 C++ 不同，Java 自动管理栈和堆，程序员不能直接设置栈和堆。  </p></li><li><p>栈的存取速度比堆快；数据大小与生存期必须是确定的，缺乏灵活性；栈数据可以共享<br>堆动态地分配内存大小，生存期也不必事先告诉编译器，java 的垃圾收集器会自动收走这些不再使用的数据；由于运行时动态分配内存，存取速度较慢。 </p></li><li><ul><li><p>基本数据类型（8种）<br>  定义是通过 int a &#x3D; 3; long b &#x3D; 255L; 的形式定义的，称为自动变量。<br>  自动变量存的是字面值，不是类的实例，即不是类的引用，这里没有类的存在。<br>  如 int a &#x3D; 3; a 是一个指向 int 类型的引用，指向 3 这个字面值<br>  这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。<br>  另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：<br>  int a &#x3D; 3; int b &#x3D; 3;<br>  编译器先处理 int a &#x3D; 3；首先它会在栈中创建一个变量为 a 的引用，然后查找有没有字面值为 3 的地址，没找到，就开辟一个存放 3 这个字面值的地址，然后将 a 指向 3 的地址。接着处理 int b &#x3D; 3；在创建完 b 的引用变量后，由于在栈中已经有 3 这个字面值，便将 b 直接指向 3 的地址。这样，就出现了 a 与 b 同时均指向 3 的情况。  </p></li><li><p>包装类数据<br> 如 Integer, String, Double 等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java 用 new() 语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。</p></li></ul></li><li><p>String 是一个特殊的包装类数据。<br> 即可以用 String str &#x3D; new String(“abc”); 的形式来创建，也可以用 String str &#x3D; “abc”； 的形式来创建(作为对比，在 JDK 5.0 之前，你从未见过 Integer i &#x3D; 3; 的表达式，因为类与字面值是不能通用的，除了 String。而在 JDK 5.0 中，这种表达式是可以的！因为编译器在后台进行 Integer i &#x3D; new Integer(3) 的转换)。前者是规范的类的创建过程，即在 Java 中，一切都是对象，而对象是类的实例，全部通过 new() 的形式来创建。Java 中的有些类，如 DateFormat 类，可以通过该类的 getInstance() 方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过 new() 来创建的，而 getInstance() 向外部隐藏了此细节。那为什么在 String str &#x3D; “abc”；中，并没有通过 new() 来创建实例，是不是违反了上述原则？其实没有。 </p></li><li><p>关于String str &#x3D; “abc”的内部工作。Java内部将此语句转化为以下几个步骤：  </p><ul><li>先定义一个名为str的对String类的对象引用变量：String str；  </li><li>在栈中查找有没有存放值为 “abc” 的地址，如果没有，则开辟一个存放字面值为 “abc” 的地址，接着创建一个新的 String 类的对象 o，并将 o 的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象 o。如果已经有了值为 “abc” 的地址，则查找对象 o，并返回 o 的地址。  </li><li>将 str 指向对象 o 的地址。<br> 值得注意的是，一般 String 类中字符串值都是直接存值的。但像 String str &#x3D; “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！</li></ul><p> 只要是用 new() 来新建对象的，都会在堆中创建，而且其字符串是单独存值的，即使与栈中的数据相同，也不会与栈中的数据共享。  </p></li><li><p>数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的数据类型包装类都不能更改其内部的值。  </p></li><li><p>结论与建议  </p><ul><li><p>使用诸如 String str &#x3D; “abc”；的格式定义类时，总是想当然地认为，我们创建了 String 类的对象 str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向 String 类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过 new() 方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向 String 类的对象的引用变量 str，这个对象引用变量指向了某个值为 “abc” 的 String 类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。  </p></li><li><p>使用 String str &#x3D; “abc”；的方式，可以在一定程度上提高程序的运行速度，因为 JVM 会自动根据栈中数据的实际情况来决定是否有必要创建新对象。而对于 String str &#x3D; new String(“abc”)；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但 JDK 的内部在这里实现是否应用了这个模式，不得而知。  </p></li><li><p>当比较包装类里面的数值是否相等时，用 equals() 方法；当测试两个包装类的引用是否指向同一个对象时，用 &#x3D;&#x3D;。  </p></li><li><p>由于 String 类的不可变性质，当 String 变量需要经常变换其值时，应该考虑使用 StringBuffer 类，以提高程序效率。</p></li></ul></li></ol><hr><p>栈(stack): 是一个先进后出的数据结构,通常用于保存方法(函数)中的参数,局部变量.<br>在 java 中,所有基本类型和引用类型都在栈中存储.栈中数据的生存空间一般在当前 scopes 内(就是由{…}括起来的区域).   </p><p>堆(heap): 是一个可动态申请的内存空间(其记录空闲内存空间的链表由操作系统维护),C 中的 malloc 语句所产生的内存空间就在堆中.<br>在 java 中,所有使用 new xxx() 构造出来的对象都在堆中存储,当垃圾回收器检测到某对象未被引用,则自动销毁该对象.所以,理论上说java中对象的生存空间是没有限制的,只要有引用类型指向它,则它就可以在任意地方被使用. </p><p>在JAVA中，有六个不同的地方可以存储数据：  </p><ol><li>寄存器（register）。这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。  </li><li>堆栈（stack）。位于通用 RAM 中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些 内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA 编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成 相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些JAVA数据存储在堆栈中——特别是对象引用，但是JAVA对象不存储其中。  </li><li>堆（heap）。一种通用性的内存池（也存在于RAM中），用于存放所以的 JAVA 对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区 域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行 这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代码。用堆进行存储分配比用堆栈进行存储存储需要更多的时间。  </li><li>静态存储（static storage）。这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的，但 JAVA 对象本身从来不会存放在静态存储空间里。  </li><li>常量存储（constant storage）。常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分分割离开，所以在这种情况下，可以选择将其放在ROM中  </li><li>非 RAM 存储。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。<br>就速度来说，有如下关系：<br>寄存器 &lt; 堆栈 &lt; 堆 &lt; 其他</li></ol><p><a href="https://www.cnblogs.com/iliuyuet/p/5603618.html">原文链接</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo</title>
    <link href="/2023/12/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/dubbo/Dubbo/"/>
    <url>/2023/12/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/dubbo/Dubbo/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><h4 id="单一应用架构"><a href="#单一应用架构" class="headerlink" title="单一应用架构"></a>单一应用架构</h4><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。  </p><h4 id="垂直应用架构"><a href="#垂直应用架构" class="headerlink" title="垂直应用架构"></a>垂直应用架构</h4><p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p><h4 id="分布式服务架构"><a href="#分布式服务架构" class="headerlink" title="分布式服务架构"></a>分布式服务架构</h4><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。  </p><h4 id="流动计算架构"><a href="#流动计算架构" class="headerlink" title="流动计算架构"></a>流动计算架构</h4><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p><blockquote><p>题外话：<br>短连接是指通讯双方有数据交互时，就建立一个连接，数据发送完成后，则断开此连接，即每次连接只完成一项业务的发送。<br>长连接，指在一个连接上可以连续发送多个数据包，在连接保持期间，如果没有数据包发送，需要双方发链路检测包。<br>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是短连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，下次处理时直接发送数据包就OK了，不用建立TCP连接。<br>WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p></blockquote><h4 id="Zookeeper-和-Eureka"><a href="#Zookeeper-和-Eureka" class="headerlink" title="Zookeeper 和 Eureka"></a>Zookeeper 和 Eureka</h4><ol><li>传统的acid 是什么<br> a 原子性 c 一致性 i 隔离性  d 持久性  </li><li>cap<br> c 强一致性 a 可用性 p 分区容错性</li></ol><p>CPA 定理：<br>  CA: 一致性和可用性，可扩展性能不高，不具有分区容错性，如传统型数据库 MySQL<br>  CP: 为了满足一致性，在系统分区期间会停止服务，知道数据恢复一致，如 BigTable、HBase 等<br>  AP: 注重系统性能和可扩展性，而非强一致性，如 NoSQL 系统中的 Dynamo、Cassandra、SimpleDB  </p><ol><li><p>Zookeeper 保证 CP<br>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接 down 掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是 zk 会出现这样一种情况，当 master 节点因为网络故障与其他节点失去联系时，剩余节点会重新进行 leader 选举。问题在于，选举 leader 的时间太长，30 ~ 120s, 且选举期间整个 zk 集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因网络问题使得 zk 集群失去 master 节点是较大概率会发生的事，虽然服务能够最终恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。  </p></li><li><p>Eureka 保证 AP<br>Eureka 看明白了这一点，因此在设计时就优先保证可用性。Eureka 各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而 Eureka 的客户端在向某个 Eureka 注册或如果发现连接失败，则会自动切换至其它节点，只要有一台 Eureka 还在，就能保证注册服务可用(保证可用性)，只不过查到的信息可能不是最新的(不保证强一致性)。除此之外，Eureka 还有一种自我保护机制，如果在 15 分钟内超过 85% 的节点都没有正常的心跳，那么 Eureka 就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：  </p></li><li><p>Eureka 不再从注册列表中移除因为长时间没收到心跳而应该过期的服务  </p></li><li><p>Eureka 仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)  </p></li><li><p>当网络稳定时，当前实例新的注册信息会被同步到其它节点中</p></li></ol><p>因此， Eureka 可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像 zookeeper 那样使整个注册服务瘫痪。<br>原文：<a href="https://blog.csdn.net/weixin_38399962/article/details/81564122">https://blog.csdn.net/weixin_38399962/article/details/81564122</a>  </p><h3 id="OSI-网络七层模型"><a href="#OSI-网络七层模型" class="headerlink" title="OSI 网络七层模型"></a>OSI 网络七层模型</h3><ul><li>第一层：应用层。定义了用于在网络中进行通信和传输数据的接口；  </li><li>第二层：表示层。定义不同的系统中数据的传输格式，编码和解码规范等；  </li><li>第三层：会话层。管理用户的会话，控制用户间逻辑连接的建立和中断；  </li><li>第四层：传输层。管理着网络中的端到端的数据传输；  </li><li>第五层：网络层。定义网络设备间如何传输数据；  </li><li>第六层：链路层。将上面的网络层的数据包封装成数据帧，便于物理层传输；  </li><li>第七层：物理层。这一层主要就是传输这些二进制数据。</li></ul><p>实际应用过程中，五层协议结构里面是没有表示层和会话层的。应该说它们和应用层合并了。我们应该将重点放在应用层和传输层这两个层面<br>HTTP是应用层协议，而TCP是传输层协议</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RestFul</title>
    <link href="/2023/12/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/restful/"/>
    <url>/2023/12/31/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF/restful/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h2 id="restFul是符合rest架构风格的网络API接口-完全承认Http是用于标识资源。restFul-URL是面向资源的，可以唯一标识和定位资源。对于该URL标识的资源做何种操作是由Http方法决定的。rest请求方法有4种，包括get-post-put-delete-分别对应获取资源，添加资源，更新资源及删除资源。"><a href="#restFul是符合rest架构风格的网络API接口-完全承认Http是用于标识资源。restFul-URL是面向资源的，可以唯一标识和定位资源。对于该URL标识的资源做何种操作是由Http方法决定的。rest请求方法有4种，包括get-post-put-delete-分别对应获取资源，添加资源，更新资源及删除资源。" class="headerlink" title="restFul是符合rest架构风格的网络API接口,完全承认Http是用于标识资源。restFul URL是面向资源的，可以唯一标识和定位资源。对于该URL标识的资源做何种操作是由Http方法决定的。rest请求方法有4种，包括get,post,put,delete.分别对应获取资源，添加资源，更新资源及删除资源。"></a>restFul是符合rest架构风格的网络API接口,完全承认Http是用于标识资源。<br>restFul URL是面向资源的，可以唯一标识和定位资源。<br>对于该URL标识的资源做何种操作是由Http方法决定的。<br>rest请求方法有4种，包括get,post,put,delete.分别对应获取资源，添加资源，更新资源及删除资源。</h2><h2 id="知识剖析"><a href="#知识剖析" class="headerlink" title="知识剖析"></a>知识剖析</h2><ol><li>URL中不可出现动词</li><li>URL能够唯一地标识单个或一类资源</li><li>通过Http动词去操作URL标识的资源(get(获取),pst(添加),put(更新),delete(删除))</li></ol><hr><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ol><li>REST描述的是在网络中client和server的一种交互形式;REST本身不实用,实用的是如何设计 RESTful API(REST风格的网络接口);</li><li>Server提供的RESTful API中,URL中只使用名词来指定资源,原则上不使用动词。“资源”是REST架构或者说整个网络处理的核心</li><li>用HTTP协议里的动词来实现资源的添加,修改,删除等操作。即通过HTTP动词来实现资源的状态扭转:<ul><li>GET 用来获取资源,</li><li>POST 用来新建资源(也可以用于更新资源),</li><li>PUT 用来更新资源,</li><li>DELETE 用来删除资源。</li></ul></li><li>Server和Client之间传递某资源的一个表现形式,比如用JSON,XML传输文本,或者用JPG,WebP传输图片等。当然还可以压缩HTTP传输时的数据(on-wire data compression)。</li><li>用 HTTP Status Code传递Server的状态信息。比如最常用的 200 表示成功,500 表示Server内部错误等。</li></ol><hr><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><h3 id="1-资源与URI"><a href="#1-资源与URI" class="headerlink" title="1. 资源与URI"></a>1. 资源与URI</h3><ul><li>资源可以是实体(例如手机号码)，也可以只是一个抽象概念(例如价值)<br>要让一个资源可以被识别，需要有个唯一标识，在Web中这个唯一标识就是URI(Uniform Resource Identifier)。</li><li>URI既可以看成是资源的地址，也可以看成是资源的名称。</li><li>如果某些信息没有使用URI来表示，那它就不能算是一个资源， 只能算是资源的一些信息而已。</li><li>URI的设计应该遵循可寻址性原则，具有自描述性，需要在形式上给人以直觉上的关联</li></ul><p>URI设计的些技巧:  </p><ul><li>使用_或-来让URI可读性更好  </li><li>使用&#x2F;来表示资源的层级关系  </li><li>使用?用来过滤资源  </li><li>,或;可以用来表示同级资源的关系</li></ul><h3 id="2-统一资源接口"><a href="#2-统一资源接口" class="headerlink" title="2. 统一资源接口"></a>2. 统一资源接口</h3><ul><li>统一接口包含了一组受限的预定义的操作，不论什么样的资源，都是通过使用相同的接口进行资源的访问。</li><li>接口应该使用标准的HTTP方法如GET，PUT和POST，并遵循这些方法的语义</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>POST和PUT用于创建资源时有什么区别?<br>  POST和PUT在创建资源的区别在于，所创建的资源的名称(URI)是否由客户端决定</li><li>客户端不一定都支持这些HTTP方法吧?<br>  一些比较古老的基于浏览器的客户端，只能支持GET和POST两种方法<br>  在实践上，客户端和服务端都可能需要做一些妥协。<br>  例如rails框架就支持通过隐藏参数_method&#x3D;DELETE来传递真实的请求方法，<br>  而像Backbone这样的客户端MVC框架则允许传递_method传输和设置X-HTTP-Method-Override头来规避这个问题。</li><li>统一接口是否意味着不能扩展带特殊语义的方法?<br>  统一接口并不阻止你扩展方法，只要方法对资源的操作有着具体的、可识别的语义即可，并能够保持整个接口的统一性。</li><li>统一资源接口对URI有什么指导意义?<br>  统一资源接口要求使用标准的HTTP方法对资源进行操作，所以URI只应该来表示资源的名称，而不应该包括资源的操作。<br>  通俗来说，URI不应该使用动作来描述。</li><li>直接忽视缓存可取吗?<br>  即使你按各个动词的原本意图来使用它们，你仍可以轻易禁止缓存机制。<br>  最简单的做法就是在你的HTTP响应里增加这样一个报头： Cache-control: no-cache。<br>  但是，同时你也对失去了高效的缓存与再验证的支持(使用Etag等机制)</li><li>响应代码的处理有必要吗?<br>  HTTP的响应代码可用于应付不同场合，<br>  正确使用这些状态代码意味着客户端与服务器可以在一个具备较丰富语义的层次上进行沟通</li></ul><h3 id="3-资源的表述"><a href="#3-资源的表述" class="headerlink" title="3. 资源的表述"></a>3. 资源的表述</h3><p>资源在外界的具体呈现，可以有多种表述(或成为表现、表示)形式，在客户端和服务端之间传送的也是资源的表述，而不是资源本身。<br>资源的表述包括数据和描述数据的元数据，例如，HTTP头”Content-Type” 就是这样一个元数据属性。<br>通过HTTP内容协商，客户端可以通过Accept头请求一种特定格式的表述，服务端则通过Content-Type告诉客户端资源的表述形式。</p><ul><li>在URI里边带上版本号<br>  把版本号理解成资源的不同表述形式的话，就应该只是用一个URL，并通过Accept头部来区分</li><li>使用URI后缀来区分表述格式<br>  像rails框架，就支持使用&#x2F;users.xml或&#x2F;users.json来区分不同的格式。<br>  这样的方式对于客户端来说，无疑是更为直观，但混淆了资源的名称和资源的表述形式。<br>  我个人认为，还是应该优先使用内容协商来区分表述格式。</li><li>如何处理不支持的表述格式<br>  若服务器不支持，它应该返回一个HTTP 406响应，表示拒绝处理该请求</li></ul><h3 id="4-资源的链接"><a href="#4-资源的链接" class="headerlink" title="4. 资源的链接"></a>4. 资源的链接</h3><p>超媒体即应用状态引擎（hypermedia as the engine of application state）</p><ul><li>当你浏览Web网页时，从一个连接跳到一个页面，再从另一个连接跳到另外一个页面，就是利用了超媒体的概念：把一个个把资源链接起来  </li><li>要达到这个目的，就要求在表述格式里边加入链接来引导客户端。</li></ul><h3 id="5-状态的转移"><a href="#5-状态的转移" class="headerlink" title="5. 状态的转移"></a>5. 状态的转移</h3><p>状态应该区分应用状态和资源状态，客户端负责维护应用状态，而服务端维护资源状态。<br>客户端与服务端的交互必须是无状态的，并在每一次请求中包含处理该请求所需的一切信息。<br>服务端不需要在请求间保留应用状态，只有在接受到实际请求的时候，服务端才会关注应用状态。<br>这种无状态通信原则，使得服务端和中介能够理解独立的请求和响应。<br>在多次请求中，同一客户端也不再需要依赖于同一服务器，方便实现高可扩展和高可用性的服务端。<br>但有时候我们会做出违反无状态通信原则的设计，例如利用Cookie跟踪某个服务端会话状态，常见的像J2EE里边的JSESSIONID。<br>这意味着，浏览器随各次请求发出去的Cookie是被用于构建会话状态的。<br>当然，如果Cookie保存的是一些服务器不依赖于会话状态即可验证的信息（比如认证令牌），这样的Cookie也是符合REST原则的。  </p><p>状态转移到这里已经很好理解了， “会话”状态不是作为资源状态保存在服务端的，而是被客户端作为应用状态进行跟踪的。<br>客户端应用状态在服务端提供的超媒体的指引下发生变迁。<br>服务端通过超媒体告诉客户端当前状态有哪些后续状态可以进入。  </p><p>这些类似”下一页”之类的链接起的就是这种推进状态的作用——指引你如何从当前状态进入下一个可能的状态</p><hr><h2 id="RPC和Rest"><a href="#RPC和Rest" class="headerlink" title="RPC和Rest"></a>RPC和Rest</h2><p>RPC是以动词为中心的, REST是以名词为中心的  </p><ul><li>以动词为中心,<br>  意味着,当你要需要加入新功能时,你必须要添加更多的动词,<br>  这时候服务器端需要实现 相应的动词(方法), 客户端需要知道这个新的动词并进行调用  </li><li>以名词为中心,<br>  假使我请求的是 hostname&#x2F;friends&#x2F;,<br>  无论这个URI对应的服务怎么变化,客户端是无需关注和更新的,而这种变化对客户端也是透明的。</li></ul>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>API接口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RestFul</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell</title>
    <link href="/2023/12/31/%E5%91%BD%E4%BB%A4/shell/"/>
    <url>/2023/12/31/%E5%91%BD%E4%BB%A4/shell/</url>
    
    <content type="html"><![CDATA[<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p><a href="http://c.biancheng.net/view/706.html">学习网址</a></p><p>在线运行 Shell 命令<br><a href="http://www.dooccn.com/shell/">http://www.dooccn.com/shell/</a>  </p><p>Shell 除了能解释用户输入的命令，将它传递给内核，还可以：  </p><ul><li>调用其他程序，给其他程序传递数据或参数，并获取程序的处理结果；  </li><li>在多个程序之间传递数据，把一个程序的输出作为另一个程序的输入；  </li><li>Shell 本身也可以被其他程序调用。</li></ul><p>Shell 是将内核、程序和用户连接起来  </p><h3 id="编译型语言和脚本语言"><a href="#编译型语言和脚本语言" class="headerlink" title="编译型语言和脚本语言"></a>编译型语言和脚本语言</h3><ul><li>有的编程语言，如 C&#x2F;C++、Pascal、Go语言、汇编等，必须在程序运行之前将所有代码都翻译成二进制形式，也就是生成可执行文件，用户拿到的是最终生成的可执行文件，看不到源码。<br>这个过程叫做编译（Compile），这样的编程语言叫做编译型语言，完成编译过程的软件叫做编译器（Compiler）。  </li><li>而有的编程语言，如 Shell、JavaScript、Python、PHP等，需要一边执行一边翻译，不会生成任何可执行文件，用户必须拿到源码才能运行程序。程序运行后会即时翻译，翻译完一部分执行一部分，不用等到所有代码都翻译完。<br>这个过程叫做解释，这样的编程语言叫做解释型语言或者脚本语言（Script），完成解释过程的软件叫做解释器。  </li><li>编译型语言的优点是执行速度快、对硬件要求低、保密性好，适合开发操作系统、大型应用程序、数据库等。  </li><li>脚本语言的优点是使用灵活、部署容易、跨平台性好，非常适合Web开发以及小工具的制作。</li></ul><p>Linux 运维工程师（OPS）  </p><p>bash shell 是 Linux 的默认 shell<br>在现代的 Linux 上，sh 已经被 bash 代替，&#x2F;bin&#x2F;sh往往是指向&#x2F;bin&#x2F;bash的符号链接。<br>查看当前 Linux 的默认 Shell： <code>echo $SHELL</code><br><code>SHELL</code> 是 Linux 系统中的环境变量，它指明了当前使用的 Shell 程序的位置，也就是使用的哪个 Shell。  </p><p>CentOS 切换控制机台模式 ctrl+Alt+Fn(1,2,3,4,5,6…)  </p><p>对于普通用户，Base shell 默认的提示符是美元符号$；对于超级用户（root 用户），Bash Shell 默认的提示符是井号#。该符号表示 Shell 等待输入命令。  </p><p>Shell 通过PS1和PS2两个环境变量来控制提示符格式：  </p><ul><li>PS1 控制最外层命令行的提示符格式。  </li><li>PS2 控制第二层命令行的提示符格式。<br>可以通过修改 PS1 变量来修改提示符格式，例如：  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7"><span class="hljs-comment">[mozhiyan@localhost ~]</span>$ PS1=<span class="hljs-string">&quot;<span class="hljs-subst">[\t]</span><span class="hljs-subst">[\u]</span>\$ &quot;</span><br><span class="hljs-comment">[17:27:34]</span><span class="hljs-comment">[mozhiyan]</span>$ <br></code></pre></td></tr></table></figure>新定义的 PS1 变量只在当前 Shell 会话期间有效，再次启动 Shell 时将重新使用默认的提示符格式</li></ul><p>扩展名sh代表 shell，扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用php好了。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World !&quot;</span>  <span class="hljs-comment">#这是一条语句</span><br></code></pre></td></tr></table></figure><p><code>#!</code> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell；后面的 &#x2F;bin&#x2F;bash 就是指明了解释器的具体位置。<br><code>.sh</code> 文件中使用命令与在终端直接输入命令的效果是一样的  </p><p>执行 Shell 脚本的方式：<br>（1）bash script-name 或者sh script-name<br>这是当脚本文件本身没有可执行权限（即文件权限属性 x 位为-号）时常使用的方法，或者脚本文件开头没有指定解释器时需要使用的方法。推荐使用这种方法。<br>（2）path&#x2F;script-name 或者 .&#x2F;script-name<br>指在当前路径下执行脚本（脚本需要有执行权限），需要将脚本文件的权限改为可执行（即文件权限属性为x位）。具体方法为: chmod +x script-name。然后通过执行脚本绝对路径或者相对路径就可以执行脚本了。<br>注意：在生产环境中，运维人员由于忘记为该脚本设置可执行权限，然后直接使用，导致出错。因此，推荐第一种 bash script-name。<br>（3）source script-name 或者 . script-name<br>source 或者 “.” 命令的功能是：读入脚本并执行脚本，即在当前 Shell 中执行 source 或 “.” 加载并执行的相关脚本文件的命令及语句，而不是产生一个子 Shell 来执行文件中的命令。<br>bash script-name 是产生了一个子进程 shell，而我们当前的操作还在父 shell 中因此得不到该变量值。<br>一个规范的 Shell 脚本在第一行会指出由哪个程序（解释器）来执行脚本中的内容，这一行内容在 Linux bash 的编程一般为：<code>#！/bin/bash</code> 或 <code>#！/bin/sh</code>  </p><p>原文：<a href="https://blog.csdn.net/timchen525/article/details/76407735">https://blog.csdn.net/timchen525/article/details/76407735</a>  </p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。  </p><p>Shell 支持以下三种定义变量的方式：  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">variable</span>=value<br><span class="hljs-attr">variable</span>=<span class="hljs-string">&#x27;value&#x27;</span><br><span class="hljs-attr">variable</span>=<span class="hljs-string">&quot;value&quot;</span><br></code></pre></td></tr></table></figure><p>variable 是变量名，value 是赋给变量的值。如果 value 不包含任何空白符（例如空格、Tab 缩进等），那么可以不使用引号；如果 value 包含了空白符，那么就必须使用引号包围起来。  </p><blockquote><p>注意，赋值号 <code>=</code> 的周围不能有空格</p></blockquote><p>Shell 变量的命名规范和大部分编程语言都一样：  </p><ul><li>变量名由数字、字母、下划线组成；  </li><li>必须以字母或者下划线开头；  </li><li>不能使用 Shell 里的关键字（通过 help 命令可以查看保留关键字）。</li></ul><p>使用一个定义过的变量，只要在变量名前面加美元符号 $ 即可<br>变量名外面的花括号 { } 是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">skill</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;Java&quot;</span><br>echo <span class="hljs-string">&quot;I am good at $&#123;skill&#125;Script&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>推荐给所有变量加上花括号{ }，这是个良好的编程习惯。</p></blockquote><p>第二次对变量赋值时不能在变量名前加 $，只有在使用变量时才能加 $。  </p><p>以单引号 ‘ ‘ 包围变量的值时，单引号里面是什么就输出什么，即使内容中有变量和命令（命令需要反引起来）也会把它们原样输出。这种方式比较适合定义显示纯字符串的情况，即不希望解析变量、命令等的场景。  </p><p>以双引号 “ “ 包围变量的值时，输出时会先解析里面的变量和命令，而不是把双引号中的变量名和命令原样输出。这种方式比较适合字符串中附带有变量和命令并且想将其解析后再输出的变量定义。  </p><p><strong>将命令的结果赋值给变量</strong><br>第一种方式把命令用反引号 <code> </code>（位于 Esc 键的下方）包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；第二种方式把命令用$()包围起来，区分更加明显，所以推荐使用这种方式。  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">log = <span class="hljs-constructor">$(<span class="hljs-params">cat</span> <span class="hljs-params">log</span>.<span class="hljs-params">txt</span>)</span><br></code></pre></td></tr></table></figure><p><strong>只读变量</strong><br>readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。<br><code>readonly param</code>  </p><p><strong>删除变量</strong><br><code>unset variable_name</code><br>变量被删除后不能再次使用；unset 命令不能删除只读变量。  </p><h3 id="Shell-变量的作用域"><a href="#Shell-变量的作用域" class="headerlink" title="Shell 变量的作用域"></a>Shell 变量的作用域</h3><p>作用域： Shell 变量的有效范围（可以使用的范围）<br>Shell 变量的作用域可以分为三种：  </p><ul><li>有的变量可以在当前 Shell 会话中使用，这叫做全局变量（global variable）；  </li><li>有的变量只能在函数内部使用，这叫做局部变量（local variable）；  </li><li>而有的变量还可以在其它 Shell 中使用，这叫做环境变量（environment variable）。</li></ul><p><strong>全局变量</strong><br>在当前整个 Shell 会话中都有效。<br>在 Shell 中定义的变量，默认就是全局变量。  </p><p><strong>局部变量</strong><br>在 Shell 函数中定义的变量默认也是全局变量，它和在函数外部定义变量拥有一样的效果<br>要想变量的作用域仅限于函数内部，那么可以在定义时加上 local 命令，此时该变量就成了局部变量  </p><p><strong>环境变量</strong><br>全局变量只在当前 Shell 会话中有效，如果使用 <code>export</code> 命令将它导出，那么它就在所有的子 Shell 中也有效了，这称为“环境变量”  </p><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>运行 Shell 脚本文件时我们可以给它传递一些参数，这些参数在脚本文件内部可以使用 <code>$n</code> 的形式来接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。<br>调用函数时也可以传递参数。Shell 函数参数的传递和其它编程语言不同，没有所谓的形参和实参，在定义函数时也不用指明参数的名字和数目。换句话说，定义 Shell 函数时不能带参数，但是在调用函数时却可以传递参数，这些传递进来的参数，在函数内部就也使用 <code>$n</code> 的形式接收，例如，$1 表示第一个参数，$2 表示第二个参数，依次类推。  </p><p>通过 <code>$n</code> 的形式来接收的参数，在 Shell 中称为位置参数。  </p><blockquote><p>如果参数个数太多，达到或者超过了 10 个，那么就得用 <code>$&#123;n&#125;</code> 的形式来接收了，例如 $ {10}、${23}。{ }的作用是为了帮助解释器识别参数的边界，这跟使用变量时加{ }是一样的效果。</p></blockquote><table><thead><tr><th align="left">变量</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">$0</td><td align="left">当前脚本的文件名。</td></tr><tr><td align="left">$n（n≥1）</td><td align="left">传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2。</td></tr><tr><td align="left">$#</td><td align="left">传递给脚本或函数的参数个数。</td></tr><tr><td align="left">$*</td><td align="left">传递给脚本或函数的所有参数。</td></tr><tr><td align="left">$@</td><td align="left">传递给脚本或函数的所有参数。当被双引号” “包含时， $@ 与 $* 稍有不同，我们将在《Shell $* 和 $@的区别》一节中详细讲解。</td></tr><tr><td align="left">$?</td><td align="left">上个命令的退出状态，或函数的返回值，我们将在《Shell $?》一节中详细讲解。</td></tr><tr><td align="left">$ $</td><td align="left">当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程 ID。</td></tr></tbody></table><p><code>$@</code> 和 <code>$*</code> 被双引号 “” 包含时，就会有区别了：  </p><ul><li>“$*” 会将所有的参数从整体上看做一份数据，而不是把每个参数都看做一份数据。  </li><li>“$@” 仍然将每个参数都看作一份数据，彼此之间是独立的。</li></ul><hr><ol><li>由单引号’ ‘包围的字符串：</li></ol><ul><li>任何字符都会原样输出，在其中使用变量是无效的。  </li><li>字符串中不能出现单引号，即使对单引号进行转义也不行。</li></ul><ol start="2"><li>由双引号” “包围的字符串：</li></ol><ul><li>如果其中包含了某个变量，那么该变量会被解析（得到该变量的值），而不是原样输出。  </li><li>字符串中可以出现双引号，只要它被转义了就行。</li></ul><ol start="3"><li>不被引号包围的字符串</li></ol><ul><li>不被引号包围的字符串中出现变量时也会被解析，这一点和双引号” “包围的字符串一样。  </li><li>字符串中不能出现空格，否则空格后边的会作为其他变量或者字符串解析。</li></ul><p><strong>获取字符串长度</strong> &#96;$</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue 笔记</title>
    <link href="/2023/12/31/%E5%89%8D%E7%AB%AF/Vue%20%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/31/%E5%89%8D%E7%AB%AF/Vue%20%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue-笔记"><a href="#Vue-笔记" class="headerlink" title="Vue 笔记"></a>Vue 笔记</h2><h3 id="1-数据绑定"><a href="#1-数据绑定" class="headerlink" title="1. 数据绑定"></a>1. 数据绑定</h3><h4 id="1-1-实例"><a href="#1-1-实例" class="headerlink" title="1.1 实例"></a>1.1 实例</h4><p><code>var app = new Vue(&#123;&#125;);</code>  </p><p>变量 <code>app</code> Vue 实例.<br>b&#x3D;必不可少的选项是 <code>el</code>，指定一个页面中已存在的 DOM 元素来挂载 Vue 实例，可以是 HTMLElement，也可以是 CSS 选择器。<br>data 选项，可以声明应用内需要双向绑定的数据。  </p><h4 id="1-2-生命周期"><a href="#1-2-生命周期" class="headerlink" title="1.2 生命周期"></a>1.2 生命周期</h4><p><code>created</code>： 实例创建完成后调用，此阶段完成了数据的观测等，但尚未挂载， $el 还不可用，需要初始化处理一些数据时比较有用<br><code>mounted</code>: el 挂载到实例上后调用，第一个业务逻辑<br><code>beforeDestroy</code>: 实例销毁之前调用，主要解绑一些使用 addEventListener 监听的事件  </p><p>钩子的 this 指向的是调用它的 Vue 实例  </p><h4 id="1-3-插值与表达式"><a href="#1-3-插值与表达式" class="headerlink" title="1.3 插值与表达式"></a>1.3 插值与表达式</h4><p><code>&#123;&#123;&#125;&#125;</code> 是最基本的文本插值方法，会自动将双向绑定的数据实时显示；还可以使用 JS 表达式进行简单的运算、三元运算等<br><code>v-html</code> 输出 HTML，有可能导致 XSS 攻击，所以需在服务端对提交的内容进行处理<br><code>v-pre</code> 跳过元素和子元素的编译，即会原样输出<br>只支持单个表达式，不支持语句和流控制，不能使用用户自定义的全局变量，只能使用 Vue 白名单内的全局变量，如 Math 和 Date  </p><h4 id="1-4-过滤器"><a href="#1-4-过滤器" class="headerlink" title="1.4 过滤器"></a>1.4 过滤器</h4><p>Vue.js 支持在 <code>&#123;&#123;&#125;&#125;</code> 插值的尾部添加一个管道符<code>|</code>对数据进行过滤，经常用于格式化文本<br>过滤规则自定义的，通过 Vue 实例添加选项 filters 来设置<br>过滤器也可以串联，而且可以接收参数  </p><h4 id="1-5-指令与事件"><a href="#1-5-指令与事件" class="headerlink" title="1.5 指令与事件"></a>1.5 指令与事件</h4><p>指令，带有前缀 <code>v-</code> ；职责是当其表达式的值改变时，相应地将某些行为应用到 DOM 上。<br><code>v-bind</code>：动态更新 HTML 元素上的属性，可以省略<code>v-bind</code>，直接写一个<code>:</code><br><code>v-on</code>：绑定事件监听器，可以直接用<code>@</code>来缩写  </p><hr><h3 id="2-计算属性"><a href="#2-计算属性" class="headerlink" title="2. 计算属性"></a>2. 计算属性</h3><p>模板内的表达式常用于简单的运算，计算属性处理复杂逻辑<br>计算属性是基于它的依赖缓存的，一个计算属性所依赖的数据发生变化时，它才会重新取值；但是 <code>methods</code> 则不同，只要重新渲染，它就会被调用。<br>使用计算属性还是 <code>methods</code> 取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非不希望得到缓存  </p><hr><h3 id="3-v-bind-及-class-与-style-绑定"><a href="#3-v-bind-及-class-与-style-绑定" class="headerlink" title="3. v-bind 及 class 与 style 绑定"></a>3. v-bind 及 class 与 style 绑定</h3><h4 id="3-1-绑定-class-的几种方式"><a href="#3-1-绑定-class-的几种方式" class="headerlink" title="3.1 绑定 class 的几种方式"></a>3.1 绑定 class 的几种方式</h4><h5 id="3-1-1-对象语法"><a href="#3-1-1-对象语法" class="headerlink" title="3.1.1 对象语法"></a>3.1.1 对象语法</h5><ul><li><code>:class=&#123;&#39;active&#39;: isActive&#125;</code>: 根据 <code>isActive</code> 的值决定是否渲染 active，如为 <code>true</code>，则最终渲染完的结果是 <code>&lt;div class = &quot;active&quot;&gt;&lt;/div&gt;</code>  </li><li><code>:class=&#123;&#39;active&#39;: isActive, &#39;error&#39;: isError&#125;</code>: 可以传入多个属性，与普通 class 共存  </li><li>当 <code>:class</code> 的表达式过长或逻辑复杂时，还可以绑定一个计算属性。一般当条件多于两个时，都可以使用 <code>data</code> 或 <code>computed</code>  </li><li>可以直接绑定一个 <code>Object</code> 类型的数据</li></ul><h5 id="3-1-2-数组语法"><a href="#3-1-2-数组语法" class="headerlink" title="3.1.2 数组语法"></a>3.1.2 数组语法</h5><ul><li>可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表  </li><li>三元表达式根据条件切换 class，如 <code>&lt;div :class=&quot;[isActive ? activeCls : &#39;&#39;, errorCls]&quot;&gt;&lt;/div&gt;</code>  </li><li>也可以使用对象语法，如&#96;&#96;<div :class="[{'active': isActive}, errorCls]"></div>&#96;</li></ul><h5 id="3-1-3-用在组件上"><a href="#3-1-3-用在组件上" class="headerlink" title="3.1.3 用在组件上"></a>3.1.3 用在组件上</h5><p>当在一个自定义组件上使用 class 属性时，这些类将被添加到该组件的根元素上面。这个元素上已经存在的类不会被覆盖。对于带数据绑定 class 也同样适用  </p><h5 id="3-1-4-绑定内联样式"><a href="#3-1-4-绑定内联样式" class="headerlink" title="3.1.4 绑定内联样式"></a>3.1.4 绑定内联样式</h5><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 CSS，但其实是一个 JavaScript 对象。CSS 属性名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名，如 <code>&lt;div :style=&quot;&#123;&#39;color&#39;: color, &#39;fontSize&#39;: fontSize + &#39;px&#39;&#125;&quot;&gt;&lt;/div&gt;</code><br>直接绑定到一个样式对象通常更好，模板更清晰；常常结合返回对象的计算属性使用<br>可以将多个样式对象应用到同一个元素上  </p><h3 id="4-内置指令"><a href="#4-内置指令" class="headerlink" title="4. 内置指令"></a>4. 内置指令</h3><h4 id="4-1-基本指令"><a href="#4-1-基本指令" class="headerlink" title="4.1 基本指令"></a>4.1 基本指令</h4><h5 id="4-1-1-v-cloak"><a href="#4-1-1-v-cloak" class="headerlink" title="4.1.1 v-cloak"></a>4.1.1 v-cloak</h5><p>不需要表达式，和 CSS 规则如 <code>[v-cloak] &#123; display: none &#125;</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕  </p><h5 id="4-1-2-v-once"><a href="#4-1-2-v-once" class="headerlink" title="4.1.2 v-once"></a>4.1.2 v-once</h5><p>不需要表达式，只渲染元素和组件一次。随后的重新渲染，元素&#x2F;组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能  </p><h4 id="4-2-条件渲染指令"><a href="#4-2-条件渲染指令" class="headerlink" title="4.2 条件渲染指令"></a>4.2 条件渲染指令</h4><h5 id="4-2-1-v-if、v-else-if、v-else"><a href="#4-2-1-v-if、v-else-if、v-else" class="headerlink" title="4.2.1 v-if、v-else-if、v-else"></a>4.2.1 v-if、v-else-if、v-else</h5><p>Vue 在渲染元素时，出于效率考虑，会尽可能地复用已有的元素而非重新渲染；<code>key</code> 决定是否要复用元素，<code>key</code> 的值必须是唯一的  </p><h5 id="4-2-2-v-show"><a href="#4-2-2-v-show" class="headerlink" title="4.2.2 v-show"></a>4.2.2 v-show</h5><p><code>v-show</code> 是改变元素的 CSS 属性 display。当表达式的值为 flase 时，元素会隐藏，查看 DOM 结构会看到元素上加载了内联样式 <code>display:none;</code>  </p><blockquote><p><code>v-show</code> 不能再&lt;template&gt;上使用</p></blockquote><h5 id="4-2-3-v-if-与-v-show-的选择"><a href="#4-2-3-v-if-与-v-show-的选择" class="headerlink" title="4.2.3 v-if 与 v-show 的选择"></a>4.2.3 v-if 与 v-show 的选择</h5><p><code>v-if</code> 会根据表达式适当地销毁或重建元素及绑定的事件或子组件。若表达式初始值为 false，则一开始元素&#x2F;组件并不会渲染，只有当条件第一次变为真时才开始编译。<br><code>v-show</code> 只是简单的 CSS 属性切换，无论条件真与否，都会被编译。<br><code>v-if</code> 更适合条件不经常改变的场景，因为它切换开销相对较大，而 <code>v-show</code> 适用于频繁切换条件，有更高的初始渲染开销  </p><h4 id="4-3-列表渲染指令-v-for"><a href="#4-3-列表渲染指令-v-for" class="headerlink" title="4.3 列表渲染指令 v-for"></a>4.3 列表渲染指令 v-for</h4><h5 id="4-3-1-基本用法"><a href="#4-3-1-基本用法" class="headerlink" title="4.3.1 基本用法"></a>4.3.1 基本用法</h5><p>基于一个数组来渲染一个列表。<br><code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是元数据数组，而 <code>item</code> 则是被迭代的数组元素的别名<br><code>v-for</code> 块中可以访问所有父作用域的属性，还支持一个可选的第二个参数，即当前项的索引<br><code>v-for</code> 可以用 <code>of</code> 代替 <code>in</code> 作为分隔符，因为更接近 JavaScript 迭代器的语法<br><code>v-for</code> 可以遍历一个对象的属性；可以提供第二个的参数（可选）为 property 名称（也就是键名）；第三个参数（可选）作为索引</p><h5 id="4-3-2-数组更新"><a href="#4-3-2-数组更新" class="headerlink" title="4.3.2 数组更新"></a>4.3.2 数组更新</h5><p>Vue 包含了一组观察数组变异的方法，使用它们改变数组也会触发视图更新：</p><ul><li><code>push()</code>  </li><li><code>pop()</code>  </li><li><code>shift()</code>  </li><li><code>unshift()</code>  </li><li><code>splice()</code>  </li><li><code>sort()</code>  </li><li><code>reverse()</code><br>会改变调用这些方法的原始数组</li></ul><p>以下方法不会改变原数组:  </p><ul><li>filter()  </li><li>concat()  </li><li>slice()<br>会返回一个新数组，在使用这些非变异方法时，可以用新数组来替换原数组</li></ul><p>由于 JavaScript 的限制，Vue 是不能检测以下数组的变动：  </p><ul><li>通过索引直接设置项，比如 <code>vm.items[indexOfItem] = newValue</code>  </li><li>修改数组长度，比如 <code>vm.items.length = newLength</code></li></ul><p>解决第一类，可以使用以下两种方式，同时也将在响应式系统内触发状态更新：  </p><ul><li><code>Vue.set(vm.items, indexOfItem, newValue)</code>  </li><li><code>vm.items.splice(indexOfItem, 1, newValue)</code>  </li><li><code>vm.$set(vm.items, indexOfItem, newValue)</code></li></ul><p>解决第二类，可以使用 <code>splice</code>:<br><code>vm.items.splice(newLength)</code>  </p><blockquote><p><strong>对象变更检测注意事项</strong><br>由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除。<br>不允许动态添加根级别的响应式属性，但，可以使用 <code>Vue.set(object, propertyName,  value)</code> 或 <code>vm.$set(object, propertyName, value)</code> 方法向嵌套对象添加响应式属性<br>使用 <code>Object.assign()</code> 或 <code>_.extend()</code><br>为已有对象赋值多个新属性，应该用两个对象的属性创建一个新的对象：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vm<span class="hljs-selector-class">.userProfile</span> = Object<span class="hljs-selector-class">.assign</span>(&#123;&#125;, vm<span class="hljs-selector-class">.userProfile</span>, &#123;<br>   age: <span class="hljs-number">27</span>,<br>   favoriteColor: <span class="hljs-string">&#x27;Vue Green&#x27;</span><br> &#125;)<br></code></pre></td></tr></table></figure></blockquote><h5 id="4-3-3-过滤与排序"><a href="#4-3-3-过滤与排序" class="headerlink" title="4.3.3 过滤与排序"></a>4.3.3 过滤与排序</h5><p>可以创建一个计算属性，来返回过滤或排序后的数组，而不实际改变或重置原始数据<br>在计算属性不使用的情况下（例如，在嵌套 <code>v-for</code> 循环中），可以使用一个方法：  </p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;n in even(numbers)&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">n</span> &#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">data: &#123;<br>  <span class="hljs-attr">numbers</span>: [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> ]<br>&#125;,<br><span class="hljs-attr">methods</span>: &#123;<br>  <span class="hljs-attr">even</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">numbers</span>) &#123;<br>    <span class="hljs-keyword">return</span> numbers.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">number</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-4-在-v-for-里使用值范围"><a href="#4-3-4-在-v-for-里使用值范围" class="headerlink" title="4.3.4 在 v-for 里使用值范围"></a>4.3.4 在 <code>v-for</code> 里使用值范围</h5><p><code>v-for</code> 也可以接受整数，会将模板重复对应次数  </p><h5 id="4-3-5-在-lt-template-gt-上使用-v-for"><a href="#4-3-5-在-lt-template-gt-上使用-v-for" class="headerlink" title="4.3.5 在 &lt;template&gt; 上使用 v-for"></a>4.3.5 在 &lt;template&gt; 上使用 <code>v-for</code></h5><p>在模板上循环渲染一段包含多个元素的内容  </p><h4 id="4-4-方法与事件"><a href="#4-4-方法与事件" class="headerlink" title="4.4 方法与事件"></a>4.4 方法与事件</h4><h5 id="4-4-1-基本用法"><a href="#4-4-1-基本用法" class="headerlink" title="4.4.1 基本用法"></a>4.4.1 基本用法</h5><p><code>@click</code> 调用的方法名后可以不跟括号 <code>&quot;()&quot;</code>，如果该方法有参数，默认会将原生事件对象 event 传入<br>通过 HTML 就可以知道调用的是哪个方法，将逻辑与 DOM 解耦，便于维护。<br>更重要的是，当 ViewModel 销毁时，所有的事件处理器会自动删除，无效自己清理。<br><code>$event</code> 用于访问原生 DOM 事件。  </p><h5 id="4-4-2-修饰符"><a href="#4-4-2-修饰符" class="headerlink" title="4.4.2 修饰符"></a>4.4.2 修饰符</h5><p>在事件处理程序中调用 <code>event.preventDefault()</code> 或 <code>event.stopPropagation()</code> 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。<br>Vue.js 为 <code>v-on</code> 提供了事件修饰符，修饰符是由点开头的指令后缀来表示的:  </p><ul><li><code>.stop</code>: 阻止事件冒泡（阻止事件向上级 DOM 元素传递）  </li><li><code>.prevent</code>: 防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）  </li><li><code>.capture</code>: 与事件冒泡的方向相反，事件捕获由外到内  </li><li><code>.self</code>: 只会触发自己范围内的事件，不包含子元素  </li><li><code>.once</code>: 只会触发一次  </li><li><code>.passive</code>： 对 DOM 的默认事件进行性能优化</li></ul><h5 id="4-4-3-按键修饰符"><a href="#4-4-3-按键修饰符" class="headerlink" title="4.4.3 按键修饰符"></a>4.4.3 按键修饰符</h5><ul><li><code>.enter</code>  </li><li><code>.tab</code>  </li><li><code>.delete (捕获“删除”和“退格”键)</code>  </li><li><code>.esc</code>  </li><li><code>.space</code>  </li><li><code>.up</code>  </li><li><code>.down</code>  </li><li><code>.left</code>  </li><li><code>.right</code></li></ul><p>可以通过全局 <code>config.keyCodes</code> 对象自定义按键修饰符别名： <code>Vue.config.keyCodes.f1 = 112</code>  </p><h4 id="4-4-4-系统修饰符"><a href="#4-4-4-系统修饰符" class="headerlink" title="4.4.4 系统修饰符"></a>4.4.4 系统修饰符</h4><p>可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。</p><ul><li><code>.ctrl</code>  </li><li><code>.alt</code>  </li><li><code>.shift</code>  </li><li><code>.meta</code></li></ul><h5 id="4-4-5-修饰符"><a href="#4-4-5-修饰符" class="headerlink" title="4.4.5 修饰符"></a>4.4.5 修饰符</h5><p><code>.exact</code> 修饰符允许你控制有精确的系统修饰符组合触发的事件  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <br><br><span class="hljs-comment">&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <br><br><span class="hljs-comment">&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.exact</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>  <br></code></pre></td></tr></table></figure><h5 id="4-4-6-鼠标按钮修饰符"><a href="#4-4-6-鼠标按钮修饰符" class="headerlink" title="4.4.6 鼠标按钮修饰符"></a>4.4.6 鼠标按钮修饰符</h5><ul><li><code>.left</code>  </li><li><code>.right</code>  </li><li><code>.middle</code></li></ul><p>这些修饰符会限制处理函数仅响应特定的鼠标按钮。  </p><hr><h3 id="5-表单与-v-model"><a href="#5-表单与-v-model" class="headerlink" title="5. 表单与 v-model"></a>5. 表单与 v-model</h3><h4 id="5-1-基本用法"><a href="#5-1-基本用法" class="headerlink" title="5.1 基本用法"></a>5.1 基本用法</h4><p>Vue.js 提供了 <code>v-model</code> 指令，用于在表单类元素上双向绑定数据  </p><p>使用 <code>v-model</code> 后，表单控件显示的值只依赖所绑定的数据，不在关心初始化时的 value 属性，对于 <code>&lt;textarea&gt;&lt;/textarea&gt;</code> 之间插入的值，也不会生效。<br>对于中文输入法输入中文，一般在拼音阶段，Vue 是不会更新数据的，当敲下汉字时才会触发更新。如果希望实时更新，可以用 <code>@input</code> 替代 <code>v-model</code>。  </p><p>输入框： 输入的内容会实时映射到绑定的数据上  </p><ul><li><p><strong>单选按钮</strong><br>在单独使用时，不需要 <code>v-model</code>，直接使用 <code>v-bind</code> 绑定一个布尔类型的值，为真时选中，为否不选。<br>如果是组合使用来实现互斥选中的效果，就需要 <code>v-model</code> 配合 <code>value</code> 来使用。  </p></li><li><p><strong>复选框</strong><br>单独使用时，用 <code>v-model</code> 来绑定一个布尔值<br>组合使用时，<code>v-model</code> 与 <code>value</code> 一起，多个勾选框都绑定到同一个数组类型的数据，value 的值在数组当中，就会选中这一项，双项。  </p></li><li><p><strong>下拉选择列表</strong><br>单选： <code>&lt;option&gt;</code> 是备选项，如果含有 <code>value</code> 属性，<code>v-model</code> 就会优先匹配 <code>value</code> 的值；如果没有，就会直接匹配 <code>&lt;option&gt;</code> 的 <code>text</code><br>多选： <code>&lt;select&gt;</code> 添加 <code>multiple</code> 就可以多选了，此时 <code>v-model</code> 绑定的是一个数组，与复选框用法类似。</p></li></ul><h4 id="5-2-绑定值"><a href="#5-2-绑定值" class="headerlink" title="5.2 绑定值"></a>5.2 绑定值</h4><p>5.1 中的 <code>v-model</code> 绑定的值是一个静态字符串或布尔值，动态的数据，用 <code>v-bind</code> 实现  </p><ul><li><p><strong>单选框</strong><br><code>&lt;input type = &quot;radio&quot; v-model = &quot;picked&quot; :value = &quot;value&quot; /&gt;</code>  </p></li><li><p><strong>复选框</strong><br><code>&lt;input type = &quot;checkbox&quot; v-model = &quot;toggle&quot; :true-value = &quot;value1&quot; :false-value = &quot;value2&quot; /&gt;</code>  </p></li><li><p><strong>选择列表</strong><br><code>&lt;select v-model = &quot;selected&quot;&gt;&lt;option :value = &quot;&#123; number: 123&#125;&quot;&gt; 123&lt;/option&gt;&lt;/select&gt;</code></p></li></ul><h4 id="5-3-修饰符"><a href="#5-3-修饰符" class="headerlink" title="5.3 修饰符"></a>5.3 修饰符</h4><ul><li><p><strong>.lazy</strong><br><code>v-modea</code> 默认是在 input 事件中同步输入框的数据，使用 <code>.lazy</code> 修饰符会转变为在 change 事件中同步  </p></li><li><p><strong>.number</strong><br>可以将输入转换为 Number 类型  </p></li><li><p><strong>.trim</strong><br>可以自动过滤输入的首尾空格</p></li></ul><hr><h3 id="6-组件"><a href="#6-组件" class="headerlink" title="6. 组件"></a>6. 组件</h3><p>组件(Componet)是 Vue.js 最核心的功能。<br>提供重用性，让代码可复用  </p><p>需要注册后才可以使用，分为全局注册和局部注册，全局注册后，任何 Vue 实例都可以使用。  </p><p><strong>全局注册实例：</strong>  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Vue.componet(<span class="hljs-string">&#x27;my-componet&#x27;</span>,&#123;<br> <span class="hljs-regexp">//</span> 选项<br>&#125;)<br></code></pre></td></tr></table></figure><p><code>my-componet</code> 注册的组件自定义标签名称，可使用 kebab-case (短横线分隔命名) 和 PascalCase (首字母大写命名) 定义一个组件；但直接在 DOM(非字符串的模板)中使用时只有 kebab-case 有效，推荐该种写法。  </p><p>父实例中使用这个组件，__组件必须要在实例创建前注册__，之后就可以以 <code>&lt;my-componet&gt;&lt;/my-componet&gt;</code> 形式来使用组件<br>在组件选项中添加 <code>template</code> 就可以显示组件内，<code>template</code> 的 DOM 结构必须被一个元素包含  </p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">my-componet</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-componet</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">componet</span>(<span class="hljs-string">&#x27;my-componet&#x27;</span>,</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    template: &quot;&lt;div&gt;这是组件的内容&lt;/div&gt;&quot;</span><br><span class="hljs-template-variable">  &#125;</span><span class="language-xml"><span class="language-javascript">)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">    ...</span><br><span class="hljs-template-variable">  &#125;</span><span class="language-xml">)</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br></code></pre></td></tr></table></figure><p><strong>局部注册：</strong>  </p><p>可以通过一个普通的 JavaScript 对象来定义组件：<br><code>var ComponetA = &#123;&#125;</code><br>然后在 <code>componets</code> 选项中定义需要使用的组件：  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">new Vue(&#123;<br>    el: <span class="hljs-string">&quot;#app&quot;</span>,<br>    componets:&#123;<br>        &quot;componet-<span class="hljs-selector-tag">a</span>&quot;: ComponetA,<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>局部注册的组件在其子组件中不可用。例如，如果你希望 ComponentA 在 ComponentB 中可用，则你需要这样写：  </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> ComponentA = &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">var</span> ComponentB = &#123;<br>  components: &#123;<br>      <span class="hljs-string">&#x27;component-a&#x27;</span>: ComponentA<br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br> &#125;<br></code></pre></td></tr></table></figure><p>或者如果你通过 Babel 和 webpack 使用 ES2015 模块，那么代码看起来更像：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentA.vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>      <span class="hljs-title class_">ComponentA</span><br>  &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意在 ES2015+ 中，在对象中放一个类似 ComponentA 的变量名其实是 ComponentA: ComponentA 的缩写，即这个变量名同时是：  </p><ul><li>用在模板中的自定义元素的名称  </li><li>包含了这个组件选项的变量名</li></ul></blockquote><p>Vue 组件的模板在某些情况下会受到 HTML 限制，比如 <code>&lt;table&gt;</code> 内规定只允许是 <code>&lt;tr&gt;、&lt;td&gt;、&lt;th&gt;</code> 等这些表格元素，所以在 <code>&lt;table&gt;</code> 内直接使用组件是无效的。可以使用特殊字符 <code>is</code> 属性俩挂载组件，会被替换为组件内容。常见的限制元素还有 <code>&lt;ul&gt;</code>、<code>&lt;ol&gt;</code> 、<code>&lt;select&gt;</code>，字符串模板是不受限制的。<code>&lt;tbody is=&quot;my-componet&quot;&gt;&lt;/tbody&gt;</code>  </p><p>除了 <code>template</code> 选项外，还可以使用其他的选项，如 <code>data</code>、<code>computed</code>、<code>methods</code> 等，但 <code>data</code> 必须是一个函数，然后将数据 return 出去，因此每个实例可以维护一份被返回对象的独立的拷贝。  </p><h4 id="6-2-使用-props-传递数据"><a href="#6-2-使用-props-传递数据" class="headerlink" title="6.2 使用 props 传递数据"></a>6.2 使用 props 传递数据</h4><h5 id="6-2-1-基本用法"><a href="#6-2-1-基本用法" class="headerlink" title="6.2.1 基本用法"></a>6.2.1 基本用法</h5><p>父组件向子组件传递数据或参数<br>如果直接传递数字，布尔值，数组，对象，而不使用 v-bind，传递的仅是字符串<br>可见 vue_test\props传值.html  </p><h5 id="6-2-2-单向数据流"><a href="#6-2-2-单向数据流" class="headerlink" title="6.2.2 单向数据流"></a>6.2.2 单向数据流</h5><p>父组件数据变化时会传递给子组件，反之不行。  </p><ul><li><p>这个 prop 用来传递一个初始值；这个子组件接下来希望将其作为一个本地的 prop 数据来使用：  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Vue.component(<span class="hljs-string">&quot;my-component&quot;</span>, &#123;<br>    props: [<span class="hljs-string">&#x27;initCount&#x27;</span>],<br>    template: <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;&#x27;</span>,<br>    <span class="hljs-keyword">data</span>: function()&#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            count: <span class="hljs-keyword">this</span>.initCount<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>这个 prop 以一种原始的值传入且需要进行转换。最好使用 prop 的值来定义一个计算属性：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">props: <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;size&#x27;</span>]</span>,<br>computed: &#123;<br>    normalizedSize: <span class="hljs-built_in">function</span>()&#123;<br>        return this<span class="hljs-selector-class">.size</span><span class="hljs-selector-class">.trim</span>()<span class="hljs-selector-class">.toLowerCase</span>()<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><blockquote><p>在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。</p></blockquote><h5 id="6-2-3-数据验证"><a href="#6-2-3-数据验证" class="headerlink" title="6.2.3 数据验证"></a>6.2.3 数据验证</h5><p>当 prop 需要验证时，<code>props</code> 选项的值都是一个数组。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;my-component&#x27;</span>, &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span><br>    <span class="hljs-attr">propA</span>: <span class="hljs-title class_">Number</span>,<br>    <span class="hljs-comment">// 多个可能的类型</span><br>    <span class="hljs-attr">propB</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>],<br>    <span class="hljs-comment">// 必填的字符串</span><br>    <span class="hljs-attr">propC</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,<br>      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>    &#125;,<br>    <span class="hljs-comment">// 带有默认值的数字</span><br>    <span class="hljs-attr">propD</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>      <span class="hljs-attr">default</span>: <span class="hljs-number">100</span><br>    &#125;,<br>    <span class="hljs-comment">// 带有默认值的对象</span><br>    <span class="hljs-attr">propE</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span>,<br>      <span class="hljs-comment">// 对象或数组默认值必须从一个工厂函数获取</span><br>      <span class="hljs-attr">default</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 自定义验证函数</span><br>    <span class="hljs-attr">propF</span>: &#123;<br>      <span class="hljs-attr">validator</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) &#123;<br>        <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span><br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;success&#x27;</span>, <span class="hljs-string">&#x27;warning&#x27;</span>, <span class="hljs-string">&#x27;danger&#x27;</span>].<span class="hljs-title function_">indexOf</span>(value) !== -<span class="hljs-number">1</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>验证的类型(<code>type</code>)： String\Number\Boolean\Array\Object\Date\Function\Symbol<br>而且 <code>type</code> 还可以是一个自定义的构造函数，并且通过 <code>instanceof</code> 来进行检查确认</p><p>当 <code>prop</code> 验证失败的时候，Vue（开发版本） 将会产生一个控制台的警告  </p><blockquote><p>prop 会在一个组件实例创建之前进行验证，所以实例的属性 (如 data、computed 等) 在 default 或 validator 函数中是不可用的。</p></blockquote><h4 id="6-3-组件通信"><a href="#6-3-组件通信" class="headerlink" title="6.3 组件通信"></a>6.3 组件通信</h4><h5 id="6-3-1-自定义事件"><a href="#6-3-1-自定义事件" class="headerlink" title="6.3.1 自定义事件"></a>6.3.1 自定义事件</h5>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>前端</category>
      
      <category>VUE</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>VUE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编写高质量代码</title>
    <link href="/2023/12/31/%E4%B9%A6/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/"/>
    <url>/2023/12/31/%E4%B9%A6/%E7%BC%96%E5%86%99%E9%AB%98%E8%B4%A8%E9%87%8F%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-Java开发中通用的方法和准则"><a href="#第一章-Java开发中通用的方法和准则" class="headerlink" title="第一章 Java开发中通用的方法和准则"></a>第一章 Java开发中通用的方法和准则</h1><h2 id="1-不要在常量和变量中出现易混淆的字母"><a href="#1-不要在常量和变量中出现易混淆的字母" class="headerlink" title="1. 不要在常量和变量中出现易混淆的字母"></a>1. 不要在常量和变量中出现易混淆的字母</h2><pre><code class="hljs">字母&quot;l&quot;作为长整型时务必大写</code></pre><h2 id="2-莫让常量蜕变成变量"><a href="#2-莫让常量蜕变成变量" class="headerlink" title="2. 莫让常量蜕变成变量"></a>2. 莫让常量蜕变成变量</h2><h2 id="3-三元操作符的类型务必一致"><a href="#3-三元操作符的类型务必一致" class="headerlink" title="3. 三元操作符的类型务必一致"></a>3. 三元操作符的类型务必一致</h2><h2 id="4-避免带有变长参数的方法重载"><a href="#4-避免带有变长参数的方法重载" class="headerlink" title="4. 避免带有变长参数的方法重载"></a>4. 避免带有变长参数的方法重载</h2><h2 id="5-别让null值和空值威胁到变长方法"><a href="#5-别让null值和空值威胁到变长方法" class="headerlink" title="5. 别让null值和空值威胁到变长方法"></a>5. 别让null值和空值威胁到变长方法</h2><h2 id="6-覆写变长方法也循规蹈矩"><a href="#6-覆写变长方法也循规蹈矩" class="headerlink" title="6. 覆写变长方法也循规蹈矩"></a>6. 覆写变长方法也循规蹈矩</h2><pre><code class="hljs">覆写的方法参数与父类相同，不仅仅是类型、数量，还包括显示形式</code></pre><h2 id="7-警惕自增的陷阱"><a href="#7-警惕自增的陷阱" class="headerlink" title="7. 警惕自增的陷阱"></a>7. 警惕自增的陷阱</h2><h2 id="8-不要让旧语法困扰你"><a href="#8-不要让旧语法困扰你" class="headerlink" title="8. 不要让旧语法困扰你"></a>8. 不要让旧语法困扰你</h2><h2 id="9-少用静态导入"><a href="#9-少用静态导入" class="headerlink" title="9. 少用静态导入"></a>9. 少用静态导入</h2><h2 id="10-不要在本类中覆盖静态导入的变量和方法"><a href="#10-不要在本类中覆盖静态导入的变量和方法" class="headerlink" title="10. 不要在本类中覆盖静态导入的变量和方法"></a>10. 不要在本类中覆盖静态导入的变量和方法</h2><h2 id="11-养成良好习惯，显示声明UID"><a href="#11-养成良好习惯，显示声明UID" class="headerlink" title="11. 养成良好习惯，显示声明UID"></a>11. 养成良好习惯，显示声明UID</h2><pre><code class="hljs">显示声明serialVersionUID可以避免对象不一致，但尽量不要以这种方式向JVM“撒谎”</code></pre><h2 id="12-避免用序列化类在构造函数中为不变量赋值"><a href="#12-避免用序列化类在构造函数中为不变量赋值" class="headerlink" title="12. 避免用序列化类在构造函数中为不变量赋值"></a>12. 避免用序列化类在构造函数中为不变量赋值</h2><pre><code class="hljs">在序列化类中，不使用构造函数为final变量赋值</code></pre><h2 id="13-避免为final变量复杂赋值"><a href="#13-避免为final变量复杂赋值" class="headerlink" title="13. 避免为final变量复杂赋值"></a>13. 避免为final变量复杂赋值</h2><pre><code class="hljs">final变量在以下情况下不会被重新赋值    通过构造函数为final变量赋值    通过方法返回值为final变量赋值    final修饰的属性不是基本类型</code></pre><h2 id="14-使用序列化类的私有方法巧妙解决部分属性持久化问题"><a href="#14-使用序列化类的私有方法巧妙解决部分属性持久化问题" class="headerlink" title="14. 使用序列化类的私有方法巧妙解决部分属性持久化问题"></a>14. 使用序列化类的私有方法巧妙解决部分属性持久化问题</h2><h2 id="15-break万万不可忘"><a href="#15-break万万不可忘" class="headerlink" title="15. break万万不可忘"></a>15. break万万不可忘</h2><h2 id="16-易变业务使用脚本语言编写"><a href="#16-易变业务使用脚本语言编写" class="headerlink" title="16. 易变业务使用脚本语言编写"></a>16. 易变业务使用脚本语言编写</h2><h2 id="17-慎用动态编译"><a href="#17-慎用动态编译" class="headerlink" title="17. 慎用动态编译"></a>17. 慎用动态编译</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="-4"><a href="#-4" class="headerlink" title=""></a></h2>]]></content>
    
    
    <categories>
      
      <category>代码优化</category>
      
    </categories>
    
    
    <tags>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud</title>
    <link href="/2023/12/31/springcloud/SpringCloud/"/>
    <url>/2023/12/31/springcloud/SpringCloud/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-基础知识"><a href="#第一章-基础知识" class="headerlink" title="第一章 基础知识"></a>第一章 基础知识</h2><ul><li>Spring Cloud Config:<br>配置管理工具，支持使用Git存储配置内容，可以使用它实现应用配置的外部化存储，并支持客户端配置信息刷新、加密&#x2F;解密配置内容等  </li><li>Spring Cloud Netflix: 核心组件，对多个Netflix OSS开源套件进行整合  </li><li>Eureka: 服务治理组件，包含服务注册中心、服务注册与发现机制的实现  </li><li>Hystrix: 容错管理组件，实现断路器模式，帮助服务依赖中出现的延迟和为故障提供强大的容错能力  </li><li>Ribbon: 客户端负载均衡的服务调用组件  </li><li>Feign: 基于Ribbon和Hystrix的声明式服务调用组件  </li><li>Zuul: 网关组件，提供智能路由、访问过滤等功能  </li><li>Archaius: 外部化配置组件  </li><li>Spring Cloud Bus: 事件、消息总线，用于传播集群中的状态变化或事件，以触发后续的处理，比如用来动态刷新配置等  </li><li>Spring Cloud Cluster: 针对Zookeeper、Redis、Hazelcast、Consul的选举算法和通用状态模式的实现  </li><li>Spring Cloud Cloudfoundry: 与Pivotal Cloudfoundry的整合支持  </li><li>Spring Cloud Stream: 通过Redis、Rabbit或者Kafka实现的消费微服务，可以通过简单的声明式模型来发送和接收消息  </li><li>Spring Cloud AWS: 用于简化整合Amazon Web Service的组件  </li><li>Spring Cloud Security: 安全工具包，提供在Zuul代理中对OAuth2客户端请求中的中继器  </li><li>Spring Cloud Sleuth: Spring Cloud 应用的分布式跟踪实现，可以完美整合Zipkin  </li><li>Spring Cloud ZooKeeper: 基于ZooKeeper的服务发现与配置管理组件  </li><li>Spring Cloud Starters: Spring Cloud 的基础组件，它是基于Spring Boot风格项目的基础依赖模块  </li><li>Spring Cloud CLI: 用于在Groovy中快速创建Spring Cloud应用的Spring Boot CLI插件</li></ul><hr><h2 id="第三章-服务治理-Spring-Cloud-Eureka"><a href="#第三章-服务治理-Spring-Cloud-Eureka" class="headerlink" title="第三章 服务治理: Spring Cloud Eureka"></a>第三章 服务治理: Spring Cloud Eureka</h2><h3 id="服务治理"><a href="#服务治理" class="headerlink" title="服务治理"></a>服务治理</h3><p>服务治理是微服务架构中最为核心和基础的模块，主要用来实现各个微服务实例的自动化注册与发现  </p><ul><li>服务注册<br>  注册中心<br>  每个服务单元向注册中心登记自己提供的服务，将主机与端口号、版本号、通信协议等一些附加信息告知注册中心，注册中心按服务名分类组织服务清单</li><li>服务发现<br>  通过向服务名发起请求调用实现，服务调用方在调用服务提供方接口时，并不知道具体的服务实例位置，调用方需要向服务注册中心咨询服务，并获取所有服务是实例清单<br>  调用方从清单中以某种轮询策略取出一个位置来进行服务调用（即客户端负载均衡）</li></ul><h3 id="Netflix-Eureka"><a href="#Netflix-Eureka" class="headerlink" title="Netflix Eureka"></a>Netflix Eureka</h3><p>Spring Cloud Eureka，使用Netflix Eureka来实现服务注册与发现，既包含了服务端组件，也包含了客户端组件，并且服务端与客户端均采用Java编写  </p><ul><li>Eureka 服务端<br>  也称为服务注册中心，支持高可用配置<br>  依托于强一致性提供良好的服务实例可用性，可以应对多种不同的故障场景</li><li>Eureka 客户端<br>  主要处理服务的注册与发现，<br>  通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，<br>  向注册中心注册自身提供的服务并周期性地发送心跳来更新它的服务租约，<br>  能从服务端查询当前注册的服务信息并把它们缓存到本地并周期性地刷新服务状态</li></ul><h3 id="搭建服务注册中心-注册服务提供者"><a href="#搭建服务注册中心-注册服务提供者" class="headerlink" title="搭建服务注册中心 注册服务提供者"></a>搭建服务注册中心 注册服务提供者</h3><pre><code class="hljs">server:  port: 8761 eureka:  instance:    hostname: localhost  client:    register-with-eureka: false    fetch-registry: false    service-url:      defaultZone:        http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</code></pre><p>register-with-eureka: 设置为false，代表不向注册中心注册自己<br>fetch-registry: 设置为false，代表不需要去检索服务<br>应用启动后不需要从服务治理服务器中同步已注册的服务注册列表数据到本地<br>service-url.defaultZone: 服务注册中心的地址  </p><h3 id="高可用注册中心"><a href="#高可用注册中心" class="headerlink" title="高可用注册中心"></a>高可用注册中心</h3><p>Eureka 的服务治理设计中，所有节点即是服务提供方，也是服务消费方，服务中心也不例外<br>Eureka Server 的高可用实际上就是将自己作为服务向其他服务注册中心注册自己，即形成一组互相注册的服务注册中心，以实现服务清单的互相同步，达到高可用的效果</p><pre><code class="hljs">eureka.client.register-with-eureka=trueeureka.client.fetch-registry=trueeureka.instance.prefer-ip-address=true #不使用主机名来定义注册中心的地址，而使用IP地址的形式，    </code></pre><p>如果设置了eureka.instance.ip-address 属性，则使用该属性配置的IP，否则自动获取除环路IP外的第一个IP地址</p><h3 id="服务发现与消费"><a href="#服务发现与消费" class="headerlink" title="服务发现与消费"></a>服务发现与消费</h3><p>服务消费者，主要完成两个目标: 发现服务、消费服务<br>服务发现的任务由Eureka的客户端完成<br>服务消费的任务由Ribbon完成  </p><ul><li>Ribbon<ul><li>一个基于 HTTP 和 TCP 的客户端负载均衡器<br>  通过客户端中配置的 RibbonServerList 服务端列表去轮询访问以达到均衡负载的作用</li><li>与 Eureka 联合使用时，Ribbon 的服务实例清单 RibbonServerList 会被 DiscoveryEnabledBUWSServerList 重写，扩展成从 Eureka 注册中心中获取服务端列表<br>  也会用 NIWSDiscoveryPing 来取代 IPing ，将职责委托给 Eureka 来确定服务端是否已经启动</li></ul></li></ul><h3 id="Eureka-详解"><a href="#Eureka-详解" class="headerlink" title="Eureka 详解"></a>Eureka 详解</h3><h4 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h4><ul><li>服务注册中心</li><li>服务提供者</li><li>服务消费者</li></ul><h4 id="服务治理机制"><a href="#服务治理机制" class="headerlink" title="服务治理机制"></a>服务治理机制</h4><h5 id="服务提供者"><a href="#服务提供者" class="headerlink" title="服务提供者"></a>服务提供者</h5><ul><li>服务注册<br>  Eureka Server接收到 REST 请求之后，将元素据信息存储在一个双层Map中，第一层的 key 是服务名，第二层的 key 是具体服务的实例名</li><li>服务同步<br>  通过服务同步，两个服务提供者的服务信息就可以通过这两台服务注册中心中的任意一台获取</li><li>服务续约<br>  在注册完服务之后，服务提供者会维护一个心跳用来持续告诉 Eureka Server: “我还活着”，以防止 Eureka Server 的“剔除任务”将该服务实例从服务列表中排除出去，称之为服务续约  <figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">eureka</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">instance</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">lease-renewal-interval-in-seconds</span><span class="hljs-punctuation">:</span> <span class="hljs-string">30</span><br>    <span class="hljs-attribute">lease-expiration-duration-in-seconds</span><span class="hljs-punctuation">:</span> <span class="hljs-string">90 </span><br></code></pre></td></tr></table></figure>  lease-renewal-interval-in-seconds 参数用于定义服务续约任务的调用间隔时间，默认30秒<br>  lease-expiration-duration-in-seconds 参数用于定义服务失效时间，默认为90秒</li></ul><h5 id="服务消费者"><a href="#服务消费者" class="headerlink" title="服务消费者"></a>服务消费者</h5><ul><li>获取服务  <ul><li>启动服务消费者时，会发送一个REST请求给服务注册中心，来获取注册的服务清单  </li><li>Eureka Server 会维护一份只读的服务清单来返回给客户端，同时该缓存清单会每隔30秒更新一次  </li><li>获取服务是服务消费者的基础，必须确保 eureka.client.register-with-eureka&#x3D;true。  </li><li>若希望修改缓存清单的更新时间，可以通过 eureka.client.register-fetch-interval-seconds&#x3D;30 参数进行修改，单位为秒，默认值为 30</li></ul></li><li>服务调用  <ul><li>服务消费者在获取服务清单后，通过服务名可以获得具体提供服务的实例名和该实例的元数据信息  <ul><li>Ribbon中会默认采用轮询的方式进行调用，从而实现客户端的负载均衡</li></ul></li></ul></li><li>服务下线<br>  在客户端程序中，当服务实例进行正常的关闭操作时，会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。<br>  服务端在接收到请求之后，将该服务状态设置为下线(DOWN)，并把该下线事件传播出去</li></ul><h5 id="服务注册中心"><a href="#服务注册中心" class="headerlink" title="服务注册中心"></a>服务注册中心</h5><ul><li>失效剔除<br>  服务实例不正常下线（可能由于内存溢出、网络故障等原因使得服务不能正常工作），而服务注册中心并未收到“服务下线”的请求<br>  Eureka Server 在启动时会创建一个定时任务，默认每隔一段时间（默认为60秒）将当前清单中超时（默认为90秒)没有续约的服务剔除  </li><li>自我保护  <figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">EMERGENCY! EUREKA MAY <span class="hljs-keyword">BE </span>INCORRECTLY CLAIMING <span class="hljs-keyword">INSTANCES </span>ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD <span class="hljs-keyword">AND </span>HENCE THE <span class="hljs-keyword">INSTANCES </span>ARE NOT <span class="hljs-keyword">BEING </span>EXPIRED <span class="hljs-keyword">JUST </span>TO <span class="hljs-keyword">BE </span>SAFE. <br></code></pre></td></tr></table></figure>该警告就是触发了Eureka Server 的自我保护机制<br>Eureka Server 在运行期间，会统计心跳失败的比例在15分钟之内是否低于85%，如果出现低于 的情况，Eureka Server 会将当前的实例注册信息保护起来，让这些实例不会过期，尽可能保护这些注册信息<br>在这段保护期间内实例若出现问题，客户端很容易拿到不存在的服务实例，会出现调用失败的情况。所有客户端必须有容错机制<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">eureka.server.enable-self-preservation</span>=<span class="hljs-literal">false</span><br><span class="hljs-comment"># 参数，关闭保护机制，确保注册中心可以将不可用的实例正确剔除</span><br></code></pre></td></tr></table></figure></li></ul><hr><h3 id="第四章-熔断器"><a href="#第四章-熔断器" class="headerlink" title="第四章 熔断器"></a>第四章 熔断器</h3><p>多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。是一种因服务提供者的不可用导致服务消费者的不可用，并将不可用逐渐放大的过程。  </p><h4 id="熔断器"><a href="#熔断器" class="headerlink" title="熔断器"></a>熔断器</h4><p>可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，从而防止应用程序不断地尝试执行可能会失败的操作，使得应用程序继续执行而不用等待修正错误，或者浪费CPU时间去等到长时间的超时产生。<br>也可以是应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作  </p><p>是保护服务高可用的最后一道防线  </p><h4 id="Hystrix"><a href="#Hystrix" class="headerlink" title="Hystrix"></a>Hystrix</h4><ul><li><p><strong>断路器</strong>  </p><p>  当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务.  </p><p>  断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN).</p><p>  这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN).  </p><p>  Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</p></li><li><p><strong>Fallback</strong> </p><p>  相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. </p><p>  fallback方法的返回值一般是设置的默认值或者来自缓存.  </p></li><li><p><strong>资源隔离</strong></p><p>  在Hystrix中, 主要通过线程池来实现资源隔离.  </p><p>  通常在使用的时候我们会根据调用的远程服务划分出多个线程池.<br>  例如调用产品服务的Command放入A线程池, 调用账户服务的Command放入B线程池. </p><p>  这样做的主要优点是运行环境被隔离开了.  </p><p>  这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响.  </p><p>  但是带来的代价就是维护多个线程池会对系统带来额外的性能开销.<br>  如果是对性能有严格要求而且确信自己调用服务的客户端代码不会出问题的话, 可以使用Hystrix的信号模式(Semaphores)来隔离资源.</p></li><li><p><strong>仪表盘参数详解</strong>  </p><ul><li>实心圆: 颜色从绿黄橙红依次递减，表示服务的健康程度依次降低，圆越大，表示服务的流量越大  </li><li>线条： 用来记录2分钟内流量的相对变化</li><li>左侧  <ul><li>第一个数值（墨绿色）表示请求成功数  </li><li>第二个数值（蓝色）表示短路 &#x2F; 熔断数</li></ul></li><li>右侧  <ul><li>第一个数值（黄色）表示超时数</li><li>第二个数值（紫色）表示线程池拒绝数</li><li>第三个数值（橙色）表示失败 &#x2F; 异常数</li></ul></li><li>右侧百分比： 表示最近 10s 的错误比例</li><li>Median: 集群下的主机报告</li><li>Host: 请求频率</li><li>Circuit: 断路器状态</li></ul></li><li><p><strong>Hystrix-dashboard</strong>  </p><p>  是一款针对Hystrix进行实时监控的工具，<br>  通过Hystrix Dashboard我们可以在直观地看到各Hystrix Command的请求响应时间, 请求成功率等数据。<br>  但是只使用Hystrix Dashboard的话, 你只能看到单个应用内的服务信息.<br>  Turbine汇总系统内多个服务的数据并显示到Hystrix Dashboard上.  </p><ul><li><p><strong>1. Hystrix-dashboard</strong>  </p><ul><li><p>添加依赖  </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>  三个包缺一不可  </p><ul><li>启动类注解  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 包含@SpringBootApplication以及@EnableDiscoveryClient、@EnableCircuitBreaker  </span><br><span class="hljs-variable">@SpringCloudApplication</span>  <br><span class="hljs-variable">@EnableHystrix</span>           <span class="hljs-comment">// 允许熔断</span><br><span class="hljs-variable">@EnableHystrixDashboard</span> <span class="hljs-comment">// 单体熔断</span><br></code></pre></td></tr></table></figure></li><li>无法访问hystrix.stream (或hystrix dashboard 出现 Unable to connect to Command Metric Stream)  <ul><li><p>方法一：  </p>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Bean<br>public ServletRegistrationBean get<span class="hljs-constructor">Servlet()</span> &#123;<br>    HystrixMetricsStreamServlet streamServlet = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HystrixMetricsStreamServlet()</span>;<br>    ServletRegistrationBean registrationBean = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ServletRegistrationBean(<span class="hljs-params">streamServlet</span>)</span>;<br>    registrationBean.set<span class="hljs-constructor">LoadOnStartup(1)</span>;<br>    registrationBean.add<span class="hljs-constructor">UrlMappings(<span class="hljs-string">&quot;/hystrix.stream&quot;</span>)</span>;<br>    registrationBean.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;HystrixMetricsStreamServlet&quot;</span>)</span>;<br>    return registrationBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>  由于 HystrixStreamEndpoint 下 get 中的 HystrixMetricsStreamServlet 类中的注解。  </p></li><li><p>方法二：<br>  application.yml 中添加</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">management:</span><br><span class="hljs-symbol">  endpoints:</span><br><span class="hljs-symbol">    web:</span><br><span class="hljs-symbol">      exposure:</span><br>        include[<span class="hljs-number">0</span>]: <span class="hljs-string">&quot;hystrix.stream&quot;</span><br>        include[<span class="hljs-number">1</span>]: <span class="hljs-string">&quot;health&quot;</span><br>        include[<span class="hljs-number">2</span>]: <span class="hljs-string">&quot;info&quot;</span><br></code></pre></td></tr></table></figure><p>  单体监控访问地址变成 <a href="http://hystrix-app:port/actuator/hystrix.stream">http://hystrix-app:port/actuator/hystrix.stream</a><br>  如果不配置 info, health，则无法打开 actuator&#x2F;health以及actuator&#x2F;info</p></li></ul></li></ul></li><li><p><strong>2. Turbine</strong><br> Netflix提供了一个开源项目（Turbine）来提供把多个hystrix.stream的内容聚合为一个数据源供Dashboard展示</p><ul><li><p>添加依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-turbine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix-dashboard<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件  </p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">turbine:</span><br>  <span class="hljs-attr">app-config:</span> <span class="hljs-string">demo-ribbon,</span> <span class="hljs-string">demo-ribbon-2</span>  <span class="hljs-comment"># 参数指定了需要收集监控信息的服务名</span><br><span class="hljs-comment">#  cluster-name-expression: &quot;&#x27;default&#x27;&quot; </span><br>  <span class="hljs-attr">combine-host-port:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">cluster-name-expression:</span> <span class="hljs-string">metadata[&#x27;cluster&#x27;]</span> <span class="hljs-comment"># 参数指定了集群名称为</span><br>  <span class="hljs-attr">aggregator:</span><br>    <span class="hljs-attr">cluster-config:</span> <span class="hljs-string">ribbon</span><br>  <span class="hljs-attr">instanceUrlSuffix:</span> <span class="hljs-string">/hystrix.stream</span><br></code></pre></td></tr></table></figure><p>  <strong>turbine.appConfig</strong>: 配置 Eureka 中的 serviceId 列表，表明监控哪些服务<br>  <strong>turbine.aggregator.clusterConfig</strong>: 指定聚合哪些集群，多个使用”,”分割，默认为 default。可使用 http:&#x2F;&#x2F;…&#x2F;turbine.stream?cluster&#x3D;{clusterConfig之一} 访问<br>  <strong>turbine.clusterNameExpression</strong>:<br>  1. clusterNameExpression 指定集群名称，默认表达式 appName；此时： turbine.aggregator.clusterConfig 需要配置想要监控的应用名称；<br>  2. 当 clusterNameExpression: default 时，turbine.aggregator.clusterConfig可以不写，因为默认就是default；<br>  3. 当 clusterNameExpression: metadata[‘cluster’]时，假设想要监控的应用配置了 eureka.instance.metadata-map.cluster: ABC，则需要配置，同时 turbine.aggregator.clusterConfig: ABC  </p></li><li><p>启动类注解<br>  @EnableTurbine<br>  @EnableHystrixDashboard  </p></li><li><p>demo-ribbon 和 demo-ribbon-2 的配置文件</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">eureka:</span><br><span class="hljs-symbol">    client:</span><br><span class="hljs-symbol">        serviceUrl:</span><br><span class="hljs-symbol">          defaultZone:</span> http:<span class="hljs-comment">//localhost:8761/eureka/</span><br><span class="hljs-symbol">    instance:</span><br>        metadata-map:<br><span class="hljs-symbol">         cluster:</span> ribbon<br><span class="hljs-symbol">         </span><br><span class="hljs-symbol">    server:</span><br><span class="hljs-symbol">        port:</span> <span class="hljs-number">8765</span><br><span class="hljs-symbol">    spring:</span><br><span class="hljs-symbol">        application:</span><br><span class="hljs-symbol">            name:</span> demo-ribbon<br><span class="hljs-symbol">    management:</span><br><span class="hljs-symbol">      endpoints:</span><br><span class="hljs-symbol">        web:</span><br><span class="hljs-symbol">          exposure:</span><br>            include[<span class="hljs-number">0</span>]: <span class="hljs-string">&quot;hystrix.stream&quot;</span><br>            include[<span class="hljs-number">1</span>]: <span class="hljs-string">&quot;health&quot;</span><br>            include[<span class="hljs-number">2</span>]: <span class="hljs-string">&quot;info&quot;</span><br></code></pre></td></tr></table></figure><p>  _注意_： 如果加了 management.endpoints.web, 则 turbine 的配置文件中相匹配的集群的 instanceUrlSuffix 为 &#x2F;actuator&#x2F;health  </p><p>  多集群配置：  </p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">turbine:</span><br>    <span class="hljs-attr">app-config:</span> <span class="hljs-string">demo-ribbon,</span> <span class="hljs-string">demo-ribbon-2,</span> <span class="hljs-string">demo-client-feign</span> <span class="hljs-comment"># 参数指定了需要收集监控信息的服务名</span><br><span class="hljs-comment">#  cluster-name-expression: &quot;&#x27;default&#x27;&quot; </span><br>    <span class="hljs-attr">combine-host-port:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">cluster-name-expression:</span> <span class="hljs-string">metadata[&#x27;cluster&#x27;]</span> <span class="hljs-comment"># 参数指定了集群名称为</span><br>    <span class="hljs-attr">aggregator:</span><br>        <span class="hljs-attr">cluster-config:</span> <span class="hljs-string">ribbon,</span> <span class="hljs-string">feign</span><br>    <span class="hljs-attr">instanceUrlSuffix:</span> <br>        <span class="hljs-attr">ribbon:</span> <span class="hljs-string">actuator/hystrix.stream</span><br>        <span class="hljs-attr">feign:</span> <span class="hljs-string">actuator/hystrix.stream</span><br></code></pre></td></tr></table></figure></li><li><p>访问地址<br>  &#x2F;hystrix<br>  <a href="http://turbine-hostname:port/turbine.stream?cluster=ribbon">http://turbine-hostname:port/turbine.stream?cluster=ribbon</a></p></li><li><p>需注意的是，turbine 监控的 hystrix 可以缺少 spring-cloud-starter-netflix-hystrix-dashboard</p></li></ul></li></ul></li></ul><hr><h2 id="第五章-网关"><a href="#第五章-网关" class="headerlink" title="第五章 网关"></a>第五章 网关</h2><p>智能路由网关组件Zuul，用于构建边界服务(Edge Service)，致力于动态路由、过滤、监控、弹性伸缩和安全  </p><p>作用:  </p><ul><li>Zuul、Ribbon 以及 Eureka 相结合，可以实现智能路由和负载均衡的功能，Zuul 能够将请求流量按某种策略分发到集群状态的多个服务实例  </li><li>网关将所有服务的 API 接口统一聚合，并统一对外暴露。  </li><li>网关服务可以做用户身份认证和权限认证，防止非法请求操作 API 接口，对服务器起到保护作用  </li><li>网关可以实现监控功能，实时日志输出，对请求进行记录  </li><li>网关可以用来实现流量监控，高流量的情况下，对服务进行降级  </li><li>API 接口从内部服务分离出来，方便做测试</li></ul><p>过滤器:  </p><ul><li>PRE 过滤器: 它是在请求路由到具体的服务之前执行的，这种类型的过滤器可以做安全验证，如身份验证、参数验证。  </li><li>ROUTING 过滤器: 它用于将请求路由到具体的微服务实例。在默认情况下，它使用Http Client 进行网络请求。  </li><li>POST 过滤器: 他是在请求已被路由到微服务后执行的。一般情况下，用作收集统计信息、指标，以及将响应传输到客户端。  </li><li>ERROR 过滤器: 它是在其他过滤器发生错误时执行的。</li></ul><h3 id="构建网关"><a href="#构建网关" class="headerlink" title="构建网关"></a>构建网关</h3><ul><li>依赖    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>启动类<br>  添加 @EnableZuulProxy 注解开启 Zuul 的 API 网关服务功能。</li><li>application.yml  <ul><li>相关配置，包括配置服务注册中心的地址，程序的端口，程序名等  </li><li>路由配置：  <ul><li>传统路由方式:<br>  zuul.routes.app-a-url.path &#x3D; &#x2F;api-a-url&#x2F;<br>  zuul.routes.app-a-url.url &#x3D; <a href="http://localhost:8080/">http://localhost:8080/</a><br>  一旦指定了 Url，Zuul 就不能做负载均衡了，而是直接访问指定的Url，在实际的开发中这种做法不可取</li><li>面向服务的路由:<br>  zuul.routes.app-a-url.path &#x3D; &#x2F;api-a-url&#x2F;<br>  zuul.routes.app-a-url.serviceId &#x3D; hello-service<br>  满足“&#x2F;api-a-url”开头的请求 Url 都会被分发到 hello-service 服务。如果某服务存在多个实例，Zuul 结合 Ribbon 会做负载均衡，将请求均分的部分路由到不同的服务实例。</li></ul></li></ul></li></ul><h3 id="在-Zuul-上配置-API-接口的版本号"><a href="#在-Zuul-上配置-API-接口的版本号" class="headerlink" title="在 Zuul 上配置 API 接口的版本号"></a>在 Zuul 上配置 API 接口的版本号</h3><p>zuul.prefix: 给每个服务的 API 接口加前缀</p><h3 id="Zuul-熔断"><a href="#Zuul-熔断" class="headerlink" title="Zuul 熔断"></a>Zuul 熔断</h3><p><em>Zuul 目前只支持服务级别的熔断，不支持具体到某个URL进行熔断。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RibbonFallbackProviderImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">FallbackProvider</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRoute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;*&quot;</span>; <span class="hljs-comment">//这里是route的名称,不是服务的名称, 服务id，可以用* 或者 null 代表所有服务都过滤</span><br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title function_">fallbackResponse</span><span class="hljs-params">(String route, Throwable cause)</span> &#123;<br>        <span class="hljs-comment">// TODO Auto-generated method stub</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClientHttpResponse</span>() &#123; <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> HttpHeaders <span class="hljs-title function_">getHeaders</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();<br>                headers.setContentType(MediaType.APPLICATION_JSON_UTF8);<br>                <span class="hljs-keyword">return</span> headers;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> InputStream <span class="hljs-title function_">getBody</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-type">JSONObject</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span><span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>                json.put(<span class="hljs-string">&quot;state&quot;</span>,<span class="hljs-string">&quot;501&quot;</span>);<br>                json.put(<span class="hljs-string">&quot;msg&quot;</span>,<span class="hljs-string">&quot;后台接口错误&quot;</span>);<br><span class="hljs-comment">//                return new ByteArrayInputStream(json.toJSONString().getBytes(&quot;UTF-8&quot;)); //返回前端的内容</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(<span class="hljs-string">&quot;Zuul Fallback error string&quot;</span>.getBytes());<br>            &#125;  <br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getStatusText</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-keyword">return</span> HttpStatus.BAD_REQUEST.getReasonPhrase();<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> HttpStatus <span class="hljs-title function_">getStatusCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-comment">// TODO Auto-generated method stub</span><br>                <span class="hljs-keyword">return</span> HttpStatus.BAD_REQUEST;<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRawStatusCode</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-keyword">return</span> HttpStatus.BAD_REQUEST.value();<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// TODO Auto-generated method stub</span><br>            &#125;<br>        &#125;;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="第六章-微服务监控-Spring-Boot-Admin"><a href="#第六章-微服务监控-Spring-Boot-Admin" class="headerlink" title="第六章 微服务监控 Spring Boot Admin"></a>第六章 微服务监控 Spring Boot Admin</h2><p>管理和监控一个或者多个 Spring Boot 程序。<br>分为 Server 端和 Client 端，Client 端可以通过 HTTP 向 Server 端注册，也可以结合 Spring Cloud 的服务注册组件 Eureka 进行注册。<br>监控内容包括 Spring Boot 的监控组件 Actuator 的各个Http 节点，也支持更高级的功能，包括 Turbine、Jmx、Loglevel等。  </p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>Spring Boot Admin（ 简称 SBA ）服务端需要向服务注册中心注册服务</p><ul><li><p><strong>服务端</strong>  </p><ul><li><p>添加依赖  </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  2.0.3 使用不成功，不了解原因  </p></li><li><p>启动类<br>  添加 @EnableAdminServer 注解  </p></li><li><p>配置文件<br>  配置端口号、程序名、服务注册中心地址</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">server:</span><br><span class="hljs-symbol">  port:</span> <span class="hljs-number">8770</span><br><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  application:</span><br><span class="hljs-symbol">    name:</span> demo-admin-server<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">eureka:</span>   <br><span class="hljs-symbol">  client:</span><br><span class="hljs-symbol">    serviceUrl:</span><br><span class="hljs-symbol">      defaultZone:</span> $<span class="hljs-punctuation">&#123;</span>EUREKA_SERVICE_URL:http:<span class="hljs-comment">//localhost:8761&#125;/eureka/</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>客户端</strong>  </p><ul><li><p><strong>引入SBA Client</strong>  </p><ul><li><p>添加依赖  </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  客户端需要引入 actuator 依赖，服务端不需要  </p></li><li><p>配置文件<br>  actuator 监控可暴露全部端口，显示所有信息</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  application:</span><br><span class="hljs-symbol">    name:</span> user<br><span class="hljs-symbol">  boot:</span><br><span class="hljs-symbol">    admin:</span><br><span class="hljs-symbol">      client:</span><br><span class="hljs-symbol">        url:</span> http:<span class="hljs-comment">//localhost:8770</span><br><span class="hljs-symbol">eureka:</span><br><span class="hljs-symbol">  instance:</span><br><span class="hljs-symbol">    leaseRenewalIntervalInSeconds:</span> <span class="hljs-number">10</span><br>    health-check-url-path: <span class="hljs-keyword">/actuator/</span>health<br><span class="hljs-symbol">  client:</span><br><span class="hljs-symbol">    registryFetchIntervalSeconds:</span> <span class="hljs-number">5</span><br>    service-url:<br><span class="hljs-symbol">      defaultZone:</span> $<span class="hljs-punctuation">&#123;</span>EUREKA_SERVICE_URL:http:<span class="hljs-comment">//localhost:8671&#125;/eureka/</span><br><span class="hljs-symbol">management:</span><br><span class="hljs-symbol">  endpoints:</span><br><span class="hljs-symbol">    web:</span><br><span class="hljs-symbol">      exposure:</span><br><span class="hljs-symbol">        include:</span> <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-symbol">  endpoint:</span><br><span class="hljs-symbol">    health:</span><br>      show-details: ALWAYS<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>基于 Spring Cloud Discovery</strong></p></li></ul><p>  让 SBA 通过注册中心（Eureka、Consul等）来发现服务。<br>  只需要在 admin-client 中改变引入的依赖，其他不需要改变，即可<br>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--&lt;dependency&gt;--&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;groupId&gt;de.codecentric&lt;/groupId&gt;--&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt;--&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;version&gt;2.0.1&lt;/version&gt;--&gt;</span><br><span class="hljs-comment">&lt;!--&lt;/dependency&gt;--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure></p></li></ul><h3 id="安全配置"><a href="#安全配置" class="headerlink" title="安全配置"></a>安全配置</h3><p>SBA 服务端可以访问客户端的敏感点，因此建议为服务端和客户端添加一些安全配置  </p><h4 id="服务端的安全配置"><a href="#服务端的安全配置" class="headerlink" title="服务端的安全配置"></a>服务端的安全配置</h4><ul><li><p>添加依赖  </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件<br>  设置账号密码以及其他一些配置</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">server:</span><br><span class="hljs-symbol">  port:</span> <span class="hljs-number">8770</span><br><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  application:</span><br><span class="hljs-symbol">    name:</span> demo-admin-server<br><span class="hljs-symbol">  security:</span><br><span class="hljs-symbol">    user:</span><br><span class="hljs-symbol">      name:</span> admin<br><span class="hljs-symbol">      password:</span> admin<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">eureka:</span>   <br><span class="hljs-symbol">  instance:</span><br><span class="hljs-symbol">    leaseRenewalIntervalInSeconds:</span> <span class="hljs-number">10</span><br>    health-check-url-path: <span class="hljs-keyword">/actuator/</span>health<br><span class="hljs-symbol">  client:</span><br><span class="hljs-symbol">    registryFetchIntervalSeconds:</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">    serviceUrl:</span><br><span class="hljs-symbol">      defaultZone:</span> $<span class="hljs-punctuation">&#123;</span>EUREKA_SERVICE_URL:http:<span class="hljs-comment">//localhost:8761&#125;/eureka/</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">management:</span><br><span class="hljs-symbol">  endpoints:</span><br><span class="hljs-symbol">    web:</span><br><span class="hljs-symbol">      exposure:</span><br><span class="hljs-symbol">        include:</span> <span class="hljs-string">&quot;*&quot;</span><br><span class="hljs-symbol">  endpoint:</span><br><span class="hljs-symbol">    health:</span><br>      show-details: ALWAYS<br><br></code></pre></td></tr></table></figure></li><li><p>新增一个安全配置类  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Configuration<br>public <span class="hljs-keyword">class</span> SecuritySecureConfig extends WebSecurityConfigurerAdapter &#123;<br><br>    <span class="hljs-keyword">private</span> final String adminContextPath;<br><br>    public <span class="hljs-constructor">SecuritySecureConfig(AdminServerProperties <span class="hljs-params">adminServerProperties</span>)</span> &#123;<br>        this.adminContextPath = adminServerProperties.get<span class="hljs-constructor">ContextPath()</span>;<br>    &#125;<br><br>    @Override<br>    protected void configure(HttpSecurity http) throws Exception &#123;<br>        <span class="hljs-comment">// @formatter:off</span><br>        SavedRequestAwareAuthenticationSuccessHandler successHandler = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SavedRequestAwareAuthenticationSuccessHandler()</span>;<br>        successHandler.set<span class="hljs-constructor">TargetUrlParameter(<span class="hljs-string">&quot;redirectTo&quot;</span>)</span>;<br><br>        http.authorize<span class="hljs-constructor">Requests()</span><br>                .ant<span class="hljs-constructor">Matchers(<span class="hljs-params">adminContextPath</span> + <span class="hljs-string">&quot;/assets/**&quot;</span>)</span>.permit<span class="hljs-constructor">All()</span><br>                .ant<span class="hljs-constructor">Matchers(<span class="hljs-params">adminContextPath</span> + <span class="hljs-string">&quot;/login&quot;</span>)</span>.permit<span class="hljs-constructor">All()</span><br>                .any<span class="hljs-constructor">Request()</span>.authenticated<span class="hljs-literal">()</span><br>                .<span class="hljs-keyword">and</span><span class="hljs-literal">()</span><br>                .form<span class="hljs-constructor">Login()</span>.login<span class="hljs-constructor">Page(<span class="hljs-params">adminContextPath</span> + <span class="hljs-string">&quot;/login&quot;</span>)</span>.success<span class="hljs-constructor">Handler(<span class="hljs-params">successHandler</span>)</span>.<span class="hljs-keyword">and</span><span class="hljs-literal">()</span><br>                .logout<span class="hljs-literal">()</span>.logout<span class="hljs-constructor">Url(<span class="hljs-params">adminContextPath</span> + <span class="hljs-string">&quot;/logout&quot;</span>)</span>.<span class="hljs-keyword">and</span><span class="hljs-literal">()</span><br>                .http<span class="hljs-constructor">Basic()</span>.<span class="hljs-keyword">and</span><span class="hljs-literal">()</span><br>                .csrf<span class="hljs-literal">()</span>.disable<span class="hljs-literal">()</span>;<br>        <span class="hljs-comment">// @formatter:on</span><br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><p>如果你的客户端使用的是 SBA Client 的方式，客户端此时已无法注册到服务端（Spring Cloud Discovery 不受影响），需要在配置文件添加：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.admin</span><span class="hljs-selector-class">.client</span>:<br>  username: <span class="hljs-string">&quot;admin&quot;</span><br>  password: <span class="hljs-string">&quot;admin&quot;</span><br></code></pre></td></tr></table></figure><h4 id="客户端的安全配置"><a href="#客户端的安全配置" class="headerlink" title="客户端的安全配置"></a>客户端的安全配置</h4><h5 id="SBA-Client-的安全配置"><a href="#SBA-Client-的安全配置" class="headerlink" title="SBA Client 的安全配置"></a>SBA Client 的安全配置</h5><ul><li>客户端的配置文件  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">server.port</span>=<span class="hljs-number">8081</span><br><br><span class="hljs-attr">spring.application.name</span>=demo-admin-client-<span class="hljs-number">2</span><br><span class="hljs-attr">spring.boot.admin.client.url</span>=http://localhost:<span class="hljs-number">8770</span><br><span class="hljs-attr">management.endpoints.web.exposure.include</span>=*<br><br><span class="hljs-attr">spring.security.user.name</span>=client1<br><span class="hljs-attr">spring.security.user.password</span>=client1<br><br><span class="hljs-attr">spring.boot.admin.client.username</span>=admin<br><span class="hljs-attr">spring.boot.admin.client.password</span>=<span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure></li><li>服务器端的配置文件增加  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>   <span class="hljs-attr">port:</span> <span class="hljs-number">8770</span><br> <span class="hljs-attr">spring:</span><br>   <span class="hljs-attr">application:</span><br>     <span class="hljs-attr">name:</span> <span class="hljs-string">demo-admin-server</span><br>   <span class="hljs-attr">security:</span><br>     <span class="hljs-attr">user:</span><br>       <span class="hljs-attr">name:</span> <span class="hljs-string">admin</span><br>       <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br><br> <span class="hljs-attr">eureka:</span>   <br>   <span class="hljs-attr">instance:</span><br>     <span class="hljs-attr">leaseRenewalIntervalInSeconds:</span> <span class="hljs-number">10</span><br>     <span class="hljs-attr">health-check-url-path:</span> <span class="hljs-string">/actuator/health</span><br>     <span class="hljs-attr">metadata-map:</span><br>       <span class="hljs-attr">user.name:</span> <span class="hljs-string">$&#123;spring.security.user.name&#125;</span><br>       <span class="hljs-attr">user.password:</span> <span class="hljs-string">$&#123;spring.security.user.password&#125;</span> <br>   <span class="hljs-attr">client:</span><br>     <span class="hljs-attr">registryFetchIntervalSeconds:</span> <span class="hljs-number">5</span><br>     <span class="hljs-attr">serviceUrl:</span><br>       <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">$&#123;EUREKA_SERVICE_URL:http://localhost:8761&#125;/eureka/</span><br><br> <span class="hljs-attr">management:</span><br>   <span class="hljs-attr">endpoints:</span><br>     <span class="hljs-attr">web:</span><br>       <span class="hljs-attr">exposure:</span><br>         <span class="hljs-attr">include:</span> <span class="hljs-string">&quot;*&quot;</span><br>   <span class="hljs-attr">endpoint:</span><br>     <span class="hljs-attr">health:</span><br>       <span class="hljs-attr">show-details:</span> <span class="hljs-string">ALWAYS</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="Spring-Cloud-Discovery-的安全配置"><a href="#Spring-Cloud-Discovery-的安全配置" class="headerlink" title="Spring Cloud Discovery 的安全配置"></a>Spring Cloud Discovery 的安全配置</h5><ul><li>客户端的配置文件<figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">application</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">user</span><br>  <span class="hljs-attribute">security</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">user</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;client&quot;</span><br>      <span class="hljs-attribute">password</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;client&quot;</span><br><span class="hljs-attribute">eureka</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">instance</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">leaseRenewalIntervalInSeconds</span><span class="hljs-punctuation">:</span> <span class="hljs-string">10</span><br>    <span class="hljs-attribute">health-check-url-path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/actuator/health</span><br>    <span class="hljs-attribute">metadata-map</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">user.name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">$&#123;spring.security.user.name&#125;</span><br>      <span class="hljs-attribute">user.password</span><span class="hljs-punctuation">:</span> <span class="hljs-string">$&#123;spring.security.user.password&#125;</span><br>  <span class="hljs-attribute">client</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">registryFetchIntervalSeconds</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5</span><br>    <span class="hljs-attribute">service-url</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">defaultZone</span><span class="hljs-punctuation">:</span> <span class="hljs-string">$&#123;EUREKA_SERVICE_URL:http://localhost:8671&#125;/eureka/</span><br><span class="hljs-attribute">management</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">endpoints</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">web</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">exposure</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">include</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;*&quot;</span><br>  <span class="hljs-attribute">endpoint</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">health</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">show-details</span><span class="hljs-punctuation">:</span> <span class="hljs-string">ALWAYS</span><br></code></pre></td></tr></table></figure></li><li>服务端的配置文件<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">management.endpoints.web.exposure.include</span>=*<br><span class="hljs-attr">management.endpoint.health.enabled</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">spring.application.name</span>=demo-admin-client<br><span class="hljs-attr">server.port</span>=<span class="hljs-number">8771</span><br><span class="hljs-attr">eureka.client.service-url.defaultZone</span>=<span class="hljs-variable">$&#123;EUREKA_SERVICE_URL:http://localhost:8761&#125;</span>/eureka/<br><br><span class="hljs-attr">spring.security.user.name</span>=client<br><span class="hljs-attr">spring.security.user.password</span>=client<br><br><span class="hljs-attr">eureka.instance.metadata-map.user.name</span>=<span class="hljs-variable">$&#123;spring.security.user.name&#125;</span><br><span class="hljs-attr">eureka.instance.metadata-map.user.password</span>=<span class="hljs-variable">$&#123;spring.security.user.password&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h3><p>去除了 hystrix dashboard 功能，用 Vue.js 取代 AngularJs 编写 UI 界面。 </p><ul><li><p>UI<br>Rewritten ui using vue.js<br>Integrated ui-login module into the main ui module<br>Removed ui-activiti module, as it was only used rarely<br>Removed Hystrix-Dashboard integration (subject to change)<br>Added support for the session endpoint<br>Added display of the (sanitized) metadata<br>Added option to reset loglevels<br>Added wallboard view  </p></li><li><p>Backend<br>Moved all classes to the spring.boot.admin.server package<br>Redesigned backend using event sourcing principles<br>Added concept of applications (consisting of 1 to n instances)<br>Moved endpoint detection to the backend by querying the &#x2F;actuator-index or by probing via OPTIONS request<br>Replaced Zuul with a custom proxy using the WebClient<br>Removed dependency on spring-cloud-starter<br>Added CompositeHttpHeadersProvider to support multiple HttpHeadersProviders at the same time<br>Added <code>InstanceExchangeFilterFunction</code>s which allows to intercept&#x2F;modify the requests to the monitored instances<br>Added out-of-the-box support for CloudFoundry<br>Added support for Spring Boot 1.5.x actuator endpoints using LegacyEndpointConverters<br>Update OpsGenieNotifier to api v2<br>Rewritten the MailNotifier to use Thymeleaf templates  </p></li><li><p>Client<br>Moved all properties to spring.boot.admin.client. and spring.boot.admin.client.instance.<br>Moved all classes to the spring.boot.admin.client package<br>Added support webflux applications<br>Added out-of-the-box support for CloudFoundry</p></li></ul><hr><h2 id="第七章-Sleuth-链路追踪"><a href="#第七章-Sleuth-链路追踪" class="headerlink" title="第七章 Sleuth 链路追踪"></a>第七章 Sleuth 链路追踪</h2><p>微服务架构是通过业务来划分服务的，对外暴露的接口，可能需要很多个服务协同才能完成一个接口功能，如果链路上任何一个服务出现问题，都会形成导致接口调用失败。此时查找出现问题的微服务是很困难的。<br>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin。  </p><h3 id="zipkin-服务端"><a href="#zipkin-服务端" class="headerlink" title="zipkin 服务端"></a>zipkin 服务端</h3><p>并非不能自己代码构建，但官方目前建议用已经提供好的server。构建方法也可以查看<a href="https://zipkin.io/pages/quickstart.html">官网</a>或者 <a href="https://github.com/openzipkin/zipkin#quick-start">github</a>，默认端口是9411，可通过几种方式构建。<br>这里通过直接拉取源代码编译： java -jar .&#x2F;zipkin-server&#x2F;target&#x2F;zipkin-server-*exec.jar<br>Zipkin Server的下载地址：<br><a href="https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/">https://dl.bintray.com/openzipkin/maven/io/zipkin/java/zipkin-server/</a><br>完成后访问<a href="http://localhost:9411/">http://localhost:9411/</a> ，可查看到管理界面  </p><h3 id="zipkin-客户端"><a href="#zipkin-客户端" class="headerlink" title="zipkin 客户端"></a>zipkin 客户端</h3><p>新建两个客户端，然后 client2 调用 client1 中的某个服务  </p><ul><li>依赖  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>application.yml 中  <ul><li>spring.zipkin.base-url指定zipkin server端的地址, 一般为<a href="http://localhost:9411/">http://localhost:9411/</a>   </li><li>spring.sleuth.sampler.probalility指定采样百分比，默认0.1，改成1.0表示所有数据都采用。</li></ul></li><li>见 Ribbon</li></ul><hr><h2 id="第八章-Spring-Cloud-配置中心"><a href="#第八章-Spring-Cloud-配置中心" class="headerlink" title="第八章 Spring Cloud 配置中心"></a>第八章 Spring Cloud 配置中心</h2><p>Spring Cloud Config 是 Spring Cloud 团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。  </p><p>服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密 &#x2F; 解密信息等访问接口；<br>而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。  </p><p>由于 Spring Cloud Config 实现的配置中心默认采用 Git 来存储配置信息，所以使用 Spring Cloud Config 构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过 Git 客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN 仓库、本地化文件系统。  </p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li><strong>Server 端</strong>  <ul><li><p>添加依赖  </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件  </p><ul><li>本地配置    <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">server.port</span>=<span class="hljs-number">8774</span><br><span class="hljs-attr">spring.application.name</span>=demo_config_server<br><span class="hljs-attr">spring.profiles.active</span>=native<br><span class="hljs-attr">spring.cloud.config.server.native.search-locations</span>=classpath:/shared<br></code></pre></td></tr></table></figure></li><li>Git 仓库配置    <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">server.<span class="hljs-attribute">port</span>=8774<br>spring.application.<span class="hljs-attribute">name</span>=demo_config_server<br>spring.cloud.config.server.git.<span class="hljs-attribute">uri</span>=http://github.com/xxx/springcloud<br><span class="hljs-comment"># 远程仓库中配置文件所在路径</span><br>spring.cloud.config.server.git.<span class="hljs-attribute">search-paths</span>=config-reg<br><span class="hljs-comment"># GitHub 仓库的登录名和密码，私有仓库登录名和密码是必须的，公共仓库可以不需要</span><br>spring.cloud.config.server.git.username=<br>spring.cloud.config.server.git.password=<br><span class="hljs-comment"># 仓库的分支</span><br>spring.cloud.config.server.git.<span class="hljs-attribute">default-label</span>=master<br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul><blockquote><p>设置属性 <strong>spring.profiles.active&#x3D;native</strong>, Config Server 会默认从应用的src&#x2F;main&#x2F;resource目录下检索配置文件<br>也可以通过 <strong>spring.cloud.config.server.native.searchLocations&#x3D;file:E:&#x2F;properties&#x2F;</strong> 属性来指定配置文件的位置  </p></blockquote><pre><code class="hljs">+ 启动类      添加 @EnableConfigServer，激活对配置中心的支持  </code></pre><blockquote><p>仓库中的配置文件会被转换成 Web 接口，访问可以参照以下的规则：</p><p>  &#x2F;{application}&#x2F;{profile}[&#x2F;{label}]<br>  &#x2F;{application}-{profile}.yml<br>  &#x2F;{label}&#x2F;{application}-{profile}.yml<br>  &#x2F;{application}-{profile}.properties<br>  &#x2F;{label}&#x2F;{application}-{profile}.properties  </p><p>上面的 URL 会映射{application}-{profile}.yml对应的配置文件，其中{label}对应 Git 上不同的分支，默认为 master。以 config-client-dev.yml 为例子，它的 application 是 config-client，profile 是 dev。</p></blockquote><ul><li><p><strong>Client 端</strong></p><ul><li><p>添加依赖  </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件<br>  application.yml</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  application:</span><br><span class="hljs-symbol">    name:</span> config-git<br><span class="hljs-symbol">server:</span><br><span class="hljs-symbol">  port:</span> <span class="hljs-number">13000</span><br></code></pre></td></tr></table></figure><p>  bootstrap.yml</p>  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  cloud:</span><br><span class="hljs-symbol">    config:</span><br><span class="hljs-symbol">      uri:</span> http:<span class="hljs-comment">//localhost:12000 # 配置中心的具体地址，即 config-server</span><br><span class="hljs-symbol">      name:</span> config-client <span class="hljs-meta"># 对应 &#123;application&#125; 部分</span><br><span class="hljs-symbol">      profile:</span> dev <span class="hljs-meta"># 对应 &#123;profile&#125; 部分</span><br><span class="hljs-symbol">      label:</span> master <span class="hljs-meta"># 对应 &#123;label&#125; 部分，即 Git 的分支。如果配置中心使用的是本地存储，则该参数无用</span><br></code></pre></td></tr></table></figure><p>  __特别注意__：上面这些与 Spring Cloud Config 相关的属性必须配置在 <strong>bootstrap.yml</strong> 中，config 部分内容才能被正确加载。<br>  因为 config 的相关配置会先于 application.yml，而 bootstrap.yml 的加载也是先于 application.yml。  </p></li><li><p>启动类<br>  无需修改<br>  Controller 中使用 @Value 注解来获取 Server 端参数值</p></li></ul></li><li><p><strong>Refresh</strong><br>因为 Spring Cloud Config 分服务端和客户端，服务端负责将 Git 中存储的配置文件发布成 REST 接口，客户端可以从服务端 REST 接口获取配置。但客户端并不能主动感知到配置的变化，从而主动去获取新的配置。每个客户端通过 POST 方法触发各自的 &#x2F;actuator&#x2F;refresh。  </p><ul><li>添加依赖    <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><p>spring-boot-starter-actuator是一套监控的功能，可以监控程序在运行时状态，其中就包括&#x2F;actuator&#x2F;refresh的功能。  </p><pre><code class="hljs">+ 开启更新机制  在加载变量的类上面加载 @RefreshScope, 在客户端执行 /actuator/refresh 时就会更新此类下面的变量值  + 配置文件  1.5x 以上默认开通了安全认证，所以要在配置文件 appliction.yml 中添加以下配置，以将 /actuator/refresh 暴露出来  <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">management:</span><br><span class="hljs-symbol">  endpoints:</span><br><span class="hljs-symbol">    web:</span><br><span class="hljs-symbol">      exposure:</span><br><span class="hljs-symbol">        include:</span> refresh<br></code></pre></td></tr></table></figure></code></pre><ul><li><strong>Webhook</strong></li></ul><p>Webhook 是当某个事件发生时，通过发送 HTTP POST 请求的方式来通知信息接收方。Webhook 来监测你在 Github.com 上的各种事件，最常见的莫过于 push 事件。如果你设置了一个监测 push 事件的 Webhook，那么每当你的这个项目有了任何提交，这个 Webhook 都会被触发，这时 Github 就会发送一个 HTTP POST 请求到你配置好的地址。</p><h3 id="服务化与高可用"><a href="#服务化与高可用" class="headerlink" title="服务化与高可用"></a>服务化与高可用</h3><p>把 config-server 也注册为服务，这样所有客户端就能以服务的方式进行访问。通过这种方法，只需要启动多个指向同一 Git 仓库位置的 config-server 就能实现高可用。  </p><ul><li><p>服务端改造</p><ul><li><p>添加依赖</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>application.yml<br>  在 application.yml 里新增 Eureka 的配置</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">eureka:<br>  client:<br>    service-url:<br>      defaultZone: http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8761</span><span class="hljs-regexp">/eureka/</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>客户端改造  </p><ul><li><p>添加依赖  </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件<br>  bootstrap.yml  </p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span><br>      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span><br>      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">service-id:</span> <span class="hljs-string">config-server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span><br></code></pre></td></tr></table></figure></li></ul><p>  主要是去掉了 <strong>spring.cloud.config.uri</strong> 直接指向 Server 端地址的配置，增加了最后的三个配置：  </p><ul><li>__spring.cloud.config.discovery.enabled__：开启 Config 服务发现支持  </li><li>__spring.cloud.config.discovery.serviceId__：指定 Server 端的 name, 也就是 Server 端spring.application.name的值  </li><li>__eureka.client.service-url.defaultZone__：指向配置中心的地址</li></ul><p>  这三个配置文件都需要放到bootstrap.yml的配置中。</p></li></ul><h3 id="消息总线-Bus"><a href="#消息总线-Bus" class="headerlink" title="消息总线 Bus"></a>消息总线 Bus</h3><p>如果需要客户端获取到最新的配置信息需要执行refresh，我们可以利用 Webhook 的机制每次提交代码发送请求来刷新客户端，当客户端越来越多的时候，需要每个客户端都执行一遍，这种方案就不太适合了。使用 Spring Cloud Bus 可以完美解决这一问题。  </p><h4 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h4><p>通过轻量消息代理连接各个分布的节点。这会用在广播状态的变化（例如配置变化）或者其他的消息指令。Spring Bus 的一个核心思想是通过分布式的启动器对 Spring Boot 应用进行扩展，也可以用来建立一个多个应用之间的通信频道。目前唯一实现的方式是用 Amqp 消息代理作为通道，同样特性的设置（有些取决于通道的设置）在更多通道的文档中。  </p><p>Spring Cloud Bus 被国内很多都翻译为消息总线，也挺形象的。大家可以将它理解为管理和传播所有分布式项目中的消息既可，其实本质是利用了 MQ 的广播机制在分布式的系统中传播消息，目前常用的有 Kafka 和 RabbitMQ。利用 Bus 的机制可以做很多的事情，其中配置中心客户端刷新就是典型的应用场景之一。  </p><p>由于使用了 RabbitMQ，首先必须安装 RabbitMQ  </p><ul><li><p><strong>服务端</strong></p><ul><li><p>添加依赖<br>  必须的  </p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-bus<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件  </p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-server</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">server:</span><br>        <span class="hljs-attr">git:</span><br>          <span class="hljs-attr">uri:</span> <span class="hljs-string">https://github.com/zhaoyibo/spring-cloud-study</span><br>          <span class="hljs-attr">search-paths:</span> <span class="hljs-string">config-repo</span><br>    <span class="hljs-attr">bus:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">trace:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">12000</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:8761/eureka/</span><br><span class="hljs-attr">management:</span><br>  <span class="hljs-attr">endpoints:</span><br>    <span class="hljs-attr">web:</span><br>      <span class="hljs-attr">exposure:</span><br>        <span class="hljs-attr">include:</span> <span class="hljs-string">bus-refresh</span><br></code></pre></td></tr></table></figure></li><li><p>启动类<br>  加 @EnableConfigServer 注解</p></li></ul></li><li><p><strong>客户端</strong></p><ul><li><p>添加依赖<br>  必须的</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-bus<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-stream-binder-rabbit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置文件<br>  application.yml</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">bus:</span><br>      <span class="hljs-attr">trace:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">13000</span><br></code></pre></td></tr></table></figure><p>  bootstrap.yml</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span><br>      <span class="hljs-attr">profile:</span> <span class="hljs-string">dev</span><br>      <span class="hljs-attr">label:</span> <span class="hljs-string">master</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>        <span class="hljs-attr">service-id:</span> <span class="hljs-string">config-server</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7000/eureka/</span><br></code></pre></td></tr></table></figure></li><li><p>Controller<br>  @RefreshScope 必须加，否则客户端会受到服务端的更新消息，但是更新不了，因为不知道更新哪里的。</p></li></ul></li><li><p><strong>测试</strong><br>  更改配置文件中的值。通过 Postman 或其他工具向 config server 发送一个 &#x2F;actuator&#x2F;bus-refresh&#x2F; 的 Post 请求，请求发送成功后，再访问浏览器</p></li></ul><blockquote><p>只要开启 Spring Cloud Bus 后，暴露 bus-refresh，不管是对 config-server 还是 config-client 执行&#x2F;actuator&#x2F;bus-refresh都是可以更新配置的</p></blockquote><ul><li><p><strong>其他</strong></p><ul><li><strong>局部刷新</strong></li></ul><p>  可通过&#x2F;actuator&#x2F;bus-refresh&#x2F;{destination}端点的 destination 参数来定位要刷新的应用程序。  </p><p>  例如：&#x2F;actuator&#x2F;bus-refresh&#x2F;customers:8000，这样消息总线上的微服务实例就会根据 destination 参数的值来判断是否需要要刷新。其中，customers:8000指的是各个微服务的 ApplicationContext ID。  </p><p>  destination 参数也可以用来定位特定的微服务。例如：&#x2F;actuator&#x2F;bus-refresh&#x2F;customers:**，这样就可以触发 customers 微服务所有实例的配置刷新。  </p><ul><li><strong>跟踪总线事件</strong></li></ul><p>  跟踪总线事件非常简单，只需设置 __spring.cloud.bus.trace.enabled&#x3D;true__，这样在&#x2F;actuator&#x2F;bus-refresh端点被请求后。</p></li></ul><blockquote><p>可参考网页：<a href="https://www.cnblogs.com/cralor/p/9239976.html">https://www.cnblogs.com/cralor/p/9239976.html</a></p></blockquote><hr><h2 id="第九章-Spring-Cloud-Oauth2"><a href="#第九章-Spring-Cloud-Oauth2" class="headerlink" title="第九章 Spring Cloud Oauth2"></a>第九章 Spring Cloud Oauth2</h2><h3 id="TokenStore"><a href="#TokenStore" class="headerlink" title="TokenStore"></a>TokenStore</h3><p>Persistence interface for OAuth2 tokens.(对于 OAuth2 令牌持久化接口)<br>默认实现有三种：  </p><ul><li>InMemoryTokenStore  </li><li>JdbcTokenStore  </li><li>JwtTokenStore</li></ul><h4 id="InMemoryTokenStore"><a href="#InMemoryTokenStore" class="headerlink" title="InMemoryTokenStore"></a>InMemoryTokenStore</h4><p><strong>1. 概要</strong>  </p><p>默认采用的实现方式。<br>在单服务上可以体现出很好特效（即并发量不大，并且在失败的时候不会进行备份）<br>存储在内存，调试简易</p><p><strong>2. 实现</strong>  </p><p>默认实现，直接调用即可  </p><p><strong>3. 代码调用</strong>  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)<br><span class="hljs-keyword">private</span> TokenStore inMemoryTokenStore;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>   endpoints.tokenStore(inMemoryTokenStore);<br>   ....<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="JdbcTokenStore"><a href="#JdbcTokenStore" class="headerlink" title="JdbcTokenStore"></a>JdbcTokenStore</h4><p><strong>1. 概要</strong><br>基于 JDBC 的实现，令牌会保存到数据库。<br>可以在多个服务直接实现令牌共享。  </p><p><strong>2. 实现</strong>  </p><p>1). 配置数据源<br>2). 数据库（见附录）<br>3). 配置 JdbcTokenStore</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Autowired</span> <span class="hljs-keyword">private</span> <span class="hljs-title class_">DataSource</span> dataSource;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">TokenStore</span> <span class="hljs-title function_">jdbcTokenStore</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">Assert</span>.<span class="hljs-title function_">state</span>(dataSource != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;DataSource must be provided&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdbcTokenStore</span>(dataSource);<br>&#125;<br></code></pre></td></tr></table></figure><p>4). 代码调用  </p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Autowired</span>(required = <span class="hljs-keyword">false</span>)<br><span class="hljs-keyword">private</span> TokenStore jdbcTokenStore;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerEndpointsConfigurer endpoints)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>   endpoints.tokenStore(jdbcTokenStore);<br>   ....<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="JwtTokenStore"><a href="#JwtTokenStore" class="headerlink" title="JwtTokenStore"></a>JwtTokenStore</h4><p><strong>1. 概要</strong>  </p><p>jwt 全称 JSON Web Token。<br>这个实现方式不用管如何进行存储，因为它可以把相关信息数据编码存放在令牌里。<br>不会保存任何数据，但是在转换令牌值以及授权信息方面与 DefaultTokenServices 所扮演的角色是一样的。  </p><p><strong>2. 实现</strong>  </p><p>jwt 存放在令牌中，考虑安全性，因此，OAuth2 提供了 JwtAccessTokenConverter 实现， 添加 jwtSigningKey, 以此生成秘钥，以此进行签名，只有 jwtSigningKey 才能获取信息。</p><hr><h2 id="第十章-Spring-Cloud-Gateway"><a href="#第十章-Spring-Cloud-Gateway" class="headerlink" title="第十章 Spring Cloud Gateway"></a>第十章 Spring Cloud Gateway</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-class">.route</span>(<span class="hljs-string">&quot;path_route&quot;</span>, r -&gt; r<span class="hljs-selector-class">.path</span>(<span class="hljs-string">&quot;/href&quot;</span>)<br>    <span class="hljs-selector-class">.filters</span>(fn -&gt; fn<span class="hljs-selector-class">.stripPrefix</span>(<span class="hljs-number">1</span>))<br>    <span class="hljs-selector-class">.uri</span>(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="1-路由谓词工厂链"><a href="#1-路由谓词工厂链" class="headerlink" title="1. 路由谓词工厂链"></a>1. 路由谓词工厂链</h3><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">id: gate-consumer</span><br>        <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">lb://gate-consumer</span><br>        <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br><span class="hljs-comment">#        - Path=/client/**</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">name: Path</span><br>          <span class="hljs-attribute">args</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-attribute">pattern</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/client/**</span><br></code></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">predicates:</span><br>  - name: Path<br><span class="hljs-symbol">    args:</span><br><span class="hljs-symbol">      pattern:</span> <span class="hljs-keyword">/client/</span>**<br>等同于<br><span class="hljs-symbol">predicates:</span><br>  - P<span class="hljs-attr">ath</span><span class="hljs-operator">=</span><span class="hljs-keyword">/client/</span>**<br></code></pre></td></tr></table></figure><h4 id="1-1-After-路由谓词工厂"><a href="#1-1-After-路由谓词工厂" class="headerlink" title="1.1 After 路由谓词工厂"></a>1.1 After 路由谓词工厂</h4><p>采用一个 datetime 类型的参数<br>匹配当前日期时间之后发生的请求  </p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">id: after_route</span><br>        <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">https://www.baidu.com</span><br>        <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">After=2018-12-20T17:20:30.00-07:00[Asia/Shanghai]</span><br></code></pre></td></tr></table></figure><h4 id="1-2-Before-路由谓词工厂"><a href="#1-2-Before-路由谓词工厂" class="headerlink" title="1.2 Before 路由谓词工厂"></a>1.2 Before 路由谓词工厂</h4><p>采用一个 datetime 类型的参数<br>匹配当前日期时间之前发生的请求  </p><h4 id="1-3-Between-路由谓词工厂"><a href="#1-3-Between-路由谓词工厂" class="headerlink" title="1.3 Between 路由谓词工厂"></a>1.3 Between 路由谓词工厂</h4><p>采用两个 datetime 类型的参数，参数 2 必须在参数 1 之后<br>匹配日期之前发生的请求  </p><h4 id="1-4-Cookie-路由谓词工厂"><a href="#1-4-Cookie-路由谓词工厂" class="headerlink" title="1.4 Cookie 路由谓词工厂"></a>1.4 Cookie 路由谓词工厂</h4><p>采用两个参数，Cookie 名称和正则表达式<br>匹配具有给定名称的 cookie，值与正则表达式匹配  </p><h4 id="1-5-Header-路由谓词工厂"><a href="#1-5-Header-路由谓词工厂" class="headerlink" title="1.5 Header 路由谓词工厂"></a>1.5 Header 路由谓词工厂</h4><p>采用两个参数，Header 名称和正则表达式<br>匹配具有给定名称且值与正则表达式匹配的 Header 匹配  </p><h4 id="1-6-Host-路由谓词工厂"><a href="#1-6-Host-路由谓词工厂" class="headerlink" title="1.6 Host 路由谓词工厂"></a>1.6 Host 路由谓词工厂</h4><p>采用一个 主机名模式 的参数，该模式是一种 Ant 样式模式作为分隔符<br>匹配该模式的主机头部匹配  </p><h4 id="1-7-Method-路由谓词工厂"><a href="#1-7-Method-路由谓词工厂" class="headerlink" title="1.7 Method 路由谓词工厂"></a>1.7 Method 路由谓词工厂</h4><p>采用一个 要匹配的 HTTP 方法 的参数  </p><h4 id="1-8-Method-路由谓词工厂"><a href="#1-8-Method-路由谓词工厂" class="headerlink" title="1.8 Method 路由谓词工厂"></a>1.8 Method 路由谓词工厂</h4><p>采用一个 Spring PurthMatter 模式 的参数  </p><h4 id="1-9-Query-路由谓词工厂"><a href="#1-9-Query-路由谓词工厂" class="headerlink" title="1.9 Query 路由谓词工厂"></a>1.9 Query 路由谓词工厂</h4><p>采用两个参数，一个必需的参数和一个可选的正则表达式  </p><h4 id="1-10-RemoteAddr-路由谓词工厂"><a href="#1-10-RemoteAddr-路由谓词工厂" class="headerlink" title="1.10 RemoteAddr 路由谓词工厂"></a>1.10 RemoteAddr 路由谓词工厂</h4><p>采用 CIDR 符合（IPv4 或 IPv6）字符串的列表（最小值为1）</p><h3 id="2-网关过滤器工厂链"><a href="#2-网关过滤器工厂链" class="headerlink" title="2. 网关过滤器工厂链"></a>2. 网关过滤器工厂链</h3><h4 id="2-1-AddRequestHeader-网关过滤器工厂"><a href="#2-1-AddRequestHeader-网关过滤器工厂" class="headerlink" title="2.1 AddRequestHeader 网关过滤器工厂"></a>2.1 AddRequestHeader 网关过滤器工厂</h4><h4 id="2-2-AddRequestParameter-网关过滤器工厂"><a href="#2-2-AddRequestParameter-网关过滤器工厂" class="headerlink" title="2.2 AddRequestParameter 网关过滤器工厂"></a>2.2 AddRequestParameter 网关过滤器工厂</h4><h4 id="2-3-AddResponseHeader-网关过滤器工厂"><a href="#2-3-AddResponseHeader-网关过滤器工厂" class="headerlink" title="2.3 AddResponseHeader 网关过滤器工厂"></a>2.3 AddResponseHeader 网关过滤器工厂</h4><h4 id="2-4-Hystrix-网关过滤器工厂"><a href="#2-4-Hystrix-网关过滤器工厂" class="headerlink" title="2.4 Hystrix 网关过滤器工厂"></a>2.4 Hystrix 网关过滤器工厂</h4><h4 id="2-5-PrefixPath-网关过滤器工厂"><a href="#2-5-PrefixPath-网关过滤器工厂" class="headerlink" title="2.5 PrefixPath 网关过滤器工厂"></a>2.5 PrefixPath 网关过滤器工厂</h4><h4 id="2-6-PreserverHostHeader-网关过滤器工厂"><a href="#2-6-PreserverHostHeader-网关过滤器工厂" class="headerlink" title="2.6 PreserverHostHeader 网关过滤器工厂"></a>2.6 PreserverHostHeader 网关过滤器工厂</h4><p>没有参数，设置路由过滤器将检查的请求属性，以确定是否应发送原始主机头，而不是 http 客户端确定的主机头  </p><h4 id="2-7-RequestRateLimiter-网关过滤器工厂"><a href="#2-7-RequestRateLimiter-网关过滤器工厂" class="headerlink" title="2.7 RequestRateLimiter 网关过滤器工厂"></a>2.7 RequestRateLimiter 网关过滤器工厂</h4><p>使用 RateLimiter 实现来确定是否运行当前请求继续，如果不是，则返回 HTTP 429 - Too Many Requests (默认情况下)的状态  </p><h4 id="2-8-RedirectTo-网关过滤器工厂"><a href="#2-8-RedirectTo-网关过滤器工厂" class="headerlink" title="2.8 RedirectTo 网关过滤器工厂"></a>2.8 RedirectTo 网关过滤器工厂</h4><h4 id="2-9-RemoveNonProxyHeaders-网关过滤器工厂"><a href="#2-9-RemoveNonProxyHeaders-网关过滤器工厂" class="headerlink" title="2.9 RemoveNonProxyHeaders 网关过滤器工厂"></a>2.9 RemoveNonProxyHeaders 网关过滤器工厂</h4><h4 id="2-10-RemoveRequestHeader-网关过滤器工厂"><a href="#2-10-RemoveRequestHeader-网关过滤器工厂" class="headerlink" title="2.10 RemoveRequestHeader 网关过滤器工厂"></a>2.10 RemoveRequestHeader 网关过滤器工厂</h4><h4 id="2-11-RemoveResponseHeader-网关过滤器工厂"><a href="#2-11-RemoveResponseHeader-网关过滤器工厂" class="headerlink" title="2.11 RemoveResponseHeader 网关过滤器工厂"></a>2.11 RemoveResponseHeader 网关过滤器工厂</h4><h4 id="2-12-RewritePath-网关过滤器工厂"><a href="#2-12-RewritePath-网关过滤器工厂" class="headerlink" title="2.12 RewritePath 网关过滤器工厂"></a>2.12 RewritePath 网关过滤器工厂</h4><h4 id="2-13-SaveSession-网关过滤器工厂"><a href="#2-13-SaveSession-网关过滤器工厂" class="headerlink" title="2.13 SaveSession 网关过滤器工厂"></a>2.13 SaveSession 网关过滤器工厂</h4><h4 id="2-14-SecureHeaders-网关过滤器工厂"><a href="#2-14-SecureHeaders-网关过滤器工厂" class="headerlink" title="2.14 SecureHeaders 网关过滤器工厂"></a>2.14 SecureHeaders 网关过滤器工厂</h4><h4 id="2-15-SetPath-网关过滤器工厂"><a href="#2-15-SetPath-网关过滤器工厂" class="headerlink" title="2.15 SetPath 网关过滤器工厂"></a>2.15 SetPath 网关过滤器工厂</h4><h4 id="2-16-SetResponseHeader-网关过滤器工厂"><a href="#2-16-SetResponseHeader-网关过滤器工厂" class="headerlink" title="2.16 SetResponseHeader 网关过滤器工厂"></a>2.16 SetResponseHeader 网关过滤器工厂</h4><h4 id="2-17-SetStatus-网关过滤器工厂"><a href="#2-17-SetStatus-网关过滤器工厂" class="headerlink" title="2.17 SetStatus 网关过滤器工厂"></a>2.17 SetStatus 网关过滤器工厂</h4><h4 id="2-18-StripPrefix-网关过滤器工厂"><a href="#2-18-StripPrefix-网关过滤器工厂" class="headerlink" title="2.18 StripPrefix 网关过滤器工厂"></a>2.18 StripPrefix 网关过滤器工厂</h4><h4 id="2-19-Retry-网关过滤器工厂"><a href="#2-19-Retry-网关过滤器工厂" class="headerlink" title="2.19 Retry 网关过滤器工厂"></a>2.19 Retry 网关过滤器工厂</h4><h4 id="2-20-RequestSize-网关过滤器工厂"><a href="#2-20-RequestSize-网关过滤器工厂" class="headerlink" title="2.20 RequestSize 网关过滤器工厂"></a>2.20 RequestSize 网关过滤器工厂</h4><h3 id="3-过滤器"><a href="#3-过滤器" class="headerlink" title="3. 过滤器"></a>3. 过滤器</h3><h4 id="3-1-Gateway-Filter"><a href="#3-1-Gateway-Filter" class="headerlink" title="3.1 Gateway Filter"></a>3.1 Gateway Filter</h4><p>相当于一个 Filter 过滤器，可以对访问的 URL 过滤，进行横切处理（切面处理），应用场景包括超时、安全  </p><h4 id="3-2-Global-Filter"><a href="#3-2-Global-Filter" class="headerlink" title="3.2 Global Filter"></a>3.2 Global Filter</h4><p>全局的 Filter，作用于所有路由  </p><h4 id="3-3-区别"><a href="#3-3-区别" class="headerlink" title="3.3 区别"></a>3.3 区别</h4><p>定义的方法一样都是 Moon filter()<br>Gateway Filter 应用到单个路由或者一个分组的路由上；继承了 ShortcutConfigurable<br>Global Filter 应用到所有的路由上;没有任何继承  </p><h3 id="4-Https-的使用技巧"><a href="#4-Https-的使用技巧" class="headerlink" title="4. Https 的使用技巧"></a>4. Https 的使用技巧</h3><p>常规的做法是通过Nginx来配置SSL证书。<br>将生成的https证书放到 Spring Cloud Gateway 应用的类路径下  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8762</span><br>  <span class="hljs-attr">ssl:</span><br>    <span class="hljs-attr">key-alias:</span> <span class="hljs-string">spring</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">key-store-password:</span> <span class="hljs-string">spring</span><br>    <span class="hljs-attr">key-store:</span> <span class="hljs-string">classpath:selfsigned.jks</span><br>    <span class="hljs-attr">key-store-type:</span> <span class="hljs-string">JKS</span><br>    <span class="hljs-attr">key-store-provider:</span> <span class="hljs-string">SUN</span><br>    <span class="hljs-attr">key-password:</span> <span class="hljs-string">spring</span><br></code></pre></td></tr></table></figure><p>由于请求进来的协议是 Https，而后端被代理的服务是 http 协议的请求，所以 Gateway 用 Https 请求转发调用 HTTP 协议就会出现 “not an SSL&#x2F;TLS record”的错误。<br>修改方法：  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.dog.filter;<br><br><span class="hljs-keyword">import</span> java.net.URI;<br><br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.LoadBalancerClientFilter;<br><span class="hljs-keyword">import</span> org.springframework.core.Ordered;<br><span class="hljs-keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><br><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpsToHttpFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">GlobalFilter</span>, Ordered &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">filter</span><span class="hljs-params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;<br>        <span class="hljs-type">URI</span> <span class="hljs-variable">orignalUri</span> <span class="hljs-operator">=</span> exchange.getRequest().getURI();<br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> exchange.getRequest();<br>        ServerHttpRequest.<span class="hljs-type">Builder</span> <span class="hljs-variable">mutate</span> <span class="hljs-operator">=</span> request.mutate();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">forwardedUri</span> <span class="hljs-operator">=</span> request.getURI().toString();<br>        <span class="hljs-keyword">if</span>(forwardedUri != <span class="hljs-literal">null</span> &amp;&amp; forwardedUri.startsWith(<span class="hljs-string">&quot;https&quot;</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">URI</span> <span class="hljs-variable">mutatedUri</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(<span class="hljs-string">&quot;http&quot;</span>,<br>                        orignalUri.getUserInfo(),<br>                        orignalUri.getHost(),<br>                        orignalUri.getPort(),<br>                        orignalUri.getPath(),<br>                        orignalUri.getQuery(),<br>                        orignalUri.getFragment());<br>                mutate.uri(mutatedUri);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(e.getMessage(), e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">ServerHttpRequest</span> <span class="hljs-variable">build</span> <span class="hljs-operator">=</span> mutate.build();<br>        <span class="hljs-keyword">return</span> chain.filter(exchange.mutate().request(build).build());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> LoadBalancerClientFilter.LOAD_BALANCER_CLIENT_FILTER_ORDER - <span class="hljs-number">1</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="5-整合-Swagger2"><a href="#5-整合-Swagger2" class="headerlink" title="5. 整合 Swagger2"></a>5. 整合 Swagger2</h4><p>5.1 在 Gateway 网关创建三个类： SwaggerHandle, SwaggerProvider, SwaggerHeaderFilter   </p><p>5.1.1 SwaggerHandler  </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.example.dog.swagger2;<br><br><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.http.HttpStatus;<br><span class="hljs-keyword">import</span> org.springframework.http.ResponseEntity;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><span class="hljs-keyword">import</span> reactor.core.publisher.Mono;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger.web.*;<br><br><span class="hljs-keyword">import</span> java.util.Optional;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/swagger-resources&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SwaggerHandler</span> &#123;<br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> SecurityConfiguration securityConfiguration;<br>    <span class="hljs-meta">@Autowired(required = false)</span><br>    <span class="hljs-keyword">private</span> UiConfiguration uiConfiguration;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SwaggerResourcesProvider swaggerResources;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> SwaggerHandler(SwaggerResourcesProvider swaggerResources) &#123;<br>        <span class="hljs-keyword">this</span>.swaggerResources = swaggerResources;<br>    &#125;<br><br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/configuration/security&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;SecurityConfiguration&gt;&gt; securityConfiguration() &#123;<br>        <span class="hljs-keyword">return</span> Mono.just(new ResponseEntity&lt;&gt;(<br>                Optional.ofNullable(securityConfiguration).orElse(SecurityConfigurationBuilder.builder().build()), HttpStatus.OK));<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/configuration/ui&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;UiConfiguration&gt;&gt; uiConfiguration() &#123;<br>        <span class="hljs-keyword">return</span> Mono.just(new ResponseEntity&lt;&gt;(<br>                Optional.ofNullable(uiConfiguration).orElse(UiConfigurationBuilder.builder().build()), HttpStatus.OK));<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&gt; swaggerResources() &#123;<br>        <span class="hljs-keyword">return</span> Mono.just((new ResponseEntity&lt;&gt;(swaggerResources.<span class="hljs-keyword">get</span>(), HttpStatus.OK)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>5.1.2 GatewaySwaggerProvider  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.dog.swagger2;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.config.GatewayProperties;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.route.RouteLocator;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.support.NameUtils;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Primary;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> springfox.documentation.swagger.web.SwaggerResource;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger.web.SwaggerResourcesProvider;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Primary</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewaySwaggerProvider</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SwaggerResourcesProvider</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">API_URI</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/v2/api-docs&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RouteLocator routeLocator;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> GatewayProperties gatewayProperties;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GatewaySwaggerProvider</span><span class="hljs-params">(RouteLocator routeLocator, GatewayProperties gatewayProperties)</span> &#123;<br>        <span class="hljs-built_in">this</span>.routeLocator = routeLocator;<br>        <span class="hljs-built_in">this</span>.gatewayProperties = gatewayProperties;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;SwaggerResource&gt; <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        List&lt;SwaggerResource&gt; resources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        List&lt;String&gt; routes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">//取出Spring Cloud Gateway中的route</span><br>        routeLocator.getRoutes().subscribe(route -&gt; routes.add(route.getId()));<br>        <span class="hljs-comment">//结合application.yml中的路由配置，只获取有效的route节点</span><br>        gatewayProperties.getRoutes().stream().filter(routeDefinition -&gt; routes.contains(routeDefinition.getId()))<br>                .forEach(routeDefinition -&gt; routeDefinition.getPredicates().stream()<br>                        .filter(predicateDefinition -&gt; (<span class="hljs-string">&quot;Path&quot;</span>).equalsIgnoreCase(predicateDefinition.getName()))<br>                        .forEach(predicateDefinition -&gt; resources.add(swaggerResource(routeDefinition.getId(),<br>                                predicateDefinition.getArgs().get(NameUtils.GENERATED_NAME_PREFIX + <span class="hljs-string">&quot;0&quot;</span>)<br>                                        .replace(<span class="hljs-string">&quot;/**&quot;</span>, API_URI)))));<br>        <span class="hljs-keyword">return</span> resources;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> SwaggerResource <span class="hljs-title function_">swaggerResource</span><span class="hljs-params">(String name, String location)</span> &#123;<br>        <span class="hljs-type">SwaggerResource</span> <span class="hljs-variable">swaggerResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SwaggerResource</span>();<br>        swaggerResource.setName(name);<br>        swaggerResource.setLocation(location);<br>        swaggerResource.setSwaggerVersion(<span class="hljs-string">&quot;2.0&quot;</span>);<br>        <span class="hljs-keyword">return</span> swaggerResource;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>5.1.3 SwaggerHeaderFilter 这个类只是在 Finchley.RELEASE 版本需要实现，SR2 版本无需实现。  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.example.dog.swagger2;<br><br><br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilter;<br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;<br><span class="hljs-keyword">import</span> org.springframework.http.server.reactive.ServerHttpRequest;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> org.springframework.util.StringUtils;<br><span class="hljs-keyword">import</span> org.springframework.web.server.ServerWebExchange;<br><br>@Component<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SwaggerHeaderFilter</span> <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">AbstractGatewayFilterFactory</span></span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-keyword">String</span> HEADER_NAME = <span class="hljs-string">&quot;X-Forwarded-Prefix&quot;</span>;<br>    <br>    @Override<br>    <span class="hljs-keyword">public</span> GatewayFilter apply(Object config) &#123;<br>        <span class="hljs-keyword">return</span> (exchange, chain) -&gt; &#123;<br>            ServerHttpRequest request = exchange.getRequest();<br>            <span class="hljs-keyword">String</span> path = request.getURI().getPath();<br>            <span class="hljs-keyword">if</span>(!StringUtils.endsWithIgnoreCase(path, GatewaySwaggerProvider.API_URI)) &#123;<br>                <span class="hljs-keyword">return</span> chain.filter(exchange);<br>            &#125;<br>            <span class="hljs-keyword">String</span> basePath = path.substring(<span class="hljs-number">0</span>, path.lastIndexOf(GatewaySwaggerProvider.API_URI));<br>            ServerHttpRequest <span class="hljs-keyword">new</span><span class="hljs-type">Request</span> = request.mutate().header(HEADER_NAME, basePath).build();<br>            ServerWebExchange <span class="hljs-keyword">new</span><span class="hljs-type">Exchange</span> = exchange.mutate().request(<span class="hljs-keyword">new</span><span class="hljs-type">Request</span>).build();<br>            <span class="hljs-keyword">return</span> chain.filter(<span class="hljs-keyword">new</span><span class="hljs-type">Exchange</span>);<br>        &#125;;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>5.2 Gateway 的 application.yml 中配置：</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">application</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">gateway_server</span><br><span class="hljs-comment"># Gateway注册到 Eureka, 默认服务名要大写</span><br><span class="hljs-comment"># 注册到 ZooKeeper 上，服务名默认小写</span><br><span class="hljs-comment"># 注册到 Consul 上，服务名默认小写</span><br><span class="hljs-comment"># 设置为 true 表示开启用小写的 serviceId 进行基于服务路由的转发</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">discovery</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-attribute">locator</span><span class="hljs-punctuation">:</span><br>          <span class="hljs-attribute">lower-case-service-id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">true</span><br><span class="hljs-comment"># 是否与服务发现组件进行结合，通过 seviceId 转发到具体的服务实例。</span><br><span class="hljs-comment"># 默认为 false，若为 true 便开启基于服务发现的路由规则</span><br>          <span class="hljs-attribute">enabled</span><span class="hljs-punctuation">:</span> <span class="hljs-string">true</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">id: gate-consumer</span><br>        <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">lb://gate-consumer</span><br>        <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/client/**</span><br>        <span class="hljs-attribute">filters</span><span class="hljs-punctuation">:</span><br><span class="hljs-comment">#        - SwaggerHeaderFilter</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">id: sc-service</span><br>        <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">lb://sc-service</span><br>        <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/admin/**</span><br>        <span class="hljs-attribute">filters</span><span class="hljs-punctuation">:</span><br><span class="hljs-comment">#        - SwaggerHeaderFilter</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><blockquote><p>在 SR2 中不需要添加 SwaggerHeaderFilter</p></blockquote><p>5.3 Swagger 基于 eureka 服务注册机制的实现，需要重写 SwaggerProvider, 基于DiscoveryClientRouteDefinitionLocator 发现的路由器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.dog.swagger2.provider;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">import</span> org.springframework.cloud.gateway.discovery.DiscoveryClientRouteDefinitionLocator;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Primary;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> springfox.documentation.swagger.web.SwaggerResource;<br><span class="hljs-keyword">import</span> springfox.documentation.swagger.web.SwaggerResourcesProvider;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Primary</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GatewaySwaggerProviderFromDiscovery</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SwaggerResourcesProvider</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">API_URI</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/v2/api-docs&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EUREKA_SUB_PRIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CompositeDiscoveryClient_&quot;</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DiscoveryClientRouteDefinitionLocator routeDefinitionLocator;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">GatewaySwaggerProviderFromDiscovery</span><span class="hljs-params">(DiscoveryClientRouteDefinitionLocator routeDefinitionLocator)</span> &#123;<br>        <span class="hljs-built_in">this</span>.routeDefinitionLocator = routeDefinitionLocator;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;SwaggerResource&gt; <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        List&lt;SwaggerResource&gt; resources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 从 DiscoveryClientRouteDefinitionLocator 中取出 routes，构造 swaggerResource</span><br>        routeDefinitionLocator.getRouteDefinitions().subscribe(routeDefinition -&gt; &#123;<br>            resources.add(swaggerResource(routeDefinition.getId().substring(EUREKA_SUB_PRIX.length()),<br>                    routeDefinition.getPredicates()<br>                        .get(<span class="hljs-number">0</span>).getArgs().get(<span class="hljs-string">&quot;pattern&quot;</span>)<br>                            .replace(<span class="hljs-string">&quot;/**&quot;</span>, API_URI)));<br>        &#125;);<br>        <br>        <span class="hljs-keyword">return</span> resources;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> SwaggerResource <span class="hljs-title function_">swaggerResource</span><span class="hljs-params">(String name, String location)</span> &#123;<br>        <span class="hljs-type">SwaggerResource</span> <span class="hljs-variable">swaggerResource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SwaggerResource</span>();<br>        swaggerResource.setName(name);<br>        swaggerResource.setLocation(location);<br>        swaggerResource.setSwaggerVersion(<span class="hljs-string">&quot;2.0&quot;</span>);<br>        <span class="hljs-keyword">return</span> swaggerResource;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>application  </p> <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  cloud:</span><br><span class="hljs-symbol">    gateway:</span><br><span class="hljs-symbol">      routes:</span><br>      - id: gate-consumer<br><span class="hljs-symbol">        uri:</span> lb:<span class="hljs-comment">//gate-consumer</span><br><span class="hljs-symbol">        predicates:</span><br>        - name: Path<br><span class="hljs-symbol">          args:</span><br><span class="hljs-symbol">            pattern:</span> <span class="hljs-keyword">/client/</span>**<br></code></pre></td></tr></table></figure><h2 id="参考自-spring-cloud-gateway聚合swagger-以及-重新定义-Spring-Cloud"><a href="#参考自-spring-cloud-gateway聚合swagger-以及-重新定义-Spring-Cloud" class="headerlink" title="参考自 spring cloud gateway聚合swagger 以及 重新定义 Spring Cloud"></a>参考自 <a href="https://blog.csdn.net/qq_37616173/article/details/83113813">spring cloud gateway聚合swagger</a> 以及 重新定义 Spring Cloud</h2><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><h4 id="1-EnableEurekaClient-和-EnableDiscoveryClient注解"><a href="#1-EnableEurekaClient-和-EnableDiscoveryClient注解" class="headerlink" title="1. @EnableEurekaClient 和 @EnableDiscoveryClient注解"></a>1. @EnableEurekaClient 和 @EnableDiscoveryClient注解</h4><p>注解 @EnableEurekaClient上有 @EnableDiscoveryClient注解<br>1). @EnableDiscoveryClient注解是基于spring-cloud-commons依赖，并且在classpath中实现；<br>2). @EnableEurekaClient注解是基于spring-cloud-netflix依赖，只能为eureka作用；<br>如果你的classpath中添加了eureka，则它们的作用是一样的。</p><h4 id="2-Feign熔断"><a href="#2-Feign熔断" class="headerlink" title="2. Feign熔断"></a>2. Feign熔断</h4><pre><code class="hljs">application.ymlfeign:    hystrix:        enabled: true</code></pre><p>SpringBootApplication类名上添加</p><pre><code class="hljs">@EnableHystrix  </code></pre><p>EurekaClientFeign 方法上添加</p><pre><code class="hljs">@FeignClient(value = &quot;demo-client&quot;, configuration = FeignConfig.class, fallback = UserServiceHystrix.class)</code></pre><p>UserServiceHystrix 实现 EurekaClientFeign</p><p>若</p><pre><code class="hljs">@Configurationpublic class FeignConfig &#123;@Beanpublic Retryer feignRetryer() &#123;//        return new Retryer.Default();      return Retryer.NEVER_RETRY;  &#125;</code></pre><p>則EurekaClientFeign接口的@FeignClient中的configuration必須是FeignConfig.class<br>否則可以不填，或者指定為configuration &#x3D; FeignClientConfiguration.class  </p><h4 id="3-Ribbon-与-Hystrix"><a href="#3-Ribbon-与-Hystrix" class="headerlink" title="3. Ribbon 与 Hystrix"></a>3. Ribbon 与 Hystrix</h4><ul><li>添加  <ul><li>pom.xml  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>SpringBoot 启动类    <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@EnableHystrix</span><br></code></pre></td></tr></table></figure></li><li>需要熔断方法上面  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@HystrixCommand(fallbackMethod = <span class="hljs-string">&quot;error&quot;</span>)</span><br></code></pre></td></tr></table></figure>  注意error方法的参数要与原方法的参数一致，返回类型一致</li></ul></li></ul><h4 id="4-出错信息：com-netflix-turbine-monitor-instance-InstanceMonitor-MisconfiguredHostException-“timestamp”-”2018-09-30T08-19-23-837-0000”-”status”-404-”error”-”Not-Found”-”message”-”No-message-available”-”path”-”-x2F-hystrix-stream”"><a href="#4-出错信息：com-netflix-turbine-monitor-instance-InstanceMonitor-MisconfiguredHostException-“timestamp”-”2018-09-30T08-19-23-837-0000”-”status”-404-”error”-”Not-Found”-”message”-”No-message-available”-”path”-”-x2F-hystrix-stream”" class="headerlink" title="4. 出错信息：com.netflix.turbine.monitor.instance.InstanceMonitor$MisconfiguredHostException: [{“timestamp”:”2018-09-30T08:19:23.837+0000”,”status”:404,”error”:”Not Found”,”message”:”No message available”,”path”:”&#x2F;hystrix.stream”}]"></a>4. 出错信息：com.netflix.turbine.monitor.instance.InstanceMonitor$MisconfiguredHostException: [{“timestamp”:”2018-09-30T08:19:23.837+0000”,”status”:404,”error”:”Not Found”,”message”:”No message available”,”path”:”&#x2F;hystrix.stream”}]</h4><p>查看 turbine 配置文件中是否缺少 turbine.instanceUrlSuffix &#x3D; XX&#x2F;hystrix.stream<br>是否与 app-config 中的 client 的配置文件中配置的相同<br>换句话说，如果 client 中配置了 management.endpoints.web.exposure &#x3D; “hystrix.stream”, 则 XX为 actuator; 如果 client 配置了 public ServletRegistrationBean getServlet(), 则 turbine.instanceUrlSuffix &#x3D; hystrix.stream。<br>需要注意的是集群中的 client 需要一致  </p><h4 id="5-Zuul-的-EnableZuulServer-注解与-EnableZuulProxy-的区别"><a href="#5-Zuul-的-EnableZuulServer-注解与-EnableZuulProxy-的区别" class="headerlink" title="5. Zuul 的 @EnableZuulServer 注解与 @EnableZuulProxy 的区别"></a>5. Zuul 的 @EnableZuulServer 注解与 @EnableZuulProxy 的区别</h4><p>@EnableZuulServer 注解是高配版本<br>@EnableZuulProxy 注解是低配版本<br>如果不想让高版本多出的过滤器生效，可用低配版本注解<br>低配版本注解更适合自定义过滤器，因为经过的过滤器少，性能会比较高<br>@EnableZuulProxy 添加了对 Ribbo 和 Hystrix 支持  </p><p>RequestContext：用于在过滤器之间传递上下文，如：请求路由到哪里、错误、HttpServletRequest、HttpServletResponse，数据保存在每个请求的ThreadLocal中。  </p><hr><h4 id="6-Jwt"><a href="#6-Jwt" class="headerlink" title="6. Jwt"></a>6. Jwt</h4><p><strong>1. Jwt 的原则</strong>  </p><p>是在服务器身份验证之后，将生成一个 Json 对象并将其发送回用户；<br>之后，当用户与服务器通信时，客户在请求中发回 JSON 对象。服务器仅依赖于这个 JSON 对象来标识用户。<br>为了防止用户篡改数据，服务器将在生成对象时添加签名。  </p><p>服务器不保存任何对话数据，即服务器变为无状态，使其更容易扩展。  </p><p><strong>2. Jwt 的数据结构</strong></p><p>很长的字符串，字符之间通过分隔符 “.” 分为3个子串<br>三个部分如下：  </p><ul><li><p>JWT 头部<br>  是一个描述 JWT 元数据的 JSON 对象  </p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br><span class="hljs-string">&quot;alg&quot;</span>: <span class="hljs-string">&quot;HS256&quot;</span>, <span class="hljs-regexp">//</span> alg属性表示签名使用的算法，默认为HMAC SHA256（写为HS256)<br><span class="hljs-string">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span>   <span class="hljs-regexp">//</span> typ属性表示令牌的类型，JWT令牌统一写为JWT。<br>&#125;  <br></code></pre></td></tr></table></figure><p>  使用 Base64 URL 算法将上述 JSON 对象转换为字符串保存  </p></li><li><p>有效载荷  </p><p>  JWT的主体内容部分，也是一个 JSON 对象，包含需要传递的数据。  </p><p>  指定七个默认字段供选择：<br>  iss: 发行人<br>  exp: 到期时间<br>  sub: 主题<br>  aud: 用户<br>  nbf: 在此之前不可用<br>  iat: 发布时间<br>  jti: JWT ID 用于标识该 JWT<br>  还可以自定义私用字段  </p><p>  默认情况下 JWT 是为加密的，任何人都可以解读其内容，因此不要构建隐私信息字段，存放保密信息，以防止信息泄露  </p><p>  也使用 Base64 URL 算法转换为字符串保存  </p></li><li><p>签名哈希  </p><p>  对上面两部分数据签名，通过指定的算法生成哈希，以确保数据不会被篡改。  </p><p>  首先，需要指定一个密码，该密码仅仅为保存在服务器中，并不能向用户公开。<br>  然后，使用标头中指定的签名算法（默认情况下为 HMAC SHA256）根据以下公式生成签名：<br>  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">HMACSHA256(<span class="hljs-params">base64UrlEncode</span>(<span class="hljs-params">header</span>)</span> + <span class="hljs-string">&quot;.&quot;</span> + base64<span class="hljs-constructor">UrlEncode(<span class="hljs-params">payload</span>)</span>, secret)<br></code></pre></td></tr></table></figure></p></li></ul><p>在计算出签名哈希后，JWT 头、有效载荷和签名哈希的三个部分用分隔符“.”连接组合成一个字符串。构成整个 JWT 对象。</p><p><strong>3. JWT 的用法</strong>  </p><p>客户端接收服务器返回的JWT，将其存储在 Cookie 或 localStorage 中。  </p><p>此后，客户端将在与服务器交互中都会带 JWT。如果将它存储在 Cookie 中，就会自动发送，但是不会跨域，因此一般是将它放入到 HTTP 请求的 Header Authorization 字段中。  </p><p>当跨域时，也可以将 JWT 放置于 POST 请求的数据主体中。  </p><hr><h4 id="7-跨域"><a href="#7-跨域" class="headerlink" title="7. 跨域"></a>7. 跨域</h4><p>浏览器从一个域名的网页去请求另一个域名的资源时，端口、域名、协议任一不同，都是跨域。  </p><p><a href="http://www.nealyang.cn/index.html">http://www.nealyang.cn/index.html</a> 调用   <a href="http://www.nealyang.cn/server.php">http://www.nealyang.cn/server.php</a>  非跨域<br><a href="http://www.nealyang.cn/index.html">http://www.nealyang.cn/index.html</a> 调用   <a href="http://www.neal.cn/server.php">http://www.neal.cn/server.php</a>  跨域, 主域不同<br><a href="http://www.666.baidu.com/index.html">http://www.666.baidu.com/index.html</a> 调用 <a href="http://www.555.baidu.com/test.js">http://www.555.baidu.com/test.js</a>   跨域, 子域名不同<br><a href="http://www.nealyang.cn:8080/index.html">http://www.nealyang.cn:8080/index.html</a> 调用   <a href="http://www.nealyang.cn/server.php">http://www.nealyang.cn/server.php</a> 跨域, 端口不同<br><a href="https://www.nealyang.cn/index.html">https://www.nealyang.cn/index.html</a> 调用   <a href="http://www.nealyang.cn/server.php">http://www.nealyang.cn/server.php</a>  跨域, 协议不同<br>localhost   调用 127.0.0.1 跨域  </p><hr><h4 id="8-域名"><a href="#8-域名" class="headerlink" title="8. 域名"></a>8. 域名</h4><p><strong>1. URL 构成</strong>  </p><p><strong>protocol:&#x2F;&#x2F;hostname[post]&#x2F;path&#x2F;[;parameters][?query]#fragment</strong>  </p><ul><li>protocol 协议，常用的协议是http  </li><li>hostname 主机地址，可以是域名，也可以是IP地址  </li><li>port 端口 http协议默认端口是： 80 端口，如果不写默认就是: 80 端口  </li><li>path 路径 网络资源在服务器中的指定路径  </li><li>parameter 参数 如果要向服务器传入参数，在这部分输入  </li><li>query 查询字符串 如果需要从服务器那里查询内容，在这里编辑  </li><li>fragment 片段 网页中可能会分为不同的片段，如果想访问网页后直接到达指定位置，可以在这部分设置</li></ul><p><strong>2. 域名</strong>  </p><p>一个完整的域名由二个或二个以上部分组成，各部分之间用英文 的句号”.”来分隔。  </p><p>例如下列域名： yahoo.com， yahoo.ca.us， yahoo.co.uk。  </p><p>其中第一个域名由二部分组成，第二个域名和第三个域名由 三部分 组成。  </p><p>在一个完整的域名中， 最后一个”.”的右边部分称为顶级域名或一 级域名（TLD） ，在上面的域名例子中，com、us 和 uk 是顶级域名。<br>最后一个”.”的左边部分称为二级域名（SLD） ，例如，域名 yahoo.com 中 yahoo 是 二级域名，域名 yahoo.ca.us 中 ca<br>是二级域名，而域名 yahoo.co.uk 中 co 是二级域名。<br>二级域名的左边部分称 为三级域名。<br>三级域名的左边部分称为四级域名， 以此类推。 例如， 域名 yahoo.ca.us 和 yahoo.co.uk 中 yaho o 是三级域名。  </p><hr><h4 id="9-OAuth2-和-SSO（单点登录）"><a href="#9-OAuth2-和-SSO（单点登录）" class="headerlink" title="9. OAuth2 和 SSO（单点登录）"></a>9. OAuth2 和 SSO（单点登录）</h4><p>OAuth2: 解决的是服务提供方（微信等）给第三方应用授权的问题<br>SSO: 解决的是大型系统中各个子系统如何共享登录状态的问题  </p><p>两者都是基于分布式系统，涉及到多个角色，但是不同的是，oauth2 是一种具体的协议，sso 可以说是一种技术，可以用 cookie 实现，甚至也可以用 oauth2 实现（虽然不是很好），比如 oauth 中的服务提供方可以充当 sso 认证中心，oauth 中的第三方应用也可以是 sso 中的子系统。  </p><p>SSO是为了解决一个用户在鉴权服务器登陆过一次以后，可以在任何应用中畅通无阻，一次登陆，多系统访问，操作用户是实打实的该应用的官方用户，用户的权限和分域以鉴权服务器的存储为准。<br>OAuth2.0解决的是通过令牌获取某个系统的操作权限，因为有clientId的标识，一次登陆只能对该系统生效，第三方应用的操作用户不是鉴权系统的官方用户，授权权限鉴权中心可以做限制。<br>原文：<a href="https://blog.csdn.net/yejingtao703/article/details/78847471">https://blog.csdn.net/yejingtao703/article/details/78847471</a>  </p><ul><li>单点登录原理：<a href="http://www.cnblogs.com/markleilei/p/6201665.html">http://www.cnblogs.com/markleilei/p/6201665.html</a>  </li><li>oauth2 详解：<a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html</a></li></ul><p>学习资料：<br><a href="http://www.zhenchao.org/2017/03/04/oauth-v2-principle/">http://www.zhenchao.org/2017/03/04/oauth-v2-principle/</a>  </p><hr><h4 id="10-如何获取client-id"><a href="#10-如何获取client-id" class="headerlink" title="10. 如何获取client_id"></a>10. 如何获取client_id</h4><p>这个需要第三方应用（这里就是慕课网）提前去服务提供商那（这里就是 QQ 服务器）里申请这种 Oauth 应用。提前申请好，提前商量好，然后 QQ 服务器就会给慕课网一个代表身份认证的东西，这里就是 client_id, client_secret 了。  </p><p>因为除了慕课网可以去 QQ 服务器申请 Oauth 登录，那央视网，百度网址，任何其他合法的网站都可以去 QQ 服务器申请使用 Oauth 服务，那 QQ 服务器为了管理这些第三方们，所以给它们每个网站都分配一个标识，比如 client_id &#x3D; 999 代表是慕课网，client_id &#x3D; 3306 是百度网站。当然还会分配 client_secret。  </p><p>所以，client_id, client_secret 是 QQ 服务器给的。第三方（慕课网）需要提前去 QQ 服务器那申请。如何申请，需要什么资质，看 QQ 的相关文档介绍就行了</p><hr><h4 id="11-由于安全认证，Eureka-服务连不上注册中心"><a href="#11-由于安全认证，Eureka-服务连不上注册中心" class="headerlink" title="11. 由于安全认证，Eureka 服务连不上注册中心"></a>11. 由于安全认证，Eureka 服务连不上注册中心</h4><p>security默认启用了csrf检验，要在eureka服务端那边配置security的csrf检验为false  </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-meta">@EnableWebSecurity</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebSecurityConfigurer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebSecurityConfigurerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void configure(<span class="hljs-type">HttpSecurity</span> http) <span class="hljs-keyword">throws</span> <span class="hljs-type">Exception</span> &#123;<br>        http.csrf().disable();<br>        <span class="hljs-keyword">super</span>.configure(http);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Grape 是一个内嵌在 Groovy 里的 Jar 包依赖管理器。Grape 让你可以快速添加 maven 仓库依赖到你的 classpath 里，使脚本运行更加简单。最简单的一种用法是只需要在你的脚本里添加一个注解：<br><code>@Grab(group=&#39;org.springframework&#39;, module=&#39;spring-orm&#39;, version=&#39;3.2.5.RELEASE&#39;)</code><br>@Grab 也支持简洁版：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">Grab(&#x27;<span class="hljs-params">org</span>.<span class="hljs-params">springframework</span>:<span class="hljs-params">spring</span>-<span class="hljs-params">orm</span>:3.2.5.RELEASE&#x27;)</span><br>import org.springframework.jdbc.core.JdbcTemplate<br></code></pre></td></tr></table></figure><h4 id="12-Zuul-配置项中-sensitiveHeaders-和-ignoredHeaders-的不同"><a href="#12-Zuul-配置项中-sensitiveHeaders-和-ignoredHeaders-的不同" class="headerlink" title="12. Zuul 配置项中 sensitiveHeaders 和 ignoredHeaders 的不同"></a>12. Zuul 配置项中 sensitiveHeaders 和 ignoredHeaders 的不同</h4><p>spring cloud netflix 组件 zuul 一般是用来作为网关服务开发，在涉及到转发路由的时候，zuul 会改写 request 中的头部信息。那么怎么样在项目中配置呢？请看下面：  </p><p>sensitiveHeaders 会过滤客户端附带的 headers<br>例如：<code>zuul.sensitiveHeaders=Cookie,Set-Cookie</code>  </p><p>如果客户端在发请求是带了Cookie，那么 Cookie 不会传递给下游服务。  </p><p>默认：<code>zuul.sensitiveHeaders=</code>  </p><p>什么都不设置代表不过滤任何信息，但 <code>zuul.sensitiveHeaders=</code>一定要附上。  </p><p>zuul.ignoredHeaders 会过滤服务之间通信附带的 headers<br>例如：zuul.ignoredHeaders &#x3D; Cookie,Set-Cookie<br>如果客户端在发请求是带了 Cookie，那么 Cookie 依然会传递给下游服务。但是如果下游服务再转发就会被过滤。作用与上面敏感的 Header 差不多，事实上 sensitive-headers 会被添加到 ignored-headers 中。  </p><p>还有一种情况就是客户端带了 Cookie，在 ZUUL 的 Filter 中有 addZuulRequestHeader(“Cookie”, “new”),<br>那么客户端的 Cookie 将会被覆盖，此时不需要 sensitiveHeaders。  </p><p>如果设置了 sensitiveHeaders: Cookie，那么 Filter 中设置的 Cookie 依然不会被过滤。  </p><p>原文：<a href="https://blog.csdn.net/ahutdbx/article/details/84192573">https://blog.csdn.net/ahutdbx/article/details/84192573</a>  </p><h4 id="13-SpringBoot-使用feign时报错Service-id-not-legal-hostname"><a href="#13-SpringBoot-使用feign时报错Service-id-not-legal-hostname" class="headerlink" title="13. SpringBoot 使用feign时报错Service id not legal hostname"></a>13. SpringBoot 使用feign时报错Service id not legal hostname</h4><p>feign 不支持下划线 “_”，支持 “-“, 改成 xx-sss 即可  </p><hr><h3 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h3><p>学习 Spring Cloud 的博客： <a href="https://windmt.com/">https://windmt.com/</a></p><p><a href="https://gitee.com/owenwangwen/open-capacity-platform.git">https://gitee.com/owenwangwen/open-capacity-platform.git</a></p><p><a href="https://github.com/fp2952/spring-cloud-base">https://github.com/fp2952/spring-cloud-base</a></p><p><a href="https://gitee.com/owenwangwen/open-capacity-platform/tree/master">https://gitee.com/owenwangwen/open-capacity-platform/tree/master</a></p><hr><p><code>keytool -genkeypair -alias mytest -keyalg RSA -keypass mypass -keystore keystore.jks -storepass mypass</code></p><p>JKS 密钥库使用专用格式。建议使用 “keytool -importkeystore -srckeystore keystore.<br>jks -destkeystore keystore.jks -deststoretype pkcs12” 迁移到行业标准格式 PKCS12<br>。  </p><p><code>keytool -export -alias mytest -keystore keystore.jks -file pubkey.txt -rfc</code>: 导出公钥<br>在导出证书时加上-rfc参数则可以使用一种可打印的编码格式来保存证书，否则是二进制文件，有些内容无法显示  </p><hr><p>1、什么是跨域Web SSO:  </p><p>域名通过“.”号切分后，从右往左看，不包含”.”的是顶级域名,包含一个”.”的是一级域名，包含两个”.”的是二级域名，依次类推。  </p><p><a href="https://www.baidu.com:com是顶级域名，baidu.com是一级域名，www.baidu.com是二级域名。">https://www.baidu.com:com是顶级域名，baidu.com是一级域名，www.baidu.com是二级域名。</a>  </p><p>2、浏览器读写cookie的安全性限制：一级或顶级域名不同的网站，无法读取到彼此写的cookie  </p><p>一级域名相同，只是二级或更高级域名不同的站点，可以通过设置domain参数共享cookie的读写。这种场景可以选择不跨域的SSO方案  </p><p>域名相同，只是https和http协议不同的URL默认cookie可以共享。  </p><p>3、http协议是无状态协议，浏览器访问服务器时，要让服务器知道你是谁，只有两种方式：  </p><p>1）将信息写入cookie，它会随着每次HTTP请求带到服务端  </p><p>2）在URL、表单数据中带上用户信息（也可能在HTTP头部）。这种方式依赖于从特定的网页入口进入，因为只有走特定的入口，才有机会拼装出相应的信息，提交到服务端。  </p><hr><p>iperf 单节点系统吞吐量测试软件</p><hr><p>采用Zuul网关和Spring Security搭建一个基于JWT的全局验证架构<br><a href="https://github.com/shuaicj/zuul-auth-example">https://github.com/shuaicj/zuul-auth-example</a>  </p><p>central-platform简称CP，基于Spring Cloud(Finchley.SR1) 、Spring Boot(2.0.1)、Spring Security jwt开发 基于layui前后分离的开发平台,其中包括Gateway网关、Oauth认证服务、User用户服务、 Eureka注册中心等多个服务, 为微服务开发所需配置管理、服务发现、断路器、智能路由、 微代理等,努力为企业级打造最全面的微服务开发解决方案;<br><a href="https://gitee.com/GeekPerson/central-platform">https://gitee.com/GeekPerson/central-platform</a>  </p><p>FCat项目基于 Angular 4 + Spring Cloud 的企业级基础功能框架 全栈必备<br><a href="https://gitee.com/xfdm/FCat">https://gitee.com/xfdm/FCat</a></p><p>慕课网正在学习中的项目<br><a href="https://gitee.com/krui/tiger-security">https://gitee.com/krui/tiger-security</a>  </p><p>蘑菇博客，一个基于微服务架构的前后端分离博客系统。前台使用 Vue +Element , 后端使用spring boot + spring cloud + mybatis-plus进行开发<br><a href="https://gitee.com/moxi159753/mogu_blog_v2">https://gitee.com/moxi159753/mogu_blog_v2</a>  </p><p>一个基于SpringBoot 2的管理后台系统<br><a href="https://gitee.com/xiandafu/springboot-plus">https://gitee.com/xiandafu/springboot-plus</a>  </p><p>spring-cloud2-demo<br><a href="https://github.com/RuvikVan/spring-cloud2-demo">https://github.com/RuvikVan/spring-cloud2-demo</a>  </p><p>登录对比：cas（单点登录）；oauth2（授权）；单一登录的区别<br><a href="http://375287760.iteye.com/blog/2400976">http://375287760.iteye.com/blog/2400976</a>  </p><p>SpringCloud 学习研究项目，内部包含相关的一整套信息。<br><a href="https://gitee.com/cmlbeliever/springcloud/tree/master/">https://gitee.com/cmlbeliever/springcloud/tree/master/</a> </p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><h4 id="一、bootstrap-yml（bootstrap-properties）"><a href="#一、bootstrap-yml（bootstrap-properties）" class="headerlink" title="一、bootstrap.yml（bootstrap.properties）####"></a>一、bootstrap.yml（bootstrap.properties）####</h4><p>bootstrap.yml（bootstrap.properties）用来程序引导时执行，应用于更加早期配置信息读取，如可以使用来配置 application.yml 中使用到参数等</p><p>application.yml（application.properties) 应用程序特有配置信息，可以用来配置后续各个模块中需使用的公共参数等。</p><p>bootstrap.yml 先于 application.yml 加载</p><p>bootstrap.yml 可以理解成系统级别的一些参数配置，这些参数一般是不会变动的。<br>application.yml 可以用来定义应用级别的，如果搭配 spring-cloud-config 使用 application.yml 里面定义的文件可以实现动态替换。</p><p>使用Spring Cloud Config Server时，应在 bootstrap.yml 中指定：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">spring<span class="hljs-selector-class">.application</span><span class="hljs-selector-class">.name</span><br>spring<span class="hljs-selector-class">.cloud</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.server</span><span class="hljs-selector-class">.git</span><span class="hljs-selector-class">.uri</span><br>一些加密/解密信息<br></code></pre></td></tr></table></figure><blockquote><p>注意：一旦bootStrap.yml 被加载，则内容不会被覆盖，即便后期加载的application.yml的内容标签与bootstrap的标签一致，application 也不会覆盖bootstrap, 而application.yml 里面的内容可以动态替换。</p></blockquote><p>推荐在<code>bootstrap.yml</code> or <code>application.yml</code>里面配置<code>spring.application.name</code>. 你可以通过设置<code>spring.cloud.bootstrap.enabled=false</code>来禁用<code>bootstrap</code>。</p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Spring Cloud</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一本Docker书 阅读笔记</title>
    <link href="/2023/12/31/docker/%E7%AC%AC%E4%B8%80%E6%9C%AC%20Docker%20%E4%B9%A6%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/31/docker/%E7%AC%AC%E4%B8%80%E6%9C%AC%20Docker%20%E4%B9%A6%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>容器的命名必须是唯一的。<br>很多docker 命令中，都可以用容器的名称来替代容器ID。<br>合法的容器的名称只能包含大小写字母，下划线，圆点，横线即（[a-zA-Z.<em>-</em>]）</p><p><code>docker -v | --version</code>： 查看版本  </p><p><code>docker container ls</code>： 查看所有当前运行的容器<br><code>docker container ls -l</code>： 查看最新创建的一条容器，包含所有状态<br><code>docker container ls -a</code>： 这将列出任何状态的容器，无论是创建，运行还是退出<br><code>docker container ls -q</code>： 列出所有容器的ID<br><code>docker ps -n x</code>： 显示最后x个容器，无论是否运行  </p><p><code>docker ps</code>命令默认情况下仅显示运行容器。 要查看所有容器，请使用<code>-a</code>(或<code>--all</code>)标志<br>过滤标志(<code>-f</code>或<code>--filter</code>)格式是<code>key = value</code>对。如果有多个过滤器，则传递多个标志(例如<code>--filter “foo = bar” --filter “bif = baz”</code>)<br><code>docker ps --filter &#39;exited=0&#39;</code><br><code>docker ps --filter &#39;name=demo&#39;</code>  </p><p><code>docker inspect</code>： 返回其配置信息  </p><p><code>docker container rm </code>： 删除容器。如果要强制删除正在运行的程序，可以使用命令行参数 -f 或 -force。<br><code>docker rm</code>： 删除容器  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker rm `docker ps -<span class="hljs-selector-tag">a</span> -<span class="hljs-selector-tag">q</span>`<br></code></pre></td></tr></table></figure><p>删除所有容器  </p><p><code>docker start</code> || <code>docker restart</code>： 启动容器  </p><p><code>docker attach</code>： 重新附着到容器的会话，沿用docker run命令时指定的参数来运行，容器必须运行；连接到正在运行中的容器，可以同时连接上同一个container来共享屏幕（与screen命令的attach类似）；退出后，docker容器也退出<br><code>docker exec</code>： 在运行的容器中执行命令，退出后，docker 容器继续运行，容器后必须紧跟 命令，默认-d(分离模式)  </p><p><code>docker top</code>： 查看容器中运行的进程信息，支持 ps 命令参数。<br><code>docker logs 容器名|ID</code>： 获取容器的日志，查看容器内部的运行  </p><ul><li>-f : 跟踪日志输出, ctrl + c 退出日志跟踪  </li><li>–since :显示某个开始时间的所有日志  </li><li>-t : 显示时间戳  </li><li>–tail :仅列出最新N条容器日志</li></ul><p><code>docker stop</code>： 停止容器<br><code>docker kill</code>： 快速停止容器  </p><p><code>docker run</code>  </p><ul><li><code>--restart</code>： <ul><li>no – 是默认策略，在任何情况下都不会restart容器  </li><li>on-failure[:max-retries] – 只在容器以非0状态码退出时重启。可选的，可以退出 docker daemon 尝试重启容器的次数。<br>  好处是：如果容器以正常 exit code 终止，将不会 restart  </li><li>always – 不管退出状态码是什么始终重启容器。<br>  当指定 always 时，docker daemon 将无限次数地重启容器。容器也会在 daemon 启动时尝试重启，不管容器当时的状态如何。<br>  列举几个场景：  <ul><li>容器以非正常状态码终止(如应用内存不足导致终止)  </li><li>容器被正常 stopped，然后机器重启或Docker服务重启  </li><li>容器在宕机在正常运行，然后重启机器或Docker服务重启</li></ul></li><li>unless-stopped – 和 always 基本一样，只有一个场景 unless-stopped 有点特殊：<br>  如果容器正常 stopped，然后机器重启或 docker 服务重启，这种情况下容器将不会被 restart</li></ul></li></ul><p>&#x2F;var&#x2F;lib&#x2F;docker 目录存放 Docker 镜像、容器以及容器的配置<br>&#x2F;var&#x2F;lib&#x2F;docker&#x2F;containers 目录存放所有的容器</p><p>SIGKILL ： 发送一个进程导致立即杀死  </p><hr><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>用来启动容器的构建基石  </p><p><code>docker images</code>： 列出镜像</p><p><code>docker run</code>： 从镜像启动一个容器时，如果镜像不再本地，从 Docker Hub 下载该镜像。如果没有指定具体的镜像标签，会自动下载 latest标签的镜像<br><code>docker pull</code>： 预先拉取镜像到本地。节省从一个镜像启动一个容器所需的时间。未指定具体的镜像标签，会自动下载 latest  </p><p><code>docker search</code>： 查找镜像  </p><p><code>docker build [OPTIONS] PATH | URL | -</code>： 用于使用 Dockerfile 创建镜像<br>使用当前目录的 Dockerfile 创建镜像，标签为 runoob&#x2F;ubuntu:v1。  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">docker</span> build -t runoob/ubuntu:<span class="hljs-built_in">v1</span> . <br></code></pre></td></tr></table></figure><p>使用URL github.com&#x2F;creack&#x2F;docker-firefox 的 Dockerfile 创建镜像。  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker build github.com<span class="hljs-regexp">/creack/</span>docker-firefox<br></code></pre></td></tr></table></figure><p>也可以通过 -f Dockerfile 文件的位置,文件的名称：  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ docker build -f <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/a/</span>Dockerfile .<br></code></pre></td></tr></table></figure><p>ubuntu 镜像，实际上并不是一个完整的操作系统，只是一个裁剪版，只包含最低限度的支持系统运行的组件  </p><p><strong>构建容器时指定仓库的标签</strong>  </p><p><code>docker port 容器 [端口]</code>： 查看容器的端口映射情况  </p><p><code>docker run</code>：  </p><ul><li>-p： Docker 在运行时应该公开哪些端口给外部（宿主机）。<br>  灵活管理容器和宿主机之间的端口映射。<br>  分配端口：  <ol><li>随机选择49153~65535的一个端口来映射  </li><li>指定一个具体的端口号来映射<br><code>docker run -d -p --name demo dy/container:tag \nginx -g &quot;daemon off;&quot;</code><br><code>docker run -d -p 127.0.0.1:80:80 --name demo dy/container:tag \nginx -g &quot;daemon off;&quot;</code><br><code>docker run -d -p 127.0.0.1::80 --name demo dy/container:tag \nginx -g &quot;daemon off;&quot;</code>： 只指定了一个 IP 地址</li></ol></li><li>-P ： 该参数可以用来对外公开在Dockerfile 中的 EXPOSE 指令中设置的所有端口。</li></ul><p><code>docker images -f reference=&quot;*/static_web:v*</code><br><strong>DockerFile 指令</strong>  </p><ul><li><strong>FROM</strong></li><li><strong>MAINTAINER</strong>  </li><li><strong>RUN</strong>  </li><li><strong>CMD</strong><br>  用于制定一个 <em>容器启动</em> 时要运行的命令<br>  类似于 RUN 指令，只是 RUN 指令是指定 <em>镜像被构建</em> 时要运行的命令<br>  和 <code>docker run</code> 命令启动容器时指定要运行的命令非常类似。<br>  要运行的命令存放在一个数组结构中，不使用数组指定 cmd 指令，Docker 会在指定的命令前加上 &#x2F;bin&#x2F;sh -c。<br>  docker run 命令可以覆盖 cmd 指令<br>  只能指定一条 CMD 指令。如果指定多条，只会使用最后一条。  </li><li><strong>ENTRYPOINT</strong><br>  指令与 CMD 相似，但提供的命令则不易在启动容器时被覆盖。<br>  docker run 命令行中指定的任何参数都会被当做参数再次传递给 ENTRYPOINT 指令中指定的命令。<br>  如果 docker run 中没有参数，CMD 指令中的指定的参数会被传递给 ENTRYPOINT。<br>  可以在运行时通过 docker run 的 –entrypoint 标识覆盖 ENTRYPOINT 中的参数。<br>  ENTRYPOINT [“curl”, “-s”] &#x2F;&#x2F; 注意一定要双引号，一定要安装相对应的命令如 curl  </li><li><strong>WORKDIR</strong>  </li><li><strong>ENV</strong>  </li><li><strong>ADD</strong><br>  <a href="https://docs.docker.com/engine/reference/builder/#add">https://docs.docker.com/engine/reference/builder/#add</a><br>  将主机构建环境（上下文）目录中的文件和目录、以及一个 URL 标记的文件拷贝到镜像中。  <ol><li>如果源路径是个文件，且目标路径是以 &#x2F; 结尾， 则docker会把目标路径当作一个目录，会把源文件拷贝到该目录下。如果目标路径不存在，则会自动创建目标路径。  </li><li>如果源路径是个文件，且目标路径是不是以 &#x2F; 结尾，则docker会把目标路径当作一个文件。如果目标路径不存在，会以目标路径为名创建一个文件，内容同源文件；如果目标文件是个存在的文件，会用源文件覆盖它，当然只是内容覆盖，文件名还是目标文件名。如果目标文件实际是个存在的目录，则会源文件拷贝到该目录下。 注意，这种情况下，最好显示的以 &#x2F; 结尾，以避免混淆。  </li><li>如果源路径是个目录，且目标路径(无论是否以&#x2F;结尾)不存在，则docker会自动以目标路径创建一个目录，把源路径目录下的文件拷贝进来。如果目标路径是个已经存在的目录，则docker会把源路径目录下的文件拷贝到该目录下。  </li><li>如果源文件是个归档文件（压缩文件），则docker会自动帮解压。</li></ol></li><li><strong>COPY</strong><br>  类似 ADD，但不会去做文件提取和解压的工作  </li><li><strong>ONBUILD</strong><br>  并不会在自己的构建中执行</li></ul><p>wget <a href="https://github.com/turnbullpress/dockerbook-code/blob/master/code/5/sample/nginx/global.conf">https://github.com/turnbullpress/dockerbook-code/blob/master/code/5/sample/nginx/global.conf</a><br>wget <a href="https://github.com/turnbullpress/dockerbook-code/blob/master/code/5/sample/nginx/nginx.conf">https://github.com/turnbullpress/dockerbook-code/blob/master/code/5/sample/nginx/nginx.conf</a>  </p><p><strong>使用 Docker 测试静态网站</strong>  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>. mkdir sample<br><span class="hljs-number">2</span>. cd mkdir<br><span class="hljs-number">3</span>. touch Dockerfile<br><span class="hljs-number">4</span>. vi Dockerfile  <br>    FROM ubuntu<br>    MAINTAINER DY<br>    ENV REFRESHED_AT <span class="hljs-number">2018</span><span class="hljs-regexp">/11/</span><span class="hljs-number">16</span><br>    RUN apt-get update<br>    RUN apt-get -y -q install nginx<br>    RUN mkdir <span class="hljs-regexp">/var/</span>www/html<br>    ADD nginx<span class="hljs-regexp">/global.conf /</span>ect<span class="hljs-regexp">/nginx/</span>conf.d/<br>    ADD nginx<span class="hljs-regexp">/nginx.conf /</span>ect<span class="hljs-regexp">/nginx/</span><br>    EXPOSE <span class="hljs-number">80</span><br><span class="hljs-number">5</span>. cd &amp;&amp; cd sample<br><span class="hljs-number">6</span>. mkdir nginx<br><span class="hljs-number">7</span>. cd nginx &amp;&amp; touch global.conf &amp;&amp; touch nginx.conf<br><span class="hljs-number">8</span>. vi global.conf<br>    server &#123;<br>        listen          <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">80</span>;<br>        server_name     _;<br><br>        root            <span class="hljs-regexp">/var/</span>www<span class="hljs-regexp">/html/</span>website;<br>        index           index.html index.htm;<br><br>        access_log      <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_access.log;<br>        error_log       <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>default_error.log;<br>    &#125;<br><span class="hljs-number">9</span>. vi nginx.conf<br>    user www-data; <span class="hljs-comment"># 最好修改为 root，否则可能出现 403，权限不足</span><br>    worker_processes <span class="hljs-number">4</span>;<br>    pid <span class="hljs-regexp">/run/</span>nginx.pid;<br>    daemon off;  <span class="hljs-comment"># 组织 Nginx 进入后台，强制其在前台运行  </span><br><br>    events &#123;  &#125;<br><br>    http &#123;<br>      sendfile on;<br>      tcp_nopush on;<br>      tcp_nodelay on;<br>      keepalive_timeout <span class="hljs-number">65</span>;<br>      types_hash_max_size <span class="hljs-number">2048</span>;<br>      include <span class="hljs-regexp">/etc/</span>nginx/mime.types;<br>      default_type application/octet-stream;<br>      access_log <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>access.log;<br>      error_log <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/nginx/</span>error.log;<br>      gzip on;<br>      gzip_disable <span class="hljs-string">&quot;msie6&quot;</span>;<br>      include <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span>*.conf;<br>    &#125;<br><span class="hljs-number">10</span>. cd sample<br><span class="hljs-number">11</span>. docker build -t dy/nginx:v1.<span class="hljs-number">1</span> .<br><span class="hljs-number">12</span>. docker run -d -p <span class="hljs-number">8800</span>:<span class="hljs-number">80</span> --name website -v <span class="hljs-variable">$PWD</span><span class="hljs-regexp">/website/</span>:var<span class="hljs-regexp">/www/</span>html<span class="hljs-regexp">/website dy/</span>nginx:v1.<span class="hljs-number">1</span> nginx<br><span class="hljs-comment"># -v 将宿主机的目录作为卷，挂载到容器里</span><br><span class="hljs-comment"># PWD 显示当前路径</span><br></code></pre></td></tr></table></figure><p><strong>使用 Docker 构建并测试 web 应用程序</strong></p><ul><li><strong>构建 Sinatra 应用程序</strong></li></ul><ol><li><p>mkdir sinatra  </p></li><li><p>touch Dockerfile  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> ubuntu:18.04<br>LABEL <span class="hljs-attribute">maintainer</span>=<span class="hljs-string">&quot;james@example.com&quot;</span><br>ENV REFRESHED_AT 2014-06-01<br><br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> -qq update &amp;&amp; apt-<span class="hljs-built_in">get</span> -qq install ruby ruby-dev build-essential redis-tools<br><span class="hljs-built_in">RUN</span> gem install --no-rdoc --no-ri sinatra json redis<br><br><span class="hljs-built_in">RUN</span> mkdir -p /opt/webapp<br><br>EXPOSE 4567<br><br>CMD [ <span class="hljs-string">&quot;/opt/webapp/bin/webapp&quot;</span> ]<br></code></pre></td></tr></table></figure></li><li><p>mkdir webapp &amp;&amp; cd webapp &amp;&amp; mkdir bin &amp;&amp; mkdir lib  </p></li><li><p>cd bin &amp;&amp; touch webapp &amp;&amp; vi webapp  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#!<span class="hljs-regexp">/usr/</span>bin/ruby<br><br>$:.unshift(<span class="hljs-keyword">File</span>.expand_path(<span class="hljs-keyword">File</span>.<span class="hljs-keyword">join</span>(<span class="hljs-keyword">File</span>.dirname(__FILE__), <span class="hljs-string">&quot;..&quot;</span>, <span class="hljs-string">&quot;lib&quot;</span>)))<br><br>require <span class="hljs-string">&#x27;app&#x27;</span><br><br>App.run!<br></code></pre></td></tr></table></figure></li><li><p>cd &#x2F;root&#x2F;sinatra&#x2F;webapp&#x2F;lib &amp;&amp; touch app.rb &amp;&amp; vi app.rb  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">require</span> <span class="hljs-string">&quot;rubygems&quot;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&quot;sinatra&quot;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&quot;json&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &lt; <span class="hljs-title class_ inherited__">Sinatra::Application</span><br><br>  set <span class="hljs-symbol">:bind</span>, <span class="hljs-string">&#x27;0.0.0.0&#x27;</span><br><br>  get <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-keyword">do</span><br>    <span class="hljs-string">&quot;&lt;h1&gt;DockerBook Test Sinatra app&lt;/h1&gt;&quot;</span><br>  <span class="hljs-keyword">end</span><br><br>  post <span class="hljs-string">&#x27;/json/?&#x27;</span> <span class="hljs-keyword">do</span><br>    params.to_json<br>  <span class="hljs-keyword">end</span><br><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p>cd &#x2F;root&#x2F;sinatra &amp;&amp; chmod +x $PWD&#x2F;webapp&#x2F;bin&#x2F;webapp<br>保证 webapp&#x2F;bin&#x2F;webapp 文件可执行  </p></li><li><p>docker build -t dy&#x2F;sinatra:v1.0 .  </p></li><li><p>docker run -d -p 4567 –name webapp -v $PWD&#x2F;webapp:&#x2F;opt&#x2F;webapp dy&#x2F;sinatra:v1.0<br>目前只是接受参数，并将输入转化为 JSON 输出。  </p></li><li><p>curl -i -H ‘Accept:application&#x2F;json’ -d ‘name&#x3D;foo&amp;status&#x3D;Bar’ localhost:32771&#x2F;json</p></li></ol><ul><li><p><strong>构建 Redis 镜像和容器</strong><br>两种方法：<br>  第一种：直接 docker pull redis<br>  第二种：Dockerfile, 以下步骤是 Dockerfile  </p><ol><li><p>cd &#x2F;root&#x2F;sinatra &amp;&amp; mkdir redis &amp;&amp; cd redis &amp;&amp; touch Dockerfile &amp;&amp; vi Dockerfile</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">FROM</span> ubuntu<br>MAINTAINER DY<br>ENV REFRESHED_AT 2018/11/21<br><br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> -y update &amp;&amp; apt-<span class="hljs-built_in">get</span> -y install redis-server redis-tools<br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> -y install vim<br><span class="hljs-built_in">RUN</span> apt-<span class="hljs-built_in">get</span> -y install inetutils-ping<br><br>EXPOSE 6379<br><br>ENTRYPOINT [<span class="hljs-string">&quot;/usr/bin/redis-server&quot;</span> ]<br>CMD []<br><br></code></pre></td></tr></table></figure></li><li><p>docker build -t dy&#x2F;redis:v1.0 .  </p></li><li><p>docker run -d -p 6379 –name redis dy&#x2F;redis  </p></li><li><p>关闭保护模式</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker exec -it redis redis-cli<br><br>config set protected-mode no<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p>  或者在 第一部 Dockerfile 的 ENTRYPOINT 中添加 “–protected-mode no”</p></li><li><p>docker port redis 6379<br>  查看映射端口(如 32772)  </p></li><li><p>本地安装 redis, centos 安装查看虚拟机.md  </p></li><li><p>redis-cli -h 127.0.0.1 -p 32772  </p></li><li><p>get p 查看是否可用（关键在于不报守护进程的错误）</p></li></ol></li><li><p><strong>连接 Redis 容器</strong></p><ol><li><p>修改或新建 &#x2F;sinatra&#x2F;webapp&#x2F;lib&#x2F;app.rb  </p>  <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">require</span> <span class="hljs-string">&quot;rubygems&quot;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&quot;sinatra&quot;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&quot;json&quot;</span><br><span class="hljs-keyword">require</span> <span class="hljs-string">&quot;redis&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &lt; <span class="hljs-title class_ inherited__">Sinatra::Application</span><br><br>      redis = <span class="hljs-title class_">Redis</span>.new(<span class="hljs-symbol">:host</span> =&gt; <span class="hljs-string">&#x27;db&#x27;</span>, <span class="hljs-symbol">:port</span> =&gt; <span class="hljs-string">&#x27;6379&#x27;</span>)<br><br>      set <span class="hljs-symbol">:bind</span>, <span class="hljs-string">&#x27;0.0.0.0&#x27;</span><br><br>      get <span class="hljs-string">&#x27;/&#x27;</span> <span class="hljs-keyword">do</span><br>        <span class="hljs-string">&quot;&lt;h1&gt;DockerBook Test Redis-enabled Sinatra app&lt;/h1&gt;&quot;</span><br>      <span class="hljs-keyword">end</span><br><br>      get <span class="hljs-string">&#x27;/json&#x27;</span> <span class="hljs-keyword">do</span><br>        params = redis.get <span class="hljs-string">&quot;params&quot;</span><br>        params.to_json<br>      <span class="hljs-keyword">end</span><br><br>      post <span class="hljs-string">&#x27;/json/?&#x27;</span> <span class="hljs-keyword">do</span><br>        redis.set <span class="hljs-string">&quot;params&quot;</span>, [params].to_json<br>        params.to_json<br>      <span class="hljs-keyword">end</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li><li><p>docker run -p 4567 –name webapp –link redis:db -d -v $PWD&#x2F;webapp:&#x2F;opt&#x2F;webapp<br>  假设映射到宿主机端口 32773<br>  <code>--link</code> 创建了两个容器间的父子连接。两个参数：一个是要连接的容器名字，另一个是连接后的别名  </p></li><li><p>启动 Redis 容器时，不需要 -p 标志公开 Redis 端口。因为父容器直接访问子容器的公开端口，只有使用 –link 标志连接到这个容器的容器才能连接到这个端口。容器的端口不需要对本地宿主机公开，安全模型。限制容器化应用程序的被攻击面，减少应用暴露的网络。  </p></li><li>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it webapp /bin/bash<br><span class="hljs-comment"># 包含连接信息</span><br><span class="hljs-built_in">cat</span> /etc/hosts<br><span class="hljs-comment"># 查看环境变量</span><br><span class="hljs-built_in">env</span><br></code></pre></td></tr></table></figure></li><li><p>curl -i -H ‘Accept:application&#x2F;json’ -d ‘name&#x3D;foo&amp;status&#x3D;Bar’ localhost:32773&#x2F;json  </p></li><li><p>curl -i localhost:32773&#x2F;json<br>  确认 Redis 实例接收到这个更新</p></li></ol></li><li><p><strong>Jenkis 安装</strong>  </p><ol><li>docker pull jenkinsci&#x2F;jenkins:lts  </li><li>docker run -p 8080:8080 -p 50000:50000 –name jenkins -u root -v &#x2F;var&#x2F;jenkins_home:&#x2F;var&#x2F;jenkins_home -v &#x2F;var&#x2F;run&#x2F;docker.sock:&#x2F;var&#x2F;run&#x2F;docker.sock -v $(which docker):&#x2F;usr&#x2F;bin&#x2F;docker jenkinsci&#x2F;jenkins:lts  </li><li>docker exec -it jenkins &#x2F;bin.bash  </li><li>doker –version<br>  如果报 error while loading shared libraries: libltdl.so.7 错误信息：  <ul><li>apt-get update  </li><li>apt-get install libltdl7</li></ul></li><li>127.0.0.1:8080 启动 jenkins，</li></ol></li></ul><hr><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。  </p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。  </p><p>Linux 的 Shell 种类众多，常见的有：  </p><p>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）<br>Bourne Again Shell（&#x2F;bin&#x2F;bash）<br>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）<br>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）<br>Shell for Root（&#x2F;sbin&#x2F;sh）  </p><hr><p><a href="http://blog.chinaunix.net/uid-27037833-id-3431985.html">http://blog.chinaunix.net/uid-27037833-id-3431985.html</a><br>Bourne shell 是 UNIX 最初使用的 shell，并且在每种 UNIX 上都可以使用, 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种shell。<br>Linux 操作系统缺省的 shell 是Bourne Again shell，它是 Bourne shell 的扩展，简称 Bash，与 Bourne shell 完全向后兼容，并且在Bourne shell 的基础上增加、增强了很多特性。 Bash放在 &#x2F;bin&#x2F;bash 中，它有许多特色，可以提供如命令补全、命令编辑和命令历史表等功能，它还包含了很多 C shell 和 Korn shell 中的优点，有灵活和强大的编程接口，同时又有很友好的用户界面。  </p><p>GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 本是 bash (Bourne-Again Shell) 的符号链接，但鉴于 bash 过于复杂，有人把 ash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 &#x2F;bin&#x2F;sh 指向它，以获得更快的脚本执行速度。Dash Shell 比 Bash Shell 小的多，符合POSIX标准。  </p><p> &#x2F;bin&#x2F;sh 与 &#x2F;bin&#x2F;bash 虽然大体上没什么区别, 但仍存在不同的标准. 标记为 “#!&#x2F;bin&#x2F;sh” 的脚本不应使用任何 POSIX 没有规定的特性 (如 let 等命令, 但 “#!&#x2F;bin&#x2F;bash” 可以)</p><p> &#x2F;bin&#x2F;sh -c<br>    -c string If  the  -c  option  is  present, then commands are read from<br>          string.  If there are arguments after the  string,  they  are<br>          assigned to the positional parameters, starting with $0.  </p><hr><p>daemon on | off   默认on<br>是否以守护进程的方式运行nginx，守护进程是指脱离终端并且在后头运行的进程，关闭守护进程执行的方式可以让我们方便调试nginx  </p><hr><p>yum 介绍  </p><p>Yum(全称为 Yellow dogUpdater, Modified)是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包，无须繁琐地一次次下载、安装。yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。  </p><p>1 安装<br>yum install 全部安装<br>    -y 安装，没有则会询问<br>yum install package1 安装指定的安装包package1<br>yum groupinsall group1 安装程序组group1  </p><p>2 更新和升级<br>yum update 全部更新<br>yum update package1 更新指定程序包package1<br>yum check-update 检查可更新的程序<br>yum upgrade package1 升级指定程序包package1<br>yum groupupdate group1 升级程序组group1  </p><p>3 查找和显示<br>yum info package1 显示安装包信息package1<br>yum list 显示所有已经安装和可以安装的程序包<br>yum list package1 显示指定程序包安装情况package1<br>yum groupinfo group1 显示程序组group1信息yum search string 根据关键字string查找安装包  </p><p>4 删除程序<br>yum remove &amp;#124; erase package1 删除程序包package1<br>yum groupremove group1 删除程序组group1<br>yum deplist package1 查看程序package1依赖情况  </p><p>5 清除缓存<br>yum clean packages 清除缓存目录下的软件包<br>yum clean headers 清除缓存目录下的 headers<br>yum clean oldheaders 清除缓存目录下旧的 headers<br>yum clean, yum clean all (&#x3D; yum clean packages; yum clean oldheaders)清 除缓存目录下的软件包及旧的header  </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker Compose</title>
    <link href="/2023/12/31/docker/Docker-Compose/"/>
    <url>/2023/12/31/docker/Docker-Compose/</url>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>先检查 linux 有没有安装 python-pip 包，终端执行 <code>pip -V</code>  </li><li>没有 python-pip 包就执行命令 <code>yum -y install epel-release</code>  </li><li>执行 <code>yum -y install python-pip</code>  </li><li>对安装好的 pip 进行升级 <code>pip install --upgrade pip</code>  </li><li>安装Docker-Compose<br> 终端执行：pip install docker-compose<br> 报错：ReadTimeoutError: HTTPSConnectionPool(host&#x3D;’pypi.python.org’, port&#x3D;443): Read timed out<br>　　  解决：pip –default-timeout&#x3D;200 install -U docker-compose</li></ol><p>Compose 是 Docker 集群管理的工具。你可以在一个文件中定义一个多容器的应用，然后使用一条命令来启动你的应用，它会自动解析容器依赖关系，下载镜像，启动应用。  </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Docker Compose</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 实战阅读笔记</title>
    <link href="/2023/12/31/docker/Docker%20%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/31/docker/Docker%20%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="第一章-介绍"><a href="#第一章-介绍" class="headerlink" title="第一章 介绍"></a>第一章 介绍</h3><p>Docker 包括一个命令行程序、一个后台守护进程，以及一组远程服务。<br>解决了常见的软件问题，并简化了安装、运行、发布和删除软件。是通过使用一项UNIX技术，称为容器。  </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 技术入门与实战阅读笔记</title>
    <link href="/2023/12/31/docker/Docker%20%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/12/31/docker/Docker%20%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E6%88%98%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>__Docker 镜像__： 只读的模板，基础。只读。<br>__Docker 容器__： 运行和隔离应用。是从镜像创建的应用运行实例。可以将其启动、开始、停止、删除，而这些容器彼此相互隔离的、互补可见的。<br>简易版的Linux系统环境（包括root用户权限、进程空间、用户空间和网络空间等）以及运行在其中的应用程序打包而成的盒子。<br>从镜像启动的时候，会在镜像的最上层创建一个可写层。   </p><p>__Docker 仓库__： 类似于代码仓库，是集中放镜像文件的场所。<br>仓库注册服务器是存放仓库的地方，其上往往存放着多个仓库。<br>每个仓库集中存放某一类镜像，往往包括多个镜像文件，通过不同的标签（tag）来进行区分。<br>例如存放Ubuntu操作系统镜像的仓库称为Ubuntu仓库，其中可能包括14.04、12.04等不同版本的镜像。  </p><p>根据所存储的镜像公开分享与否，Docker仓库可以分为公开仓库和私有仓库两种形式。<br>目前最大的公开仓库是官方提供的Docker Hub，其中存放数量庞大的镜像供用户下载。国内不少云服务提供商（如时速云、阿里云等）也提供了仓库的本地源，可以稳定的国内访问。    </p><blockquote><p> 仓库管理镜像的设计理念与Git相似，在理念设计上借鉴了Git的很多优秀思想。  </p></blockquote><h3 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h3><p>镜像是运行容器的前提。  </p><ul><li><p><strong>获取镜像</strong>  </p><p>  可以使用 docker pull name[: tag]从镜像源来下载镜像。</p></li></ul><p><code>name</code> 镜像仓库的名称（用来区分镜像）； <code>tag</code> 镜像的标签（用来表示版本信息）<br>如果不显示指定 tag，则默认会选择 <em>latest</em> 标签，下载最新版本的镜像。  </p><blockquote><p> latest 标签意味着该镜像的内容会跟踪到最新的非稳定版本而发生，内容是不稳定的。从稳定性上考虑，不要在生产环境中忽略镜像的标签信息或使用默认的 latest 标记的镜像  </p></blockquote><pre><code class="hljs">严格地讲，镜像的仓库名称中还应该添加仓库地址（即registry，注册服务器）作为前缀，由于默认使用的是 Docker Hub 服务，该前缀可以忽略。  例如： docker pull ubuntu:14.04 命令相当于 docker pull registry.hub.docker.com/ubuntu:14.04  如果从非官方的仓库下载，则需要在仓库名称前指定完整的仓库地址。  pull 子命令支持的选项：  -a,--all-tags=true | false ： 是否获取仓库中的所有镜像，默认为否  </code></pre><ul><li><p><strong>查看镜像</strong>  </p><p>  __docker images__： 列出本地主机上已有镜像的基本信息  </p><ul><li>仓库  </li><li>镜像的标签信息</li><li>镜像的ID（唯一标识镜像）</li><li>创建时间  </li><li>镜像大小</li></ul><p>  子命令:</p></li></ul><blockquote><p> __man docker-images__： 查看子命令选项  </p></blockquote><pre><code class="hljs">* -a，       --all=true | false  ： 列出所有镜像文件（包括临时文件），默认为否  * --digests=true|false          :   列出镜像的数字摘要值，默认为否  * -f，       --filter=[] ： 过滤列出的镜像  docker images -f dangling=[true|false]  docker images -f label=&lt;key&gt;[=&lt;=value&gt;]  docker images -f before=(&lt;image-name&gt;[:tag] |&lt;image-id&gt; |&lt;image@digest&gt;)  docker images -f since=(&lt;image-name&gt;[:tag] |&lt;image-id&gt; |&lt;image@digest&gt;)  * --no-trunc=true | false       ： 对输出结果中太长的部分是否进行截断，默认为是  * -q，   --quiet=true | false    ： 仅输出 ID 信息，默认为否  * -h，   --help  * --format=&quot;TEMPLATE&quot;       ： 控制输出格式  </code></pre><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">$ docker images --format &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.ID</span>&#125;&#125;</span><span class="language-xml">: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Repository</span>&#125;&#125;</span><span class="language-xml">&quot;</span><br><span class="language-xml"></span><br><span class="language-xml">30557a29d5ab: docker</span><br><span class="language-xml">5ed6274db6ce: <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">$ docker images --format &quot;table </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.ID</span>&#125;&#125;</span><span class="language-xml">\t</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Repository</span>&#125;&#125;</span><span class="language-xml">\t</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Tag</span>&#125;&#125;</span><span class="language-xml">&quot;</span><br><span class="language-xml"></span><br><span class="language-xml">IMAGE ID            REPOSITORY                TAG</span><br><span class="language-xml">77af4d6b9913        <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span>                    <span class="hljs-tag">&lt;<span class="hljs-name">none</span>&gt;</span></span><br><span class="language-xml">b6fa739cedf5        committ                   latest</span><br><span class="language-xml">746b819f315e        postgres                  9</span><br></code></pre></td></tr></table></figure><pre><code class="hljs">|占位符            |描述                    |  |:--------------:|:----------------:|  |.ID|Image ID|  |.Repository|Image repository|  |.Tag|Image tag|  |.Digest|Image digest|  |.CreatedSince|Elapsed time since the image was created|  |.CreatedAt|Time when the image was created|  |.Size|Image disk size| __docker inspect []__ 查看镜像的详细信息  </code></pre><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">docker inspect -f </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Config.Hostname</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Os</span>&#125;&#125;</span><span class="language-xml"> hello-world </span><br></code></pre></td></tr></table></figure><pre><code class="hljs">__docker history__ ：  查看指定镜像的创建历史  * --no-trunc  ： 显示完整的提交记录  * -H          ： 以可读的格式打印镜像大小和日期，默认为true  * -q          ： 仅列出提交记录ID</code></pre><ul><li><p><strong>搜索镜像</strong><br>  <strong>docke search [options] term</strong> ： 从 Docker Hub 查找镜像  </p><ul><li>–automated :只列出 automated build类型的镜像；  </li><li>–no-trunc :显示完整的镜像描述；  </li><li>-s :列出收藏数不小于指定值的镜像，默认为0。</li></ul></li><li><p><strong>删除镜像</strong><br>  <strong>docker rmi [OPTIONS] IMAGE [IMAGE…]</strong> : 删除本地一个或多少镜像  </p><ul><li>-f： 强制删除  </li><li>–no-prune： 不移除该镜像的过程镜像，默认移除</li></ul><p>  <strong>docker rmi -f $(docker images -f “dangling&#x3D;true” -q)</strong> : 删除镜像 repository, tag 为 null 的镜像</p></li><li><p><strong>创建镜像</strong>  </p><p>  <strong>docker commit</strong> :从容器创建一个新的镜像。  </p>  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker commit <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[REPOSITORY<span class="hljs-comment">[:TAG]</span>]</span><br></code></pre></td></tr></table></figure><ul><li>-a，   –author&#x3D;””     :提交的镜像作者；  </li><li>-c，   –change&#x3D;[]     :使用Dockerfile指令来创建镜像；  </li><li>-m，   –message&#x3D;””    :提交时的说明文字；  </li><li>-p，   –pause&#x3D; true   :在commit时，将容器暂停。</li></ul><p> <strong>docker import</strong> : 从归档文件中创建镜像。<br> <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker <span class="hljs-keyword">import</span> [<span class="hljs-keyword">OPTIONS</span>] <span class="hljs-keyword">file</span>|URL|- [REPOSITORY[:TAG]]<br></code></pre></td></tr></table></figure></p><ul><li>-c :应用docker 指令创建镜像；  </li><li>-m :提交时的说明文字；</li></ul></li><li><p><strong>存入和载入镜像</strong>  </p><p>  __docker save__： 将指定镜像保存成 tar 归档文件  </p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">docker save <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[IMAGE...]</span><br>或<br>docker save 要保存的文件名&gt;    要保存的镜像<br></code></pre></td></tr></table></figure><ul><li>-o :输出到的文件。</li></ul><p>  __docker load__： 将tar文件恢复成一个镜像<br>  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">docker <span class="hljs-built_in">load</span> <span class="hljs-comment">--input 文件</span><br>或者<br>docker <span class="hljs-built_in">load</span> &lt; 文件名<br></code></pre></td></tr></table></figure></p></li><li><p><strong>上传镜像</strong>  </p><p>  <strong>docker push</strong> : 将本地的镜像上传到镜像仓库,要先登陆到镜像仓库  </p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker push <span class="hljs-selector-attr">[OPTIONS]</span> NAME<span class="hljs-selector-attr">[:TAG]</span><br></code></pre></td></tr></table></figure><ul><li>–disable-content-trust :忽略镜像的校验,默认开启</li></ul></li></ul><h3 id="操作-Docker-容器"><a href="#操作-Docker-容器" class="headerlink" title="操作 Docker 容器"></a>操作 Docker 容器</h3><ul><li><p><strong>创建容器</strong><br>  <strong>docker create</strong> ：创建一个新的容器但不启动它  </p></li><li><p><strong>启动容器</strong><br>  <strong>docker start</strong> :启动一个或多个已经被停止的容器<br>  <strong>docker stop</strong> :停止一个运行中的容器<br>  <strong>docker restart</strong> :重启容器  </p></li><li></li></ul><p>docker 容器（服务）重命名只要一个命令就可以：<br><code>docker rename 原容器名  新容器名</code>  </p><hr><p>带有 OFFICIAL 标记说明是官方镜像  </p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/12/31/demo/hello-world/"/>
    <url>/2023/12/31/demo/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><h3 id="hexo版本更新"><a href="#hexo版本更新" class="headerlink" title="hexo版本更新"></a>hexo版本更新</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">查看版本: hexo version<br>安装hexo-cli: npm i hexo-cli -g<br>安装检查版本插件: npm install -g npm-check<br>检查项目的插件版本: npm-check<br>安装升级插件: npm install -g npm-upgrade<br>选择项目pack.josn中的需升级的版本: npm-upgrade<br>升级项目版本: npm update -g 或者 npm update --save 或者 npm install<br></code></pre></td></tr></table></figure><h3 id="安装async主题"><a href="#安装async主题" class="headerlink" title="安装async主题"></a>安装async主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-async hexo-renderer-less hexo-renderer-ejs<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>项目源码推荐</title>
    <link href="/2023/12/31/%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/"/>
    <url>/2023/12/31/%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<ol><li><p><strong><a href="https://gitee.com/y_project/RuoYi">若依 &#x2F; RuoYiJavaMIT</a></strong><br>基于SpringBoot2.0的权限管理系统 易读易懂、界面简洁美观。 核心技术采用Spring、MyBatis、Shiro没有任何其它重度依赖。直接运行即可用<br><a href="http://www.ruoyi.vip/">http://www.ruoyi.vip</a>  </p></li><li><p><a href="https://gitee.com/owenwangwen/open-capacity-platform">https://gitee.com/owenwangwen/open-capacity-platform</a>  </p></li><li><p><a href="https://gitee.com/meidea/Young-Auth">https://gitee.com/meidea/Young-Auth</a></p></li></ol><h4 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h4><p>#####运维</p><ol><li><a href="https://blog.kazaff.me/">https://blog.kazaff.me/</a>  </li><li><a href="https://www.szyhf.org/">https://www.szyhf.org/</a></li></ol><p><a href="https://www.liaoxuefeng.com/">https://www.liaoxuefeng.com</a><br><a href="https://www.gaowenhao.cn/#/index">https://www.gaowenhao.cn/#/index</a></p><h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>eclipse 安装 AmaterasUML<br>项目所在的 github上<a href="https://github.com/takezoe/amateras-modeler%E4%B8%8A">https://github.com/takezoe/amateras-modeler上</a><br>eclipse 4.0 以下 需要先安装 GEF, 查看图片 安装GEF.jpg，或者 <a href="http://download.eclipse.org/tools/gef/updates-pre-3_8/releases/">http://download.eclipse.org/tools/gef/updates-pre-3_8/releases/</a><br>Help –&gt; Install New Software –&gt; Add. —&gt;Location 填充 <a href="http://takezoe.github.io/amateras-update-site">http://takezoe.github.io/amateras-update-site</a>  </p><p>《深入理解 Java 虚拟机》<br>《Effective Java》<br>《深入分析 Java Web 技术内幕》<br>《大型网站技术架构》<br>《代码整洁之道》<br>《架构整洁之道》<br>《Head First 设计模式》<br>《maven 实战》<br>《区块链原理、设计与应用》<br>《Java 并发编程实战》<br>《鸟哥的 Linux 私房菜》<br>《从Paxos 到 Zookeeper》<br>《架构即未来》</p>]]></content>
    
    
    <categories>
      
      <category>推荐</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码推荐</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目搭建问题汇总</title>
    <link href="/2023/12/31/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2023/12/31/%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><strong>1. &#x2F;oauth&#x2F;token 401</strong><br>需要添加</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">(AuthorizationServerSecurityConfigurer security)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>security.tokenKeyAccess(<span class="hljs-string">&quot;isPermitAll()&quot;</span>)<br>.checkTokenAccess(<span class="hljs-string">&quot;isPermitAll()&quot;</span>)<br>.allowFormAuthenticationForClients();<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;oauth&#x2F;token  </p><ul><li>这个如果配置支持allowFormAuthenticationForClients的，且url中有client_id和client_secret的会走ClientCredentialsTokenEndpointFilter来保护  </li><li>如果没有支持allowFormAuthenticationForClients或者有支持但是url中没有client_id和client_secret的，走basic认证保护</li></ul><p><strong>2. java.lang.IllegalArgumentException: There is no PasswordEncoder mapped for the id “null”</strong><br>由于 Spring 升级到 5+<br>加密方式储存变为 {加密类型}密文<br>PasswordEncoderFactories 类 新增加了多种密码加密方式  </p><p>明文可以使用 {noop}password  </p><p>可以通过.passwordEncoder(new BCryptPasswordEncoder())</p><p><strong>3. springboot 集成 JSP</strong><br>jsp 一定要放在 webapp 下面<br>pom 中增加</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- JSP依赖 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jstl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件增加：  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.mvc.view.prefix</span>=/WEB-INF/views/<br><span class="hljs-attr">spring.mvc.view.suffix</span>=.jsp<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>问题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库优化建议</title>
    <link href="/2023/12/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%AE%AE%E7%82%B9/"/>
    <url>/2023/12/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%AE%AE%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="1-区分in和exists、not-in和not-exists"><a href="#1-区分in和exists、not-in和not-exists" class="headerlink" title="1. 区分in和exists、not in和not exists"></a>1. 区分in和exists、not in和not exists</h4><p>区分 in 和 exists 主要是造成了驱动顺序的改变（这是性能变化的关键），如果是 exists，那么以外层表为驱动表，先被访问，如果是 IN，那么先执行子查询。所以 IN 适合于外表大而内表小的情况；EXISTS 适合于外表小而内表大的情况。</p>]]></content>
    
    
    <categories>
      
      <category>问题汇总</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>MySQL</tag>
      
      <tag>优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机</title>
    <link href="/2023/12/31/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2023/12/31/%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><h4 id="CentOS安装docker"><a href="#CentOS安装docker" class="headerlink" title="CentOS安装docker"></a>CentOS安装docker</h4><h5 id="一、CentOS-Docker-安装"><a href="#一、CentOS-Docker-安装" class="headerlink" title="一、CentOS Docker 安装"></a>一、CentOS Docker 安装</h5><p>Docker支持以下的CentOS版本：  </p><ul><li>CentOS 7 (64-bit)  </li><li>CentOS 6.5 (64-bit) 或更高的版本</li></ul><h5 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h5><p>目前，CentOS 仅发行版本中的内核支持 Docker。<br>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本。  </p><h5 id="使用-yum-安装（CentOS-7-下）"><a href="#使用-yum-安装（CentOS-7-下）" class="headerlink" title="使用 yum 安装（CentOS 7 下）"></a>使用 yum 安装（CentOS 7 下）</h5><p>Docker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。<br>通过 uname -r 命令查看你当前的内核版本<br>[root@runoob ~]# uname -r</p><h6 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h6><p>Docker CE 和 Docker EE。<br>Docker CE 即社区免费版，Docker EE 即企业版，强调安全，但需付费使用。  </p><p>安装一些必要的系统工具：  </p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">sudo</span> yum install -y yum-utils device-mapper-persistent-<span class="hljs-class"><span class="hljs-keyword">data</span> lvm2</span><br></code></pre></td></tr></table></figure><p>添加软件源信息：  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo yum-config-manager --add-repo http:<span class="hljs-regexp">//mi</span>rrors.aliyun.com<span class="hljs-regexp">/docker-ce/</span>linux<span class="hljs-regexp">/centos/</span>docker-ce.repo<br></code></pre></td></tr></table></figure><p>更新 yum 缓存：  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo yum makecache fast</span><br></code></pre></td></tr></table></figure><p>安装 Docker-ce：  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum -y <span class="hljs-keyword">install</span> docker-ce<br></code></pre></td></tr></table></figure><p>启动 Docker 后台服务  </p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure><p>测试运行 hello-world  </p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@runoob</span> ~]<span class="hljs-meta"># docker run hello-world</span><br></code></pre></td></tr></table></figure><h6 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h6><p>您可以使用以下命令直接从该镜像加速地址进行拉取：<br>$ docker pull registry.docker-cn.com&#x2F;myname&#x2F;myrepo:mytag<br>例如:<br>$ docker pull registry.docker-cn.com&#x2F;library&#x2F;ubuntu:16.04</p><blockquote><p> 注: 除非您修改了 Docker 守护进程的 <code>--registry-mirror</code> 参数 (见下文), 否则您将需要完整地指定官方镜像的名称。例如，library&#x2F;ubuntu、library&#x2F;redis、library&#x2F;nginx。  </p></blockquote><p>您可以在 Docker 守护进程启动时传入 –registry-mirror 参数：<br>$ docker –registry-mirror&#x3D;<a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a> daemon<br>为了永久性保留更改，您可以修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件并添加上 registry-mirrors 键值。  </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>修改保存后重启 Docker 以使配置生效。  　</p><blockquote><p> 注: 您也可以使用适用于 Mac 的 Docker 和适用于 Windows 的 Docker 来进行设置。<br>原文链接： <a href="https://www.cnblogs.com/weifeng1463/p/7468391.html">https://www.cnblogs.com/weifeng1463/p/7468391.html</a>  </p></blockquote><h6 id="删除-Docker-CE"><a href="#删除-Docker-CE" class="headerlink" title="删除 Docker CE"></a>删除 Docker CE</h6><p>执行以下命令来删除 Docker CE：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo yum remove docker-ce</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo <span class="hljs-built_in">rm</span> -rf /var/lib/docker</span><br></code></pre></td></tr></table></figure><h4 id="镜像（Image）和容器（Container）"><a href="#镜像（Image）和容器（Container）" class="headerlink" title="镜像（Image）和容器（Container）"></a>镜像（Image）和容器（Container）</h4><p>镜像：一堆只读层的统一视角<br>容器： 一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的<br>容器 &#x3D; 镜像 + 读写层<br>运行态容器（running container）：一个可读写的统一文件系统加上隔离的进程空间和包含其中的进程<br>只读层和读写层都包含元数据，元数据是这个层的额外信息，它不仅能够让Docker获取运行和构建时的信息，还包括父层的层次信息。读写层和只读层都包含元数据。<br>每一层都包含一个指向父层的指针。如果一个层没有这个指针，说明它处于最底层。  </p><h4 id="安装-Dubbo"><a href="#安装-Dubbo" class="headerlink" title="安装 Dubbo"></a>安装 Dubbo</h4><ol><li>安装 Zookeeper  </li><li>下载 <a href="https://github.com/apache/incubator-dubbo/tree/2.5.x">Dubbo</a>  </li><li>解压，<code>mvn clean install -Dmaven.test.skip=true</code>，将 dubbo-admin\target\dubbo-admin-xxx.war 移入到虚拟机的 tomcat\webapps 下，将 tomcat 的端口改掉，以防 zookeeper 会暂用这个端口  </li><li>tomcat\bin <code>chmod +x *.sh</code> <code>./startup.sh</code>启动tomcat  </li><li>关闭防火墙 <code>systemctl stop &#39;firewalld.service&#39;</code>，否则 主机无法访问 tomcat  </li><li>输入URL ： <code>http://127.0.0.1:8888/dubbo-admin-2.5.10/</code> 即可访问  </li><li>登录密码在 dubbo.properties 文件中配置</li></ol><p>####安装 zookeeper<br>*下载解压zookeeper<br><code>tar -zxvf zookeeper-3.4.12.tar.gz</code></p><ul><li><p>root 修改 &#x2F;etc&#x2F;profile，增加<br><code>export ZOOKEEPER_HOME=/opt/zookeeper-3.4.6</code><br><code>export PATH=$PATH:$ZOOKEEPER_HOME/bin:$ZOOKEEPER_HOME/conf</code></p></li><li><p>source &#x2F;etc&#x2F;profile 使配置奏效  </p></li><li><p>在 zookeeper 目录下创建数据文件目录及日志文件目录  </p></li><li><p><code>cd conf</code> <code>cp zoo_sample.cfg zoo.cfg</code>  </p></li><li><p><code>vim zoo.cfg</code> 修改如下配置：<br><code>dataDir=/home/hadoop/usr/local/zookeeper/data #目录上文创建，同下</code><br><code>dataLogDir=/home/hadoop/usr/local/zookeeper/logs</code><br><code>server.1=192.168.126:2888:3888 第一个端口用于集合体中 follower 以侦听 leader； 第二个端口用于 Leader 选举; 第一个 hostname 即为本服务器地址</code></p><blockquote><p>最好用cat &#x2F;etc&#x2F;hosts中的主机名配置，如 localhost:2888:3888<br>否则 Dubbo 中的 provider 无法注册到虚拟机的 Zookeeper 中  </p></blockquote></li><li><p>启动<br><code>cd bin</code><br><code>zkServer.sh start</code>： 启动<br><code>zkServer.sh status</code>: 检查状态<br><code>zkServer.sh stop</code>： 停止<br>或者<br><code>bin/zkServer.sh start</code></p></li></ul><h5 id="单机伪分布式搭建zookeeper集群"><a href="#单机伪分布式搭建zookeeper集群" class="headerlink" title="单机伪分布式搭建zookeeper集群"></a>单机伪分布式搭建zookeeper集群</h5><ol><li>cd conf  </li><li>cp zoo_sample.cfg zoo.cfg  </li><li>vim zoo.cfg  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=/usr/local/zookeeper00/dataDir<br><span class="hljs-attr">dataLogDir</span>=/usr/local/zookeeper00/dataLogDir<br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2181</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">190.129</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span>  <span class="hljs-comment"># master节点，ip后面跟的是集群通信的端口</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">190.129</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">190.129</span>:<span class="hljs-number">2890</span>:<span class="hljs-number">3890</span><br></code></pre></td></tr></table></figure></li><li>cd ..&#x2F; &amp;&amp; mkdir {dataDir, dataLogDir}  </li><li>cd dataDir&#x2F; &amp;&amp; vim myid<br><code>1</code>  </li><li>cp zookeeper00 zookeeper01 -rf   </li><li>cp zookeeper00 zookeeper02 -rf   </li><li>配置 zookeeper01  <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">ickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br><span class="hljs-attr">dataDir</span>=/usr/local/zookeeper01/dataDir<br><span class="hljs-attr">dataLogDir</span>=/usr/local/zookeeper01/dataLogDir<br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2182</span>  <span class="hljs-comment"># 端口号必须要修改</span><br><span class="hljs-attr">server.1</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">190.129</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br><span class="hljs-attr">server.2</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">190.129</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br><span class="hljs-attr">server.3</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">190.129</span>:<span class="hljs-number">2890</span>:<span class="hljs-number">3890</span><br></code></pre></td></tr></table></figure>cd dataDir&#x2F; &amp;&amp; vim myid &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; <code>2</code>  </li><li>zookeeper2 配置同上<br>cd dataDir&#x2F; &amp;&amp; vim myid &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; <code>3</code>  </li><li>测试<br>分别启动： <code>bin/zkServer.sh start</code><br>查看监听的端口： <code>netstat -lntp |grep java</code>  </li><li>创造节点，是否同步到集群中的其它节点  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim">bin/zkCli.<span class="hljs-keyword">sh</span> -server localhos<span class="hljs-variable">t:2181</span>  <br><span class="hljs-keyword">ls</span> /  <br>create /data test-data<br><span class="hljs-keyword">ls</span> /<br><span class="hljs-keyword">quit</span><br></code></pre></td></tr></table></figure></li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs vim">bin/zkCli.<span class="hljs-keyword">sh</span> -server localhos<span class="hljs-variable">t:2182</span>  <br><span class="hljs-keyword">ls</span> /  # 可以查看到我们在第一个节点上创建的znode，代表集群中的节点能够正常同步数据<br><span class="hljs-built_in">get</span> /data<br><span class="hljs-keyword">quit</span><br></code></pre></td></tr></table></figure><ol start="12"><li>查看集群的状态、主从信息需要使用 .&#x2F;zkServer.sh status 命令 可以写一个简单的 shell 脚本批量执行命令<br><a href="http://blog.51cto.com/zero01/2107174">原文链接</a></li></ol><h4 id="Kafka-安装"><a href="#Kafka-安装" class="headerlink" title="Kafka 安装"></a>Kafka 安装</h4><ol><li>下载解压 kafka  </li><li>修改配置文件 vim config&#x2F;server.properties   <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">broker.id</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">port</span>=<span class="hljs-number">9092</span><br><span class="hljs-attr">host.name</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">22.128</span><br><span class="hljs-attr">log.dirs</span>=data/kafka-logs<br></code></pre></td></tr></table></figure></li><li>可以启动系统中的 zookeeper，或者见步骤4</li><li>修改config&#x2F;zookeeper.properties<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dataDir</span>=zookeeper/data<br><span class="hljs-attr">dataLogDir</span>=zookeeper/log<br><span class="hljs-comment"># the port at which the clients will connect</span><br><span class="hljs-attr">clientPort</span>=<span class="hljs-number">2181</span><br><span class="hljs-comment"># disable the per-ip limit on the number of connections since this is a non-production config</span><br><span class="hljs-attr">maxClientCnxns</span>=<span class="hljs-number">100</span><br><span class="hljs-attr">tickTime</span>=<span class="hljs-number">2000</span><br><span class="hljs-attr">initLimit</span>=<span class="hljs-number">10</span><br><span class="hljs-attr">syncLimit</span>=<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure></li><li>新建 kafka 文件夹，新建 kafkastart.sh<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#!<span class="hljs-regexp">/bin/</span>sh<br>~<span class="hljs-regexp">/application/</span>kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/bin/</span>zookeeper-server-start.sh ~<span class="hljs-regexp">/application/</span>kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/config/</span>zookeeper.properties &amp;<br># 或者<br># ~<span class="hljs-regexp">/software/</span>decompression_package<span class="hljs-regexp">/zookeeper-3.4.12/</span>bin/zkServer.sh start<br><br>sleep <span class="hljs-number">3</span><br><br>~<span class="hljs-regexp">/application/</span>kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/bin/</span>kafka-server-start.sh ~<span class="hljs-regexp">/application/</span>kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/config/</span>server.properties &amp;<br></code></pre></td></tr></table></figure></li><li>新建 kafkastop.sh<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#!<span class="hljs-regexp">/bin/</span>sh<br><br>~<span class="hljs-regexp">/application/</span>kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/bin/</span>kafka-server-stop.sh ~<span class="hljs-regexp">/application/</span>kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/config/</span>server.properties &amp;<br><br>sleep <span class="hljs-number">3</span><br><br>~<span class="hljs-regexp">/application/</span>kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/bin/</span>zookeeper-server-stop.sh ~<span class="hljs-regexp">/application/</span>kafka_2.<span class="hljs-number">12</span>-<span class="hljs-number">2.1</span>.<span class="hljs-number">0</span><span class="hljs-regexp">/config/</span>zookeeper.properties &amp;<br># 或者<br># ~<span class="hljs-regexp">/software/</span>decompression_package<span class="hljs-regexp">/zookeeper-3.4.12/</span>bin/zkServer.sh stop<br></code></pre></td></tr></table></figure></li></ol><blockquote><p><code>lsof -i:2181</code>： 查看端口进程  </p></blockquote><ol start="7"><li><p>chmod +x *.sh  </p></li><li><p>.&#x2F;kafkastart.sh 启动  </p></li><li><p>.&#x2F;kafkastop.sh 关闭  </p></li><li><p>生成者创建 topic<br><code>bin/kafka-topics.sh --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic Hello-Kafka</code><br>生产者查询主题<br><code>bin/kafka-topics.sh --list --zookeeper localhost:2181</code></p></li></ol><p><code>bin/kafka-topics.sh --describe --zookeeper localhost:2181 --topic Hello-Kafka</code><br>删除主题<br><code>bin/kafka-topics.sh --delete --zookeeper localhost:2181 --topic Hello-Kafka</code>  </p><p>生产者发送主题消息<br><code>bin/kafka-console-producer.sh --broker-list localhost:9092 --topic Hello-Kafka</code>  </p><p>消费主题消息<br><code>bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 -topic Hello-Kafka  --from-beginning</code>  </p><p><a href="https://blog.csdn.net/belalds/article/details/80575751">Kafka 彻底被删除</a>  </p><hr><h3 id="错误信息："><a href="#错误信息：" class="headerlink" title="错误信息：###"></a>错误信息：###</h3><h4 id="1-cannot-find-a-valid-baseurl-for-repo-base-x2F-7-x2F-x86-64"><a href="#1-cannot-find-a-valid-baseurl-for-repo-base-x2F-7-x2F-x86-64" class="headerlink" title="1. cannot find a valid baseurl for repo:base&#x2F;7&#x2F;x86_64"></a>1. cannot find a valid baseurl for repo:base&#x2F;7&#x2F;x86_64</h4><p> 一、<br>如果有timeout，可能是网络问题，网络连接选择NAT模式<br>二、<br>进入&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts目录，查找ifcfg开头的文件，将配置ONBOOT&#x3D;no，改为ONBOOT&#x3D;yes, 添加<br>DNS1&#x3D;8.8.8.8<br>DNS2&#x3D;4.2.2.2<br>具体命令如下：  </p><pre><code class="hljs"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /etc/sysconfig/network-scripts<br><span class="hljs-built_in">ls</span><br><span class="hljs-comment"># 每个机子都可能不一样，但格式会是“ifcfg-eth数字”</span><br></code></pre></td></tr></table></figure></code></pre><p>使用vim打开文件ifcfg-ens33，并做更改  </p><pre><code class="hljs"><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">vi ifcfg-e<span class="hljs-symbol">ns33</span>  <br></code></pre></td></tr></table></figure></code></pre><blockquote><p>ONBOOT&#x3D;no在最后一行，可以shift+g键，使光标直接跳到最后一行，按l右移光标，按h左移光标，按x键删除光标所在位置的字符；然后shift+a键，使光标移动到本行末尾，进行插入操作，键盘输入‘yes’，按一下 esc键退出编辑模式，然后shift+z+z键保存并退出vim。</p></blockquote><p>重启网络：service network restart </p><p>三、  </p><pre><code class="hljs"><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vi <span class="hljs-regexp">/etc/</span>resolv.conf<br></code></pre></td></tr></table></figure>nameserver 8.8.8.8nameserver 4.2.2.2nameserver 172.19.0.6nameserver 172.19.0.5</code></pre><p>重启网络</p><h4 id="2-Centos如何进入和退出Vim编辑器"><a href="#2-Centos如何进入和退出Vim编辑器" class="headerlink" title="2. Centos如何进入和退出Vim编辑器"></a>2. Centos如何进入和退出Vim编辑器</h4><p>1、进入VIM编辑器，可以新建文件也可以修改文件，命令为：vim  &#x2F;usr&#x2F;local&#x2F;con.cfg<br>2、如果这个文件，以前是没有的，则为新建，则下方有提示为新文件。<br>如果文件已存在，则没有提示。<br>3、进入编辑器后，我们先按”I”，即切换到“插入”状态。就可以通过上下左右移动光标，或空格、退格及回车等进行编辑内容了，和WINDOWS是一样的了。  </p><p>按ESC键 跳到命令模式，然后：<br>:w 保存文件但不退出vi<br>:w file 将修改另外保存到file中，不退出vi<br>:w! 强制保存，不推出vi<br>:wq 保存文件并退出vi<br>:wq! 强制保存文件，并退出vi<br>q: 不保存文件，退出vi<br>:q! 不保存文件，强制退出vi<br>:e! 放弃所有修改，从上次保存文件开始再编辑  </p><p>原文：<a href="https://blog.csdn.net/heliosj/article/details/78191857">https://blog.csdn.net/heliosj/article/details/78191857</a>   </p><h4 id="3-VM-虚拟机上翻屏"><a href="#3-VM-虚拟机上翻屏" class="headerlink" title="3. VM 虚拟机上翻屏"></a>3. VM 虚拟机上翻屏</h4><p>shift + page up  </p><h4 id="4-docker启动-重启-命令"><a href="#4-docker启动-重启-命令" class="headerlink" title="4. docker启动 || 重启 || 命令"></a>4. docker启动 || 重启 || 命令</h4><p>启动        systemctl start docker<br>守护进程重启   sudo systemctl daemon-reload<br>重启docker服务   systemctl restart  docker<br>重启docker服务  sudo service docker restart<br>关闭docker   service docker stop<br>关闭docker  systemctl stop docker  </p><h4 id="5-“Cannot-connect-to-the-Docker-daemon-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock-Is-the-docker-daemon-running-”"><a href="#5-“Cannot-connect-to-the-Docker-daemon-at-unix-x2F-x2F-x2F-var-x2F-run-x2F-docker-sock-Is-the-docker-daemon-running-”" class="headerlink" title="5. “Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?”"></a>5. “Cannot connect to the Docker daemon at unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock. Is the docker daemon running?”</h4><p>问题原因是因为docker服务没有启动<br>执行 service docker start 命令，启动docker服务  </p><h4 id="6-外部网络通过端口映射访问部署在虚拟机里-Docker-中的-Web-应用"><a href="#6-外部网络通过端口映射访问部署在虚拟机里-Docker-中的-Web-应用" class="headerlink" title="6. 外部网络通过端口映射访问部署在虚拟机里 Docker 中的 Web 应用"></a>6. 外部网络通过端口映射访问部署在虚拟机里 Docker 中的 Web 应用</h4><p>win + r  —-&gt; cmd —-&gt; ipconfig 查看 windows 主机： 192.168.23.62<br>虚拟机   —–&gt; ip addr —-&gt; ens33 中 inet 后的 IP 为虚拟机中操作系统（如 CentOS）的 IP 地址: 192.168.22.128<br>虚拟机   —–&gt; ip addr —-&gt; docker0 中 inet 后的 IP 为 docker 的IP 地址： 172.17.0.1  </p><p>通过 <code>docker run -p</code> 中 <code>-p</code> 将 docker 端口映射到虚拟机端口。 可通过 curl localhost:port 访问映射端口，如<code>docker run -d -p 8080:80 image</code>  </p><p>虚拟机菜单栏编辑 —-&gt;  虚拟机网络映射编辑 —-&gt;  更改设置 —-&gt; 选择 NAT 模式 —-&gt; NAT 设置 —-&gt; 添加 —-&gt; 主机端口（windows 访问的端口，如8800）, 类型 tcp ,虚拟机 IP 地址（192.168.22.128），虚拟机端口(8080)，描述（随意）  </p><p>虚拟机启动防守进程，windows 浏览器访问地址 127.0.0.1:8800 即可访问  </p><p>dockfile 文件</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">FROM</span> nginx<br>RUN echo <span class="hljs-string">&#x27;&lt;h1&gt;Hello Docker!&lt;/h1&gt;&#x27;</span> &gt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html/index.html<br></code></pre></td></tr></table></figure><p>原文链接： <a href="https://blog.csdn.net/liwenxia626/article/details/80848377">https://blog.csdn.net/liwenxia626/article/details/80848377</a>  </p><p>原文链接： <a href="https://blog.csdn.net/qq_35673617/article/details/80561489">https://blog.csdn.net/qq_35673617/article/details/80561489</a><br>Redis Desktop 链接 Centos7上部署的 redis 数据库<br><code>bind 0.0.0.0</code><br><code>firewall-cmd --query-port=6379/tcp</code>，如果出现<code>no</code>，此时执行命令：<code>firewall-cmd --add-port=6379/tcp</code>，将 6379 端口开启，返回 success，执行完查询端口是否已开启  </p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">启动一个服务： <span class="hljs-string">systemctl</span> <span class="hljs-string">start</span> <span class="hljs-string">firewalld</span>.<span class="hljs-string">service</span><br>关闭一个服务： <span class="hljs-string">systemctl</span> <span class="hljs-string">stop</span> <span class="hljs-string">firewalld</span>.<span class="hljs-string">service</span><br>重启一个服务： <span class="hljs-string">systemctl</span> <span class="hljs-string">restart</span> <span class="hljs-string">firewalld</span>.<span class="hljs-string">service</span><br>显示一个服务的状态： <span class="hljs-string">systemctl</span> <span class="hljs-string">status</span> <span class="hljs-string">firewalld</span>.<span class="hljs-string">service</span><br>在开机时启用一个服务： <span class="hljs-string">systemctl</span> <span class="hljs-string">enable</span> <span class="hljs-string">firewalld</span>.<span class="hljs-string">service</span><br>在开机时禁用一个服务： <span class="hljs-string">systemctl</span> <span class="hljs-string">disable</span> <span class="hljs-string">firewalld</span>.<span class="hljs-string">service</span><br>查看服务是否开机启动： <span class="hljs-string">systemctl</span> <span class="hljs-string">is-enabled</span> <span class="hljs-string">firewalld</span>.<span class="hljs-string">service</span><br>查看已启动的服务列表： <span class="hljs-string">systemctl</span> <span class="hljs-built_in">list-unit-files|grep</span> <span class="hljs-string">enabled</span><br></code></pre></td></tr></table></figure><h4 id="7-Linux-下的-gt-和-gt-gt"><a href="#7-Linux-下的-gt-和-gt-gt" class="headerlink" title="7. Linux 下的 &gt; 和 &gt;&gt;"></a>7. Linux 下的 &gt; 和 &gt;&gt;</h4><p><code>&gt;</code>： 覆盖写<br><code>&gt;&gt;</code>： 追加写  </p><p><code>ls -l &gt; list.txt</code>： 将 ls 执行结果保存到 list 文件中  </p><h4 id="8-vi-退出命令"><a href="#8-vi-退出命令" class="headerlink" title="8. vi 退出命令"></a>8. vi 退出命令</h4><p>进入编辑模式，按 i 进行编辑<br>编辑结束，按ESC 键 跳到命令模式，然后输入退出命令：<br>    :w保存文件但不退出vi 编辑<br>    :w! 强制保存，不退出vi 编辑<br>    :w file将修改另存到file中，不退出vi 编辑<br>    :wq保存文件并退出vi 编辑<br>    :wq!强制保存文件并退出vi 编辑<br>    q:不保存文件并退出vi 编辑<br>    :q!不保存文件并强制退出vi 编辑<br>    :e!放弃所有修改，从上次保存文件开始在编辑  </p><h4 id="9-apt-get-update-以及-apt-get-upgrade"><a href="#9-apt-get-update-以及-apt-get-upgrade" class="headerlink" title="9. apt-get update 以及 apt-get upgrade"></a>9. apt-get update 以及 apt-get upgrade</h4><p>update 是更新软件列表，upgrade 是更新软件<br>update 会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑<br>upgrade 会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。如果你的软件都是最新版本，会提示： 1  </p><h4 id="10-wget-command-not-found"><a href="#10-wget-command-not-found" class="headerlink" title="10. wget command not found"></a>10. wget command not found</h4><p>安装的是CentOS，wget默认不会被安装，所以找不到wget这个命令，解决方式是安装wget<br>yum安装wget:  <code>yum -y install wget</code>  </p><h4 id="11-删除文件夹"><a href="#11-删除文件夹" class="headerlink" title="11. 删除文件夹"></a>11. 删除文件夹</h4><p>使用rm -rf 目录名字 命令即可<br>-r 就是向下递归，不管有多少级目录，一并删除<br>-f 就是直接强行删除，不作任何提示的意思<br>–force    忽略不存在的文件，从不给出提示。<br>-i, –interactive 进行交互式删除，在删除前询问用户是否操作<br>-r, -R, –recursive   指示rm将参数中列出的全部目录和子目录均递归地删除。<br>-v, –verbose    详细显示进行的步骤<br>–help     显示此帮助信息并退出<br>–version  输出版本信息并退出  </p><h4 id="12-移动文件"><a href="#12-移动文件" class="headerlink" title="12. 移动文件"></a>12. 移动文件</h4><p>mv [-fiv] source destination<br>参数说明：  </p><ul><li>-f:force，强制直接移动而不询问  </li><li>-i:若目标文件(destination)已经存在，就会询问是否覆盖  </li><li>-u:若目标文件已经存在，且源文件比较新，才会更新</li></ul><h4 id="13-复制文件"><a href="#13-复制文件" class="headerlink" title="13. 复制文件"></a>13. 复制文件</h4><p>cp [option] source1 source2 source3 … directory<br>cp -r dir1 dir2 : dir2 目录不存在<br>cp -r dir1&#x2F;. dir2 : dir2 目录已存在  </p><p>参数说明：  </p><ul><li>-a:是指archive的意思，也说是指复制所有的目录  </li><li>-d:若源文件为连接文件(link file)，则复制连接文件属性而非文件本身  </li><li>-f:强制(force)，若有重复或其它疑问时，不会询问用户，而强制复制  </li><li>-i:若目标文件(destination)已存在，在覆盖时会先询问是否真的操作  </li><li>-l:建立硬连接(hard link)的连接文件，而非复制文件本身  </li><li>-p:与文件的属性一起复制，而非使用默认属性  </li><li>-r:递归复制，用于目录的复制操作  </li><li>-s:复制成符号连接文件(symbolic link)，即“快捷方式”文件  </li><li>-u:若目标文件比源文件旧，更新目标文件</li></ul><h4 id="14-nginx-x2F-1-14-0-Ubuntu-Forbidden"><a href="#14-nginx-x2F-1-14-0-Ubuntu-Forbidden" class="headerlink" title="14. nginx&#x2F;1.14.0 (Ubuntu) Forbidden"></a>14. nginx&#x2F;1.14.0 (Ubuntu) Forbidden</h4><p>Nginx 出现 403 Forbidden 最终解决<br>步骤一：<br>    检查目录权限。权限不足的就加个权限吧。<br>    例子：chmod -R 755 &#x2F; var&#x2F;www<br>步骤二：<br>    打开nginx.conf<br>    例子：vim &#x2F;etc&#x2F;nginx&#x2F;nginx.conf<br>    把 user 用户名 改为 user root 或 其它有高权限的用户名称即可  </p><h4 id="15-standard-init-linux-go-190-exec-user-process-caused-“exec-format-error"><a href="#15-standard-init-linux-go-190-exec-user-process-caused-“exec-format-error" class="headerlink" title="15. standard_init_linux.go:190: exec user process caused “exec format error"></a>15. standard_init_linux.go:190: exec user process caused “exec format error</h4><p>Script脚本 开头必须加 #!&#x2F;bin&#x2F;bash<br><code>#</code>和<code>！</code>之间没有空格  </p><h4 id="16-centos中执行apt-get命令提示apt-get-command-not-found"><a href="#16-centos中执行apt-get命令提示apt-get-command-not-found" class="headerlink" title="16. centos中执行apt-get命令提示apt-get command not found"></a>16. centos中执行apt-get命令提示apt-get command not found</h4><p>在 centos 下用 yum install xxx</p><p>yum 和 apt-get 的区别  </p><p>一般来说著名的 linux 系统基本上分两大类：  </p><ol><li>RedHat 系列：Redhat、Centos、Fedora 等  </li><li>Debian 系列：Debian、Ubuntu 等</li></ol><p>RedHat 系列  </p><p>1. 常见的安装包格式 rpm 包,安装 rpm 包的命令是“rpm -参数”<br>2. 包管理工具 yum<br>3. 支持 tar 包  </p><p>Debian 系列  </p><p>1. 常见的安装包格式 deb 包,安装 deb 包的命令是“dpkg -参数”<br>2. 包管理工具 apt-get<br>3. 支持 tar 包   </p><p>原文：<a href="https://blog.csdn.net/lydong_/article/details/79812694">https://blog.csdn.net/lydong_/article/details/79812694</a>  </p><h4 id="15-Redis-安装"><a href="#15-Redis-安装" class="headerlink" title="15. Redis 安装"></a>15. Redis 安装</h4><ol><li>由于CentOS官方yum源里面没有Redis,这里我们需要安装一个第三方的yum源,这里用了Fedora的epel仓库<br>yum install epel-release<br>安装过程中会有让你确认的,输入y按回车就可以了  </li><li>安装Redis<br>yum install redis<br>安装过程中会有让你确认的,输入y按回车就可以了  </li><li>启动Redis<br>service redis start  </li><li>修改端口号&#x2F;密码等配置<br>vim &#x2F;etc&#x2F;redis.conf  </li><li>注释掉 ip 绑定(这个只允许本地调试,不注释掉这个,你远程这个 redis 的时候会提示:<br>redis.clients.jedis.exceptions.JedisConnectionException:  java.net.ConnectException: Connection refused: connect）  </li><li>关闭保护模式(不关闭的话远程这个 redis 会提示:<br>redis.clients.jedis.exceptions.JedisDataException: DENIED Redis is running in protected mode）</li></ol><p><a href="https://blog.csdn.net/haoxin963/article/details/82585684">https://blog.csdn.net/haoxin963/article/details/82585684</a>  </p><h4 id="16-虚拟机-IP"><a href="#16-虚拟机-IP" class="headerlink" title="16. 虚拟机 IP"></a>16. 虚拟机 IP</h4><p><code>ip a show docker0</code>： 查询指定 IP<br><code>ipconfig docker0</code>  </p><h4 id="17-linux-ping-command-not-found"><a href="#17-linux-ping-command-not-found" class="headerlink" title="17. linux ping: command not found"></a>17. linux ping: command not found</h4><p>apt-get install inetutils-ping  </p><h4 id="18-bash-vi-command-not-found"><a href="#18-bash-vi-command-not-found" class="headerlink" title="18. bash: vi: command not found"></a>18. bash: vi: command not found</h4><p>apt-get update<br>apt-get install vim  </p><h4 id="14-apt-get"><a href="#14-apt-get" class="headerlink" title="14. apt-get"></a>14. apt-get</h4><p>下载安装软件包的简单命令行接口<br><code>apt-get [OPTIONS] [COMMANDS] [PACKAGE_NAMES]</code>  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs routeros">OPTIONS:<br>-h      帮助信息<br>-q      输出到日志<br>-qq     不输出信息，错误除外<br>-d      仅下载（不安装或解压归档文件）<br>-s      不实际安装（模拟运行命令）<br>-y      假定对全部的询问选是<br>-f      尝试修正系统依赖损坏处<br>-m      假设归档无法定位，尝试继续<br>-u      同一时候显示更新软件包的列表<br>-b      获取源代码包后编译<br>-v      显示具体的版本<br><span class="hljs-attribute">-c</span>=？    阅读此配置文件<br><span class="hljs-attribute">-o</span>=?    设置自己定义的配置选项，如 -o dir::<span class="hljs-attribute">cache</span>=/tmp<br><br>COMMANDS:<br>update              又一次获取软件包列表<span class="hljs-built_in"></span><br><span class="hljs-built_in">upgrade </span>            进行更新<br>install             安装新的软件包<br><span class="hljs-built_in">remove</span>              移出软件包<br>autoremove          自己主动移出所有不使用的软件包<br>purge               移除软件包和配置文件<br>source              下载源代码档案<br>build-dep           为源代码包配置编译依赖<br>dist-upgrade        发行版升级<br>dselect-upgrade     按照 dselect 的选择更新<br>clean               清除下载的归档文件<br>autoclean           清除旧的已下载的归档文件<br>check               检验是否有损坏的依赖<br><br><br>经常使用实例：<br>apt-cache search PACKAGE_NAMES              搜索包<br>apt-cache show PACKAGE_NAMES                获取包的相关信息，如说明、大小、版本号等<br>apt-<span class="hljs-built_in">get</span> install PACKAGE_NAMES               安装包<br>apt-<span class="hljs-built_in">get</span> install PACKAGE_NAMES --reinstall           又一次安装包<br>apt-<span class="hljs-built_in">get</span> -f install PACKAGE_NAMES            修复安装包<br>apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> PACKAGE_NAMES                删除包<br>apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> PACKAGE_NAMES --purge                删除包，包含删除配置文件等<br>apt-<span class="hljs-built_in">get</span> update                      更新源<br>apt-<span class="hljs-built_in">get</span><span class="hljs-built_in"> upgrade </span>                    更新已安装的包<br>apt-<span class="hljs-built_in">get</span> dist-upgrade                        升级系统<br>apt-<span class="hljs-built_in">get</span> dselect-upgrade                 使用 dselect 升级<br>apt-cache depends PACKAGE_NAMES             了解使用依赖<br>apt-cache rdepends PACKAGE_NAMES            查看该包被那些包依赖<br>apt-<span class="hljs-built_in">get</span> build-dep PACKAGE_NAMES             安装相关的编译环境<br>apt-<span class="hljs-built_in">get</span> source PACKAGE_NAMES                下载该包的源码<br>apt-<span class="hljs-built_in">get</span> clean                               清理没用的包<br>apt-<span class="hljs-built_in">get</span> autoclean                           清理没用的包<br>apt-<span class="hljs-built_in">get</span> check                               检查是否有损坏的依赖<br></code></pre></td></tr></table></figure><h4 id="15-杀死包含-simple-service-的进程"><a href="#15-杀死包含-simple-service-的进程" class="headerlink" title="15. 杀死包含 simple-service 的进程"></a>15. 杀死包含 simple-service 的进程</h4><p><code>kill -s `ps -ef | grep simple-service | grep -v grep | awk &#39;&#123;print $2&#125;&#39;</code>  </p><h3 id="16-Jenkins-启动-Spring-Boot"><a href="#16-Jenkins-启动-Spring-Boot" class="headerlink" title="16. Jenkins 启动 Spring Boot"></a>16. Jenkins 启动 Spring Boot</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs gradle">#!<span class="hljs-regexp">/bin/</span>bash<br><br># export BUILD_ID=dontkillMe<br># www_path=<span class="hljs-regexp">/tmp/</span>jenkins-buildenv<span class="hljs-regexp">/springcloud_inaction/</span>www<br># jar_path=<span class="hljs-regexp">/tmp/</span>jenkins-buildenv<span class="hljs-regexp">/springcloud_inaction/</span>workspace<br># jar_name=spring<br><br>kill -s `ps -ef | <span class="hljs-keyword">grep</span> simple-service | <span class="hljs-keyword">grep</span> -v <span class="hljs-keyword">grep</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br><br>docker rm spring_demo -f<br><br>cd <span class="hljs-regexp">/var/</span>jenkins_home<span class="hljs-regexp">/workspace/</span><span class="hljs-string">&quot;SpringCloud In Action - Ch 01&quot;</span><span class="hljs-regexp">/simpleservice/</span>src<span class="hljs-regexp">/main/</span>docker<br># docker build -t dy/openjdk:<span class="hljs-number">8</span>-<span class="hljs-number">1.0</span> .<br><br># cd <span class="hljs-regexp">/var/</span>jenkins_home<span class="hljs-regexp">/workspace/</span><span class="hljs-string">&quot;SpringCloud In Action - Ch 01&quot;</span><span class="hljs-regexp">/simpleservice/</span>target<br># java -jar simple-service-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar --server.port=<span class="hljs-number">8088</span><br><br><br>cp -rf ..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/target/</span>simple-service-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar simple-service-<span class="hljs-number">0.0</span>.<span class="hljs-number">1</span>-SNAPSHOT.jar<br><br>docker build -f <span class="hljs-regexp">/var/</span>jenkins_home<span class="hljs-regexp">/workspace/</span><span class="hljs-string">&quot;SpringCloud In Action - Ch 01&quot;</span><span class="hljs-regexp">/simpleservice/</span>src<span class="hljs-regexp">/main/</span>docker<span class="hljs-regexp">/Dockerfile -t dy/</span>openjdk:<span class="hljs-number">8</span>-<span class="hljs-number">1.0</span> .<br><br>docker run -d -p <span class="hljs-number">8088</span>:<span class="hljs-number">8088</span> --name spring_demo dy/openjdk:<span class="hljs-number">8</span>-<span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>####17. abrt-cli…… no more mirrors to try<br>在 CentOS 使用 yum 安装软件的时候 出现错误 no more mirrors to try，导致软件无法继续安装。  </p><p>可能原因是不正当的删除造成的。  </p><p>尝试  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">yum clean <span class="hljs-keyword">all</span> <br>yum makecache <br>yum <span class="hljs-operator">-</span>y <span class="hljs-keyword">update</span><br></code></pre></td></tr></table></figure><p>然后重新安装  </p><p>原文：<a href="https://blog.csdn.net/qq_26769677/article/details/80439868">https://blog.csdn.net/qq_26769677/article/details/80439868</a>  </p><p>####18. centOS7下安装GUI图形界面<br>当你安装 centOS7 服务器版本的时候，系统默认是不会安装 GUI 的图形界面程序，这个需要手动安装 CentOS7 Gnome GUI 包  </p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs clean">yum grouplist<br>yum groupinstall <span class="hljs-string">&quot;GNOME Desktop&quot;</span> <span class="hljs-string">&quot;Graphical Administration Tools&quot;</span> ## 名字对应 grouplist 中的字段<br><br></code></pre></td></tr></table></figure><p>####19. VM 安装 Vmware tools</p><ol><li>启动 CentOS</li><li>菜单栏  —-&gt; 虚拟机 —-&gt;  重新安装 VMware Tools …  </li><li>Centos 桌面 打开 VMware Tools  </li><li>复制 VMwareTools-10.3.2-9925305.tar.gz 到 CentOS 随意目录  </li><li>cmd 进入该目录  </li><li><code>tar zxf VMwareTools-10.3.2-9925305.tar.gz</code>： 解压  </li><li><code>sudo ./vmware-tools-distrib/vmware-install.pl</code>: 执行，yes|no 的时候 y，其余回车即可  </li><li><code>reboot</code>： 重启  </li><li>菜单栏  —-&gt; 虚拟机 —-&gt;  设置  —-&gt;  选项  —-&gt;  共享文件夹  </li><li>总是启用  </li><li>文件夹 —-&gt; 添加  —-&gt;  主机路径（本机（windows）要共享数据的文件夹绝对路径）  —-&gt;  名称（CentOS 中该文件夹的名称（默认位于 &#x2F;mnt&#x2F;hgfs 目录下））</li></ol><p>####20. CentOS赋权限<br>修改 &#x2F;etc&#x2F;sudoers 文件，找到下面一行，在root下面添加一行，如下所示：  </p><h2 id="Allow-root-to-run-any-commands-anywhere"><a href="#Allow-root-to-run-any-commands-anywhere" class="headerlink" title="Allow root to run any commands anywhere"></a>Allow root to run any commands anywhere</h2><p>root    ALL&#x3D;(ALL)     ALL<br>tommy   ALL&#x3D;(ALL)     ALL<br>修改完毕，现在可以用tommy帐号登录，然后用命令 su - ，即可获得root权限进行操作。  </p><p>####21. Failed to start mysql.service: Unit not found.<br>yum list installed | grap mysql<br>卸载 (yum -yqq remove)<br>1.安装:<br><code>yum install -y mariadb-server</code><br>2.启动maria DB服务:<br><code>systemctl start mariadb.service</code><br>(说明：CentOS 7.x开始，CentOS开始使用systemd服务来代替daemon，原来管理系统启动和管理系统服务的相关命令全部由systemctl命令来代替。)<br>3.添加至开机自启动：<br><code>systemctl enable mariadb.service</code>  </p><p>在新版的 Mariadb 安装过程中没有设置密码的过程了，而用 <code>mysql_secure_installation</code> 命令设置 Root 密码<br>使用 <code>mysql -u root -p</code> 登录</p><p>####22. Office 2016激活<br>cmd<br>cscript “C:\Program Files\Microsoft Office\Office16\ospp.vbs” &#x2F;dstatus  </p><p>slmgr.vbs -xpr</p><p>slmgr &#x2F;xpr 00339-10000-00000-AA701</p><h4 id="23-宿主机不能访问虚拟机中CentOS的Tomcat服务器"><a href="#23-宿主机不能访问虚拟机中CentOS的Tomcat服务器" class="headerlink" title="23. 宿主机不能访问虚拟机中CentOS的Tomcat服务器"></a>23. 宿主机不能访问虚拟机中CentOS的Tomcat服务器</h4><p>CentOS 7，使用iptables的版本是7以前的，CentOS 7使用firewall作为防火墙。  </p><p>查看已经开放的端口： <code>firewall-cmd --list-ports</code><br>开启端口： <code>firewall-cmd --zone=public --add-port=80/tcp --permanent</code>  </p><p>命令含义：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">–zone <span class="hljs-comment">#作用域</span><br>–<span class="hljs-keyword">add</span><span class="language-bash">-port=80/tcp <span class="hljs-comment">#添加端口，格式为：端口/通讯协议</span></span><br>–permanent <span class="hljs-comment">#永久生效，没有此参数重启后失效</span><br></code></pre></td></tr></table></figure><p>重启、停止、禁用、查看防火墙  </p><p><code>firewall-cmd --reload</code> #重启firewall<br><code>systemctl stop firewalld.service</code> #停止firewall<br><code>systemctl disable firewalld.service</code> #禁止firewall开机启动<br><code>firewall-cmd --state</code> #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）  </p><p>因此结合上述命令来看，需要将8080端口添加到防火墙的开放端口中，然后重新载入防火墙的配置即可。如下：</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">sudo firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">zone=public</span> <span class="hljs-literal">--</span><span class="hljs-comment">add</span><span class="hljs-literal">-</span><span class="hljs-comment">port=8080/tcp</span> <span class="hljs-literal">--</span><span class="hljs-comment">permanent</span><br><span class="hljs-comment">sudo firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">reload</span><br><span class="hljs-comment">sudo firewall</span><span class="hljs-literal">-</span><span class="hljs-comment">cmd</span> <span class="hljs-literal">--</span><span class="hljs-comment">list</span><span class="hljs-literal">-</span><span class="hljs-comment">ports</span><br></code></pre></td></tr></table></figure><p>原文：<a href="https://blog.csdn.net/asahinokawa/article/details/82285390">https://blog.csdn.net/asahinokawa/article/details/82285390</a> </p><p>####24. windows 端口<br><code>netstat -ano</code>：列出所有端口的情况。<br><code>netstat -aon|findstr &quot;端口号&quot;</code>：查看被占用端口对应的PID<br><code>tasklist|findstr &quot;PID&quot;</code>：查看是哪个进程或者程序占用了</p><p>####25. Yum Remove<br><code>yum remove</code>会删除依赖的库<br>推荐使用 <code>rpm -e --nodeps xxx</code> 这种删除软件命令<br><a href="https://blog.kazaff.me/2018/12/20/yum%20remove%E5%AE%B3%E6%AD%BB%E4%BA%BA/">原文链接</a></p><p>####26.<br><code>rpm -qa | grep Java</code>： 查询出系统自带的 jdk<br>系统自带的 jdk  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">java</span>-<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-openjdk-<span class="hljs-number">1.8.0.191</span>.b12-<span class="hljs-number">1</span>.el7_6.x86_64  <br><span class="hljs-attribute">java</span>-<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-openjdk-headless-<span class="hljs-number">1.8.0.191</span>.b12-<span class="hljs-number">1</span>.el7_6.x86_64  <br><span class="hljs-attribute">java</span>-<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span>-openjdk-headless-<span class="hljs-number">1.7.0.201</span>-<span class="hljs-number">2.6.16.1</span>.el7_6.x86_64  <br><span class="hljs-attribute">java</span>-<span class="hljs-number">1</span>.<span class="hljs-number">7</span>.<span class="hljs-number">0</span>-openjdk-<span class="hljs-number">1.7.0.201</span>-<span class="hljs-number">2.6.16.1</span>.el7_6.x86_64  <br></code></pre></td></tr></table></figure><p><code>rpm -e --nodeps jdk名</code>： 删除系统自带的 jdk  </p><p><code>rpm -qa | grep Java</code>： 查询出是否删除掉  </p><p>查看系统有没有自带的 openjdk  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim">rpm -<span class="hljs-keyword">qa</span> |<span class="hljs-keyword">grep</span> java<br>rpm -<span class="hljs-keyword">qa</span> |<span class="hljs-keyword">grep</span> jdk<br>rpm -<span class="hljs-keyword">qa</span> |<span class="hljs-keyword">grep</span> gcj<br></code></pre></td></tr></table></figure><p><code>yum list java-1.8*</code>： 检索 yum 中有没有 java1.8<br><code>yum install java-1.8.0-openjdk.x86_64</code>： 安装 Java<br><code>yum install java-1.8.0-openjdk-devel.x86_64</code>： 解决 <code>bash: jsp: 未找到命令...</code><br><a href="https://blog.csdn.net/leshami/article/details/78562642">JPS 命令找不到的原文链接</a><br>jps 只显示 java 进程，准确的说是当前用户已启动的部分 java 进程信息，信息包括进程号和简短的进程 command。<br>(1) -q ：只显示 pid，不显示 class 名称，jar 文件名和传递给 main 方法的参数<br>(2) -m ：输出传递给 main 方法的参数，在嵌入式 jvm 上可能是 null<br>(3) -l ：输出应用程序 main class 的完整 package 名或者应用程序的 jar 文件完整路径名<br>(4) -v ：输出传递给JVM的参数<br>原文：<a href="https://blog.csdn.net/samyang1/article/details/80517657">https://blog.csdn.net/samyang1/article/details/80517657</a>  </p><p><a href="https://www.cnblogs.com/ios9/p/9333631.html">Java 安装</a>  </p><p><code>rpm -qa | grep jdk</code>： 查看 rpm 包安装的 jdk  </p><p>###27. centos 安装 maven</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crystal">[root<span class="hljs-variable">@localhost</span> docker_demo]<span class="hljs-comment"># vim /etc/profile</span><br><br>M2_HOME=~<span class="hljs-regexp">/application/apache</span>-maven-<span class="hljs-number">3.3</span>.<span class="hljs-number">3</span>/<br>export PATH=<span class="hljs-variable">$&#123;</span>M2_HOME&#125;/<span class="hljs-symbol">bin:</span><span class="hljs-variable">$&#123;</span>PATH&#125;<br><br>[root<span class="hljs-variable">@localhost</span> docker_demo]<span class="hljs-comment"># source /etc/profile</span><br>[root<span class="hljs-variable">@localhost</span> docker_demo]<span class="hljs-comment"># mvn -v</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>虚拟机</category>
      
    </categories>
    
    
    <tags>
      
      <tag>虚拟机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>单点登录</title>
    <link href="/2023/12/31/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95SSO/"/>
    <url>/2023/12/31/%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95SSO/</url>
    
    <content type="html"><![CDATA[<h3 id="单点登录SSO"><a href="#单点登录SSO" class="headerlink" title="单点登录SSO"></a>单点登录SSO</h3><p>Single Sign On，多系统应用群中登录一个系统，便可在其他所有系统中得到授权而无需再次登录<br>包括单点登录和单点注销两部分  </p><h4 id="1-登录"><a href="#1-登录" class="headerlink" title="1. 登录"></a>1. 登录</h4><p>需要一个独立的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供入口，只接受认证中心的间接授权。<br>间接授权通过令牌实现，SSO认证中心验证用户的用户名密码，没问题，创建授权令牌，在接下来的跳转过程中，授权令牌作为参数发送给各个子系统，子系统拿到令牌，得到授权，可以借此创建局部回话，局部会话登录方式与单系统的登录相同。  </p><p><a href="http://shuzheng5201314.iteye.com/blog/2343910">http://shuzheng5201314.iteye.com/blog/2343910</a></p>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>登录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>单点登录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SublimeText</title>
    <link href="/2023/12/31/SublimeText/"/>
    <url>/2023/12/31/SublimeText/</url>
    
    <content type="html"><![CDATA[<h2 id="Sublime-Text-使用指南"><a href="#Sublime-Text-使用指南" class="headerlink" title="Sublime Text 使用指南"></a>Sublime Text 使用指南</h2><h3 id="1-注册码"><a href="#1-注册码" class="headerlink" title="1. 注册码"></a>1. 注册码</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dns">----- BEGIN LICENSE -----<br>sgbteam<br>Single User License<br>EA7E-<span class="hljs-number">1153259</span><br><span class="hljs-number">8891</span>CBB9 F1513E4F <span class="hljs-number">1A3405C1</span> A865D53F<br><span class="hljs-number">115</span>F202E <span class="hljs-number">7</span>B91AB2D <span class="hljs-number">0</span>D2A40ED <span class="hljs-number">352</span>B269B<br><span class="hljs-number">76</span>E84F0B CD69BFC7 <span class="hljs-number">59</span>F2DFEF E267328F<br><span class="hljs-number">215652A3</span> E88F9D8F <span class="hljs-number">4</span>C38E3BA <span class="hljs-number">5</span>B2DAAE4<br><span class="hljs-number">969624E7</span> DC9CD4D5 <span class="hljs-number">717</span>FB40C <span class="hljs-number">1</span>B9738CF<br><span class="hljs-number">20B3C4F1</span> E<span class="hljs-number">917B5B3</span> <span class="hljs-number">87</span>C38D9C ACCE7DD8<br><span class="hljs-number">5</span>F7EF854 <span class="hljs-number">86</span>B9743C FADC04AA FB0DA5C0<br>F913BE58 <span class="hljs-number">42</span>FEA319 F954EFDD AE881E0B<br>------ END LICENSE ------<br></code></pre></td></tr></table></figure><p>Sublime Text 默认插件的安装目录为 C:\Users\用户名\AppData\Roaming\Sublime Text 3\Packages，可以将默认的目录下的 Packages 删除，在 Sublime 的安装路径下新建一个 Data 文件夹（D:\Program Files\Sublime Text 3\Data），则插件会被自动安装至该目录下。<br>设置(Preferences) &gt;&gt; 浏览资源包(Browse Packages …) 即是打开 sublime 的插件的安装路径</p><h3 id="2-安装-Package-Control"><a href="#2-安装-Package-Control" class="headerlink" title="2. 安装 Package Control"></a>2. 安装 Package Control</h3><p>由于 packagecontrol.io 这个地址无法打开，所以没法通过控制台安装</p><ol><li><p><a href="https://github.com/wbond/package_control/releases">点击</a>下载最新的 package control 解压到 Sublime Text 设置 &gt;&gt; 浏览资源包 目录下，并重命名为 Package Control</p></li><li><p>如果点击 设置（Perferences） &gt;&gt; Package Control 或者（ctrl + shift +p &gt;&gt; install Package）没有反应，则打开 设置 &gt;&gt; Package Settings &gt;&gt; Package Control &gt;&gt; Setting User，复制下面代码</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;<br>    <span class="hljs-string">&quot;channels&quot;</span>:<br>    [<br>        <span class="hljs-string">&quot;https://github.com/JavenZ/channel_v3/raw/master/channel_v3.json&quot;</span><br>    ],<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果报找不到 Package Control 或者 设置 &gt;&gt; 没有Package Control，则打开 设置 &gt;&gt; 用户设置，将 ignored_packages 属性中包含的 Package Control 删掉，即可</p></li></ol><h3 id="3-插件"><a href="#3-插件" class="headerlink" title="3. 插件"></a>3. 插件</h3><ol><li><p>LocalizedMenu<br>汉化插件，安装成功后 设置（Prefrences） &gt;&gt; 显示语言(Languages) 切换为中文即可  </p></li><li><p>Emmet<br>编码快捷键，使用教材： <a href="http://docs.emmet.io/cheat-sheet/%E3%80%81http://peters-playground.com/Emmet-Css-Snippets-for-Sublime-Text-2/">http://docs.emmet.io/cheat-sheet/、http://peters-playground.com/Emmet-Css-Snippets-for-Sublime-Text-2/</a></p></li><li><p>html-css-jsprettify<br>对 Html&#x2F;CSS&#x2F;JS文件进行格式化，代替了 JsFormat 和 CSSFormat<br>快捷键配置:  <code>&#123;&quot;keys&quot;: [&quot;ctrl+shift+i&quot;],&quot;command&quot;: &quot;htmlprettify&quot;&#125;,</code></p></li><li><p>Color Highlighter<br>颜色选择器  </p></li><li><p>Agila Theme<br>设置 &gt;&gt; 主题方案 可更改主题方案  </p></li><li><p>Alignment<br>“&#x3D;” 号对齐，默认快捷键 <code>ctrl+shift+a</code>  </p></li><li><p>All Autocomplete<br>搜索所有打开的文件来寻找匹配的提示词  </p></li><li><p>AutoFileName<br>对文件路径补全提示，使用 <code>\</code> 即可看到相对于本项目文件夹的其他文件  </p></li><li><p>BracketHighlighter<br>代码匹配，让你的代码有不同的颜色区分该插件提供的匹对标签，或大括号或字符串引号的配对的高亮显示  </p></li><li><p>ConvertToUTF8<br>文件转码成 utf-8  </p></li><li><p>DocBlockr<br>生成注释  </p></li><li><p>IMESupport<br>Sublime 中文输入法 跟随光标  </p></li><li><p>JavaScript Completions<br>对 javascript 原生语法提示  </p></li><li><p>jQuery<br>对 jQuery 函数提示  </p></li><li><p>Keymaps<br>快速查找所有插件的快捷键  </p></li><li><p>MarkdownEditing<br>MarkdownEditing: Markdown 编辑器，可以高亮显示 Markdown 语法还支持很多编程语言的语法高亮显示。<br>只针对 md\mdown\mmd\txt 格式文件才启用<br>Markdown __去除左侧空白和更改主题__：<br>打开 设置 &gt;&gt; Package Settings &gt;&gt; Markdown Editing，然后打开 Markdown GFM Settings - Default 和 Markdown GFM Settings - User，将以下内容从 default 拷贝至 user:  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;color_scheme&quot;</span>: <span class="hljs-string">&quot;Packages/MarkdownEditing/MarkdownEditor.tmTheme&quot;</span>,<br>    <span class="hljs-string">&quot;color_scheme&quot;</span>: <span class="hljs-string">&quot;Packages/MarkdownEditing/MarkdownEditor-Dark.tmTheme&quot;</span>,<br>    <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;color_scheme&quot;</span>: <span class="hljs-string">&quot;Packages/MarkdownEditing/MarkdownEditor-Yellow.tmTheme&quot;</span>,<br>    <span class="hljs-regexp">//</span> Markdown 主题颜色<br><br>    <span class="hljs-string">&quot;draw_centered&quot;</span>: false, <span class="hljs-regexp">//</span> 两侧空白是否需要<br>    <span class="hljs-string">&quot;line_numbers&quot;</span>: true, <span class="hljs-regexp">//</span> 行号是否显示<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>MarkdownEditing<br>MarkdownPreview: 支持在浏览器中预览 markdown 文件以及将 md 导出为 html<br>快捷键打开设置： 设置 &gt;&gt; 热键设置  添加 <code>&#123; &quot;keys&quot;: [ &quot;alt+m&quot; ], &quot;command&quot;: &quot;markdown_preview&quot;, &quot;args&quot;: &#123;&quot;target&quot;: &quot;browser&quot;, &quot;parser&quot;:&quot;markdown&quot;&#125; &#125;,</code>  </p></li><li><p>Nodejs<br>node 代码提示，<a href="https://sublime.wbond.net/packages/Nodejs">教程</a><br>配置方法：</p></li></ol><ul><li><p>第一种：<br>设置 &gt;&gt; 浏览资源包 &gt;&gt; Nodejs &gt;&gt; Nodejs.sublime-build  </p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs nsis">&#123;<br>  <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>],<br>  <span class="hljs-string">&quot;file_regex&quot;</span>: <span class="hljs-string">&quot;^[ ]*File \&quot;</span>(...*?)\<span class="hljs-string">&quot;, line ([0-9]*)&quot;</span>,<br>  <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.js&quot;</span>,<br>  <span class="hljs-string">&quot;shell&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-string">&quot;encoding&quot;</span>: <span class="hljs-string">&quot;utf8&quot;</span>,<br>  <span class="hljs-string">&quot;windows&quot;</span>:<br>    &#123;<br>//        <span class="hljs-string">&quot;shell_cmd&quot;</span>: <span class="hljs-string">&quot;taskkill /F /IM node.exe &amp; node <span class="hljs-variable">$file</span>&quot;</span><br>//            <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;taskkill&quot;</span>, <span class="hljs-string">&quot;/F&quot;</span>, <span class="hljs-string">&quot;/IM&quot;</span>, <span class="hljs-string">&quot;node.exe&quot;</span>, <span class="hljs-string">&quot;&amp;&quot;</span>, <span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>]<br>        <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>]<br>    &#125;,<br>    <span class="hljs-string">&quot;linux&quot;</span>:<br>    &#123;<br>        <span class="hljs-string">&quot;shell_cmd&quot;</span>: <span class="hljs-string">&quot;killall node; /usr/bin/env node <span class="hljs-variable">$file</span>&quot;</span><br>    &#125;,<br>    <span class="hljs-string">&quot;osx&quot;</span>:<br>    &#123;<br>        <span class="hljs-string">&quot;shell_cmd&quot;</span>: <span class="hljs-string">&quot;killall node; /usr/bin/env node <span class="hljs-variable">$file</span>&quot;</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Nodejs.sublime-settings  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>  <span class="hljs-regexp">//</span> save before running commands<br>  <span class="hljs-string">&quot;save_first&quot;</span>: true,<br>  <span class="hljs-regexp">//</span> <span class="hljs-keyword">if</span> present, use this command instead of plain <span class="hljs-string">&quot;node&quot;</span><br>  <span class="hljs-regexp">//</span> e.g. <span class="hljs-string">&quot;/usr/bin/node&quot;</span> or <span class="hljs-string">&quot;C:\bin\node.exe&quot;</span><br>  <span class="hljs-string">&quot;node_command&quot;</span>: <span class="hljs-string">&quot;D:/Program Files/nodejs/node.exe&quot;</span>,<br>  <span class="hljs-regexp">//</span> Same <span class="hljs-keyword">for</span> NPM command<br>  <span class="hljs-string">&quot;npm_command&quot;</span>: <span class="hljs-string">&quot;d:/Program Files/nodejs/npm.cmd&quot;</span>,<br>  <span class="hljs-regexp">//</span> as <span class="hljs-string">&#x27;NODE_PATH&#x27;</span> environment variable <span class="hljs-keyword">for</span> node runtime<br>  <span class="hljs-string">&quot;node_path&quot;</span>: false,<br><br>  <span class="hljs-string">&quot;expert_mode&quot;</span>: false,<br><br>  <span class="hljs-string">&quot;output_to_new_tab&quot;</span>: false<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>第二种<br>工具 &gt;&gt; 编译系统 &gt;&gt; 新建编译系统…  粘贴以下代码并保存为 node.sublime-build：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">&#123;<br>    <span class="hljs-string">&quot;cmd&quot;</span>: [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;--use-strict&quot;</span>, <span class="hljs-string">&quot;--harmony&quot;</span>, <span class="hljs-string">&quot;<span class="hljs-variable">$file</span>&quot;</span>], <br>    <span class="hljs-string">&quot;selector&quot;</span>: <span class="hljs-string">&quot;source.js&quot;</span>, <br>&#125;<br></code></pre></td></tr></table></figure><p>即可<br>在js页面选择 工具 &gt;&gt; 编译系统 &gt;&gt; node，然后 <code>ctrl + b</code> 即可</p></li></ul><ol start="19"><li><p>SideBarEnhancements<br>扩充左侧菜单的功能</p></li><li><p>SublimeREPL<br>允许你在 Sublime Text 允许各种语言  </p></li><li><p>SyncedSideBar<br>自动展开打开的文件梭子的目录  </p></li><li><p>Terminal<br>使用终端<br>在 设置 &gt;&gt; Package Settings &gt;&gt; Terminal &gt;&gt; Settings-User 中添加：  </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift">&#123;<br>    <span class="hljs-string">&quot;terminal&quot;</span>: <span class="hljs-string">&quot;C:<span class="hljs-subst">\\</span>windows<span class="hljs-subst">\\</span>system32<span class="hljs-subst">\\</span>cmd.exe&quot;</span>,<br>    <span class="hljs-string">&quot;parameters&quot;</span>: [<span class="hljs-string">&quot;/START&quot;</span>,<span class="hljs-string">&quot;%CWD%&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>还有 CMD-Caller 插件也可以打开 cmd<br>需要配置：  </p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nsis">&#123;<br>    <span class="hljs-string">&quot;windows&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;default&quot;</span>: <span class="hljs-string">&quot;CMD&quot;</span>,<br>        <span class="hljs-string">&quot;apps&quot;</span>:&#123;<br>            <span class="hljs-string">&quot;CMD&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Run cmd.exe Here&quot;</span>,<br>            <span class="hljs-string">&quot;cmd&quot;</span>: <span class="hljs-string">&quot;cmd.exe /s /k pushd \&quot;</span><span class="hljs-variable">$&#123;file_path&#125;</span>\<span class="hljs-string">&quot;&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>TrailingSpaces<br>检查并意见去除代码中多余的空格<br>快捷键设置： <code>&#123; &quot;keys&quot;: [&quot;ctrl+shift+t&quot;], &quot;command&quot;: &quot;delete_trailing_spaces&quot; &#125;，</code>  </p></li><li><p>View In Browser<br>通过浏览器打开文件<br>打开 设置 &gt;&gt; Package Settings &gt;&gt; View In Browser &gt;&gt; Settings Default 和 Settings User，将 default 中的以下内容拷贝到 user:  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">&#123;<br>    <span class="hljs-string">&quot;nt&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;win32&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;chrome&quot;</span>: <span class="hljs-string">&quot;C:/Program Files (x86)/Google/Chrome/Application/chrome.exe&quot;</span>, <span class="hljs-regexp">//</span> 浏览器路径<br>        &#125;<br>    &#125;,<br><br>    <span class="hljs-string">&quot;browser&quot;</span>: <span class="hljs-string">&quot;chrome&quot;</span> <span class="hljs-regexp">//</span> 默认浏览器<br>&#125;<br><br></code></pre></td></tr></table></figure><p>快捷键设置： <code>&#123; &quot;keys&quot;: [ &quot;alt+k&quot; ], &quot;command&quot;: &quot;view_in_browser&quot;, &quot;args&quot;: &#123; &quot;browser&quot;: &quot;chrome&quot; &#125; &#125;,</code>  </p></li><li><p>Vue Syntax Highlight<br>Vue 高亮</p></li></ol><h3 id="4-常用快捷键"><a href="#4-常用快捷键" class="headerlink" title="4. 常用快捷键"></a>4. 常用快捷键</h3><p><code>Ctrl+D</code> 选中一个单词，继续 <code>Ctrl+D</code>可以直接选中下一个相同的单词进入多光标模式，在多光标模式下可以在多处位置同时进行编辑。  </p><p><code>Ctrl+L</code> 选中当前光标所在的行。可以快速选中一行，而不用通过鼠标点击行首来选中一行。  </p><pre><code class="hljs">- 多行选择: 按住Ctrl键同时鼠标左键点击你想要选择的行的行首。  - 多光标模式: 按住Ctrl键同时鼠标左键点击你想要编辑的位置，可以在代码中插入多个光标，同时进行编辑。  - 列选择模式: 按住Shift键同时鼠标右键选择列，同时进入多光标模式进行多行编辑。  </code></pre><p><code>Shift+Delete</code> 直接删除一行，或者<code>Ctrl+Shift+K</code>  </p><p><code>Ctrl+Delete</code> 向前删除，即删除光标所在位置内容的剩余部分。  </p><p><code>Ctrl+Backspace</code> 向后删除，即删除光标所在位置之前的内容。  </p><p><code>Alt/ Alt+Shift-</code> 向后或者向前导航跳转。该快捷键在配合<code>Ctrl+P</code>时十分有用。  </p><p><code>Ctrl+[ 或 ]</code> 代码缩进。  </p><p><code>Ctrl+Shift+Up 或 Down</code> 将当前行向上移动一行或向下移动一行。  </p><p><code>Ctrl+Shift+D</code> 快速复制一行。  </p><p><code>Ctrl+/</code> 注释或去掉注释。  </p><p><code>Ctrl+K+K</code> 从当前光标位置直接删除到行末。  </p><p><code>Ctrl+K+Backspace</code> 从当前光标位置直接删除到行首（不常用）。  </p><p><code>Ctrl+Shift+Enter</code> 在当前光标所在的行之前插入一行。  </p><p><code>Ctrl+Enter</code> 在当前光标所在的行之后插入一行。  </p><p><code>Ctrl+K+U</code> 将光标所在的内容变成大写字母（不用选中单词）。  </p><p><code>Ctrl+K+L</code> 将光标所在的内容变成小写字母（不用选中单词）。  </p><p><code>Alt+Left/Right</code> 向左或向右移动光标时，每次移动一个单词的位置。如果不加Alt键每次只移动一个字符的位置。  </p><p><code>Alt+Shift+Left/Right</code> 从当前光标所在位置向左或向右选择整个内容。  </p><p><code>Ctrl+Shift+V</code> 在当前光标所在位置粘贴代码，并保持代码缩进和格式不变。  </p><p><code>Ctrl+P</code> 打开快速文件切换面板。  </p><p><code>Ctrl+W</code> 关闭当前tab。  </p><p><code>Ctrl+/-</code> 放大或缩小字体。  </p><p><code>Ctrl+K+B</code> 隐藏或显示side bar  </p><hr><h5 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h5><ol><li><p>Markdown<br><a href="https://blog.csdn.net/qq_20011607/article/details/81370236">https://blog.csdn.net/qq_20011607/article/details/81370236</a><br><a href="https://blog.csdn.net/TheMisery_Hang/article/details/80176317">https://blog.csdn.net/TheMisery_Hang/article/details/80176317</a>  </p></li><li><p>View In Browser<br><a href="https://www.jianshu.com/p/686672aff949">https://www.jianshu.com/p/686672aff949</a><br><a href="https://www.cnblogs.com/qwj-sysu/p/4058840.html">https://www.cnblogs.com/qwj-sysu/p/4058840.html</a>  </p></li><li><p>插件<br><a href="https://www.jianshu.com/p/3cb5c6f2421c">https://www.jianshu.com/p/3cb5c6f2421c</a><br><a href="https://www.cnblogs.com/qingkong/p/5039527.html">https://www.cnblogs.com/qingkong/p/5039527.html</a><br><a href="https://cloud.tencent.com/developer/news/303054">https://cloud.tencent.com/developer/news/303054</a><br><a href="https://www.cnblogs.com/junwu/p/5660934.html">https://www.cnblogs.com/junwu/p/5660934.html</a><br><a href="https://www.cnblogs.com/jaxu/p/5037547.html">https://www.cnblogs.com/jaxu/p/5037547.html</a>  </p></li><li><p>Package Control 安装<br><a href="https://www.eyuyun.com/246.html">https://www.eyuyun.com/246.html</a>  </p></li><li><p>NodeJs<br><a href="https://www.jianshu.com/p/3cb5c6f2421c">https://www.jianshu.com/p/3cb5c6f2421c</a><br><a href="https://www.jianshu.com/p/7f7c7f3d98b9">https://www.jianshu.com/p/7f7c7f3d98b9</a><br><strong><a href="https://blog.csdn.net/tangxiujiang/article/details/76620701">https://blog.csdn.net/tangxiujiang/article/details/76620701</a></strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>笔记</category>
      
      <category>编辑本</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SublimeText</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows操作命令</title>
    <link href="/2023/03/01/%E5%91%BD%E4%BB%A4/window%E5%91%BD%E4%BB%A4/"/>
    <url>/2023/03/01/%E5%91%BD%E4%BB%A4/window%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>windows基本操作命令汇总</p><span id="more"></span><h3 id="一、目录文件操作"><a href="#一、目录文件操作" class="headerlink" title="一、目录文件操作"></a>一、目录文件操作</h3><p><code>cd /d 路径</code>： 从该驱动器切换到另一个驱动器<br><code>cd路径</code>： 同磁盘时,切换目录<br><code>dir</code>: 显示目录中的文件<br><code>dir 路径</code>: 可查看指定路径下的文件<br><code>md 路径</code>: 创建目录<br><code>rd 路径</code>： 删除空文件夹<br><code>rd /s 路径</code>： 删除目录树<br><code>move 源文件路径及名字 目标文件路径及名字</code>: 移动文件并重命名文件和目录<br><code>copy 源文件路径及名字 目标文件路径及名字</code>: 复制文件<br><code>del 文件[ 文件]</code>: 删除文件夹和子文件夹下所有的文件，但是均不会删除文件夹  </p><h3 id="文本相关操作"><a href="#文本相关操作" class="headerlink" title="文本相关操作"></a>文本相关操作</h3><p><code>type 路径</code>： 显示文本文件的内容<br><code>数据 &gt; 路径</code>： 将显示的数据写入到路径文件内<br><code>findstr 字符 路径</code>： 显示一行<br><code>findstr /n 字符 路径</code>： 显示一行，并标记行号<br><code>命令 | 命令</code>：将前面命令的执行结果作为后面命令的操作对象</p><h3 id="网络相关操作"><a href="#网络相关操作" class="headerlink" title="网络相关操作"></a>网络相关操作</h3><p><code>ipconfig</code>: 查看tcp、ip参数<br><code>ipconfig /all</code>: 查看所有网卡的tcp&#x2F;ip参数（ip地址、子网掩码、默认网关、mac地址、dhcp地址、dns地址、主机名）<br><code>ipconfig /release</code>: 释放tcp&#x2F;ip参数<br><code>ipconfig /renew</code>: 重新获取tcp&#x2F;ip参数<br><code>ipconfig /flushdns</code>: 刷新dns缓存<br><code>ping -n 次数 -l 长度 ip/域名</code><br><code>ping -t ip/域名</code>: 一直不停的ping<br><code>ping -a ip/域名</code>: 返回ip的主机名<br><code>tracert ip/域名</code>： 路由追踪<br><code>route print -4</code>: 打印路由<br><code>route add 目标地址或网络 网关地址</code>： 添加路由条目<br><code>route delete 目标网络</code>： 删除路由条目<br><code>netstat -anop tcp</code></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://blog.csdn.net/qq_63701832/article/details/127852530">windows常见的命令操作大全</a></p>]]></content>
    
    
    <categories>
      
      <category>教程</category>
      
      <category>windows 命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Demo</title>
    <link href="/2023/02/24/demo/demo/"/>
    <url>/2023/02/24/demo/demo/</url>
    
    <content type="html"><![CDATA[<p>摘要</p><span id="more"></span><p>正文</p><h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><p>这是个demo</p><p>测试文章</p>]]></content>
    
    
    <categories>
      
      <category>示例</category>
      
    </categories>
    
    
    <tags>
      
      <tag>demo</tag>
      
      <tag>示例</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
